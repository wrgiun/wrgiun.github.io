<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="giun">
<meta property="og:url" content="https://wrgiun.github.io/index.html">
<meta property="og:site_name" content="giun">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="giun">






  <link rel="canonical" href="https://wrgiun.github.io/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>giun</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">giun</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wrgiun.github.io/2019/09/12/Python知识整合（操作数据库）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="giun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/12/Python知识整合（操作数据库）/" class="post-title-link" itemprop="url">Python知识整合（操作数据库）</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-12 20:47:57 / 修改时间：20:56:28" itemprop="dateCreated datePublished" datetime="2019-09-12T20:47:57+08:00">2019-09-12</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1、数据库编程接口"><a href="#1、数据库编程接口" class="headerlink" title="1、数据库编程接口"></a>1、数据库编程接口</h1><p>市面有多种数据库如mysql、SQLite等等。为了对数据库进行统一的操作，大多数语言提供了简单的、标准化的数据库接口（API）。在Python Database API 2.0规范中，定义了Python数据库API接口的各个部分。下面我将介绍数据库API接口中的连接对象和游标对象</p>
<h2 id="1-1、连接对象"><a href="#1-1、连接对象" class="headerlink" title="1.1、连接对象"></a>1.1、连接对象</h2><p>数据库连接对象（Connection Object）主要提供数据库游标对象和提交/回滚事物的方式，以及关闭数据库连接。</p>
<h3 id="1-11、获取连接对象"><a href="#1-11、获取连接对象" class="headerlink" title="1.11、获取连接对象"></a>1.11、获取连接对象</h3><p>使用connect（）函数获取数据库连接，改函数具有多个参数，具体使用那个参数，根据数据库的类型而定。</p>
<p> onnect()函数参数说明表</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>dsn</td>
<td>数据源名称，给出该参数表示数据库依赖</td>
</tr>
<tr>
<td>user</td>
<td>用户名</td>
</tr>
<tr>
<td>password</td>
<td>用户密码</td>
</tr>
<tr>
<td>host</td>
<td>主机名</td>
</tr>
<tr>
<td>database</td>
<td>数据库名称</td>
</tr>
</tbody>
</table>
<p>例子，使用PyMySql模块连接MySQL数据库（在下面内容中会详细介绍）。</p>
<pre><code>conn = pymysql.connect(host=&apos;localhost&apos;, 
                        user=&apos;user&apos;,
                        password=&apos;passwd&apos;,
                        charset=&apos;utf-8&apos;
                        cursorclass=pymysql.cursors.DictCursor)
</code></pre><p>注意pymysql.connect()使用的参数与上表不完全相同，要以具体的数据库模块为准。</p>
<h3 id="1-12、连接对象方法"><a href="#1-12、连接对象方法" class="headerlink" title="1.12、连接对象方法"></a>1.12、连接对象方法</h3><p>connect（）函数返回连接对象，这个连接对象表示目前和数据库的会话。连接对象支持的方法如下表<br>| 方法名     | 说明                                                         |<br>| ———- | ———————————————————— |<br>| close()    | 关闭数据库连接                                               |<br>| commit()   | 提交事物                                                     |<br>| rollback() | 回滚事物                                                     |<br>| cursor()   | 获取游标对象，操作数据库，如执行DML（触发器）操作，调用存储过程等 |</p>
<h2 id="1-2、游标对象"><a href="#1-2、游标对象" class="headerlink" title="1.2、游标对象"></a>1.2、游标对象</h2><p>游标对象（Cursor Object）代表数据库中的游标，用于指示抓取数据操作的上下文，主要提供执行SQL语句、调用存储过程等。</p>
<p>通过cursor（）方法可以获取游标对象。</p>
<p>游标对象的属性：1、description:数据库列表类型和值的描述信息。2、rowcount():返回结果的函数统计信息，如SELECT、UPDATE等</p>
<p>游标对象的方法如下表<br>| 方法名                             | 说明                                                         |<br>| ———————————- | ———————————————————— |<br>| callproc(procname[,parameters])    | 调用存储过程，需要数据库支持                                 |<br>| close()                            | 关闭当前游标                                                 |<br>| execute（operation[,parameters])   | 执行SQL语句或者数据库命令等数据库操作                        |<br>| executemany（operation,seq_params) | 用于批量操作，如批量删除                                     |<br>| fetchone()                         | 获取查询结果集中的下一条记录                                 |<br>| fetchmany(size)                    | 获取指定数量的记录                                           |<br>| fetchall()                         | 获取结果集中的所有记录                                       |<br>| nextset()                          | 跳至下一个可用的结果集                                       |<br>| arraysize()                        | 指定使用fetchmany获取的函数，默认为1                         |<br>| setinputsize(sizes)                | 设置在调用execute*()方法时分配的内存区域大小                 |<br>| setoutputsize(sizes)               | 设置列缓冲区大小，对大数据列如LONGS和BLOBS（二进制大对象）尤其有用 |</p>
<h1 id="2、使用SQLite"><a href="#2、使用SQLite" class="headerlink" title="2、使用SQLite"></a>2、使用SQLite</h1><p>SQLite（c语言写的）是一种嵌入式数据库，它的数据库是一个文件。体积小，且可以跨平台使用，经常被嵌入到各种应用程序。python中内置了SQLite3。</p>
<h2 id="2-1、创建数据库文件"><a href="#2-1、创建数据库文件" class="headerlink" title="2.1、创建数据库文件"></a>2.1、创建数据库文件</h2><p>python操作数据流的流程</p>
<pre><code>开始&gt;&gt;创建connection(连接)&gt;&gt;获取cursor(游标)&gt;&gt;执行SQL语句，处理数据结果&gt;&gt;关闭cursor(游标)&gt;&gt;关闭connection(连接)
</code></pre><p>​<br>如</p>
<pre><code>import sqlite3   # 连接到SQLite数据库
conn = sqlite3.connect(&apos;1.db&apos;)   # 数据库文件是test.db，如果文件不存在，会在当前目录创建
cursor = conn.cursor()  # 创建一个Cursor
cursor.execute(&apos;create table user (id int(10) primary key, name varchar(20))&apos;)  # 执行一条SQL操作，创建user表
cursor.close()  # 关闭游标
conn.close()  # 关闭连接
</code></pre><h2 id="2-2、操作SQLite"><a href="#2-2、操作SQLite" class="headerlink" title="2.2、操作SQLite"></a>2.2、操作SQLite</h2><h3 id="2-21、新增用户数据信息"><a href="#2-21、新增用户数据信息" class="headerlink" title="2.21、新增用户数据信息"></a>2.21、新增用户数据信息</h3><p>使用以下SQL语句</p>
<pre><code>insert into 表名 （字段名1，字段名1，........） values(字段值1，字段值2，.......）
</code></pre><p>例子</p>
<pre><code>import sqlite3   # 连接到SQLite数据库
conn = sqlite3.connect(&apos;name.db&apos;)   # 数据库文件是test.db，如果文件不存在，会在当前目录创建
cursor = conn.cursor()  # 创建一个Cursor
# 执行一条SQL操作，创建user表
cursor.execute(&apos;create table user (id int(10) primary key, name varchar(20))&apos;)
# 执行一条SQL操作，向表user插入一条记录
cursor.execute(&apos;insert into user (id, name) values (&quot;1&quot;,&quot;wr&quot;)&apos;)
cursor.execute(&apos;insert into user (id, name) values (&quot;2&quot;,&quot;小明&quot;)&apos;)
cursor.close()  # 关闭游标
conn.commit()  # 提交事物
conn.close()  # 关闭连接
</code></pre><p>为了验证程序是否正常可以再次运行程序，如果出现如下异常</p>
<pre><code>sqlite3.OperationalError: table user already exists
</code></pre><p>则说明数据成功插入</p>
<h3 id="2-22、查看用户数据信息"><a href="#2-22、查看用户数据信息" class="headerlink" title="2.22、查看用户数据信息"></a>2.22、查看用户数据信息</h3><p>可以使用以下SQL语句</p>
<pre><code>select 字段名1，字段名2,..... from 表名 where 查询条件
</code></pre><p>fetchone():查询结果集中的下一条记录<br>fetchmany(size) :获取指定数量的记录<br>fetchall():获取结果集的所有记录</p>
<p>例子</p>
<pre><code>import sqlite3   # 连接到SQLite数据库
conn = sqlite3.connect(&apos;name.db&apos;)   # 数据库文件是name.db，如果文件不存在，会在当前目录创建
cursor = conn.cursor()  # 创建一个Cursor

# 执行查询语句
cursor.execute(&apos;select * from user&apos;) 
# 获取查询结果
result = cursor.fetchone()
print(result)

cursor.close()  # 关闭游标
conn.close()  # 关闭连接
</code></pre><p>修改上述    <code>cursor.execute(&#39;select * from user&#39;)</code> 这句代码为<code>cursor.execute(&#39;select * from user where id  &gt; ?&#39;,(1,))</code>，其中使用问号作为占位符代替具体的值，然后使用最后一个元组来替换问号，注意元组最后面的逗号不能省略<br>修改后的代码等价于<code>cursor.execute(&#39;select * from user where id  &gt; 1)</code><br>不过推荐占位符的方式，因为可以有效防止SQL注入</p>
<h3 id="2-23、修改用户数据信息"><a href="#2-23、修改用户数据信息" class="headerlink" title="2.23、修改用户数据信息"></a>2.23、修改用户数据信息</h3><p>可以使用以下sql语句</p>
<pre><code>update 表名 set 字段名 = 字段值 where 查询语句
</code></pre><p>例子，将ID=1的name改为WR</p>
<pre><code>import sqlite3   # 连接到SQLite数据库
conn = sqlite3.connect(&apos;name.db&apos;)   # 数据库文件是test.db，如果文件不存在，会在当前目录创建
cursor = conn.cursor()  # 创建一个Cursor

cursor.execute(&apos;update user set name = ? where id = ?&apos;, (&apos;WR&apos;, 1))
# 执行查询语句
cursor.execute(&apos;select * from user&apos;)
# 获取查询结果
result1 = cursor.fetchall()
print(result1)

cursor.close()  # 关闭游标
conn.commit() # 提交事务
conn.close()  # 关闭连接
</code></pre><h3 id="2-24、删除用户信息"><a href="#2-24、删除用户信息" class="headerlink" title="2.24、删除用户信息"></a>2.24、删除用户信息</h3><p>可以使用以下sql语句</p>
<pre><code>delete from 表名 where 查询语句
</code></pre><h1 id="3、使用MySQL"><a href="#3、使用MySQL" class="headerlink" title="3、使用MySQL"></a>3、使用MySQL</h1><p>可以直接安装phpstudy集成环境，包括mysql和apache数据库及其环境。安装步骤可以百度</p>
<h2 id="3-1、安装PyMySQL模块"><a href="#3-1、安装PyMySQL模块" class="headerlink" title="3.1、安装PyMySQL模块"></a>3.1、安装PyMySQL模块</h2><p>在python中支持MYSQL的数据库模块很多，我们选择PyMySQL模块<br>在命令行使用下面语句 <code>pip install PyMySQL</code>安装PyMySQL模块</p>
<h2 id="3-2、连接数据库"><a href="#3-2、连接数据库" class="headerlink" title="3.2、连接数据库"></a>3.2、连接数据库</h2><p>PyMySQL模块也遵循Python Database API 2.0规范，故MySQL的操作方法与SQLite类似<br>例子</p>
<pre><code>import pymysql

# 打开数据库连接，参数1：主机名或IP;参数2：用户名；参数3：密码；参数4；数据库名称
db = pymysql.connect(&quot;localhost&quot;, &quot;root&quot;, &quot;root&quot;, &quot;mydata&quot;)
# 通过cursor()函数创建一个游标对象cursor
cursor = db.cursor()
# 使用execute()方法执行SQL查询
cursor.execute(&apos;SELECT VERSION()&apos;)
# 使用 fetchone()方法获取单条信息
data = cursor.fetchone()
print(&quot;database version： %s&quot; % data)
# 关闭数据库连接、
db.close()
</code></pre><p>输出</p>
<pre><code>database version： 5.5.53
</code></pre><h2 id="3-3、创建数据表"><a href="#3-3、创建数据表" class="headerlink" title="3.3、创建数据表"></a>3.3、创建数据表</h2><p>例子:通过execute()方法创建表books(图书表)。books包含id(主键)，name(图书名)，category（图书馆分类），price(图书馆价格)</p>
<pre><code>import pymysql

# 打开数据库连接，参数1：主机名或IP;参数2：用户名；参数3：密码；参数4；数据库名称
db = pymysql.connect(&quot;localhost&quot;, &quot;root&quot;, &quot;390800956&quot;, &quot;mydata&quot;)
# 通过cursor()函数创建一个游标对象cursor
cursor = db.cursor()
# 使用execute()方法执行SQL语句，如果存在就删除
cursor.execute(&apos;DROP TABLE IF EXISTS books&apos;)
sql = &quot;&quot;&quot;
CREATE TABLE books(
    id int(8) NOT NULL AUTO_INCREMENT,
    name varchar(50) NOT NULL,
    category varchar(50) NOT NULL,
    price decimal(10,2) DEFAULT NULL,
    PRIMARY KEY (id)   
)   ENGINE=MyISAM AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
&quot;&quot;&quot;
cursor.execute(sql)

# 关闭数据库连接、
db.close()
</code></pre><h2 id="3-4、操作数据表"><a href="#3-4、操作数据表" class="headerlink" title="3.4、操作数据表"></a>3.4、操作数据表</h2><p>可以execute()方法添加一条记录，也可以使用executemany()方法进行批量添加记录<br>语法格式</p>
<pre><code>executemany(operation,seg_of_params)
</code></pre><p>说明：<br>operation:执行的sql语句<br>seg_of_params：参数序列</p>
<p>例子</p>
<pre><code>import pymysql

# 打开数据库连接，参数1：主机名或IP;参数2：用户名；参数3：密码；参数4；数据库名称
db = pymysql.connect(&quot;localhost&quot;, &quot;root&quot;, &quot;390800956&quot;, &quot;mydata&quot;, charset=&quot;utf8&quot;)
# 通过cursor()函数创建一个游标对象cursor
cursor = db.cursor()
# 数据列表
data = [(&quot;《见识》&quot;, &quot;literature&quot;, &quot;50.00&quot;),
        (&quot;《智能时代》&quot;, &quot;data&quot;, &quot;70.00&quot;),
        (&quot;《活着》&quot;, &quot;literature&quot;, &quot;23.00&quot;)]
try:
    # 执行SQL语句，插入多条数据
    cursor.executemany(&quot;insert into books (name, category, price) values (%s, %s, %s)&quot;, data)
    # 提交数据
    db.commit()
except:
    # 发送错误时回滚
    db.rollback()
# 关闭数据库连接、
db.close()
</code></pre><p><strong>在上面的代码中要注意</strong><br>1、在使用connect()方法时，设置charset=”utf8”,为得是识别中文<br>2、在使用insert语句插入数据时，使用%s作为占位符，防止SQL注入</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wrgiun.github.io/2019/09/12/python知识整合（文件及目录操作）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="giun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/12/python知识整合（文件及目录操作）/" class="post-title-link" itemprop="url">python知识整合（文件及目录操作）</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-12 20:47:00 / 修改时间：20:47:24" itemprop="dateCreated datePublished" datetime="2019-09-12T20:47:00+08:00">2019-09-12</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1、基本的文件操作"><a href="#1、基本的文件操作" class="headerlink" title="1、基本的文件操作"></a>1、基本的文件操作</h1><p>python中内置了文件(fFle)对象,使用文件对象的大概流程如下：<br>1、创建文件（通过内置open()函数）<br>2、通过该对象提供的方法进行一些基本的文件操作，如write()、close()等方法</p>
<h2 id="1-1、创建和打开文件"><a href="#1-1、创建和打开文件" class="headerlink" title="1.1、创建和打开文件"></a>1.1、创建和打开文件</h2><p>可以通过open()方法实现<br>语法格式：</p>
<pre><code>file = open(filename[,mode[,buffering]])
</code></pre><p>说明：<br>file:为被创建的文件对象<br>filename:要创建或者打开的文件名，可以使用绝对路径和相对路径<br>mode:可选参数，用于指定文件的打开模式，默认打开模式为只读（r）<br>buffering: 可选参数，用于指定读写文件的缓存模式，值为0表示不缓存，1表示缓存，大于1表示缓冲区的大小，默认为读写模式</p>
<h3 id="1-11、当打开不存在的文件，会抛出异常，解决办法有"><a href="#1-11、当打开不存在的文件，会抛出异常，解决办法有" class="headerlink" title="1.11、当打开不存在的文件，会抛出异常，解决办法有"></a>1.11、当打开不存在的文件，会抛出异常，解决办法有</h3><p>1、创建该文件<br>2、在调用open（）函数时，指定mode的参数值为w、w+、a、a+。这样的话，如果要打开的文件不存在就会自动创建新文件，归根到底还是和第一钟方法相联系</p>
<h3 id="1-12、以二进制的形式打开文件"><a href="#1-12、以二进制的形式打开文件" class="headerlink" title="1.12、以二进制的形式打开文件"></a>1.12、以二进制的形式打开文件</h3><p>open()函数不仅可以以文本形式打开文件，还可以以二进制形式打开文件，只要将mode参数设置为rb、 rb+、 wb、 wb+、 ab 、ab+，就可以</p>
<p>如</p>
<pre><code>file = open(&apos;1.jpg&apos;, &apos;rb&apos;)
print(file)
</code></pre><p>输出</p>
<pre><code>&lt;_io.BufferedReader name=&apos;1.jpg&apos;&gt;
</code></pre><p>可以看出创建的是一个BufferedReader（缓冲区读取）对象，该对象生成后我们可以使用第三方模块进行处理，如PIL的Image模块。</p>
<h3 id="1-13、-打开文件时指定编码方式"><a href="#1-13、-打开文件时指定编码方式" class="headerlink" title="1.13、 打开文件时指定编码方式"></a>1.13、 打开文件时指定编码方式</h3><p>open()方法打开文件时，默认为GBK编码，如果被打开的文件的编码不是GBK那么会抛出异常</p>
<p>解决方法<br>1、直接修改文件的编码<br>2、打开文件时，指定使用的编码方式（推荐）。在使用open函数打开文件时，使用encoding= ‘编码方式’，指定编码方式。</p>
<p>如，打开采用UTF - 8编码保存的文件1.txt</p>
<pre><code>file = open(&apos;1.txt1&apos;,&apos;r&apos;,encoding= &apos;utf -8&apos;)
</code></pre><h2 id="1-2、关闭文件"><a href="#1-2、关闭文件" class="headerlink" title="1.2、关闭文件"></a>1.2、关闭文件</h2><p>文件打开后，使用完要及时关闭文件。可以使用close()方法<br>语法格式</p>
<pre><code>file.close()
</code></pre><p>说明：close()方法会先刷新缓冲区中未写入的数据，然后再关闭文件。这样可以将未写入文件的数据写入文件。文件关闭后，不能再进行写操作</p>
<h2 id="1-3、打开文件时使用with语句"><a href="#1-3、打开文件时使用with语句" class="headerlink" title="1.3、打开文件时使用with语句"></a>1.3、打开文件时使用with语句</h2><p>如果在打开文件时如果抛出了异常，那么可能无法及时关闭文件。我们可以使用with语句避免这个问题<br>语法格式：</p>
<pre><code>with expression as target
    with_body
</code></pre><p>参数说明：<br>expression：用于指定一个表达式，这边可以是open()函数<br>target: 用于指定一个变量，并将expression的结果保存到该变量里<br>with-body:用于指定with语句体，其中可以是执行with语句后的相关一些操作语句，也可以是pass</p>
<p>如</p>
<pre><code>with open(&apos;1.jpg&apos;, &apos;rb&apos;) as file:
    pass
</code></pre><h2 id="1-4、写入文件内容"><a href="#1-4、写入文件内容" class="headerlink" title="1.4、写入文件内容"></a>1.4、写入文件内容</h2><p>使用write()函数<br>语法格式</p>
<pre><code>file.write(string)
</code></pre><p>部分参数说明：<br>string为要写入的字符串</p>
<p>使用write()方法的前提是，在打开文件时，指定的打开模式为w(可写)或者a（追加）等等</p>
<h2 id="1-5、读取文件"><a href="#1-5、读取文件" class="headerlink" title="1.5、读取文件"></a>1.5、读取文件</h2><p>读取文件主要分为以下3种情况。</p>
<h3 id="1-51、读取指定字符串"><a href="#1-51、读取指定字符串" class="headerlink" title="1.51、读取指定字符串"></a>1.51、读取指定字符串</h3><p><strong>1、从头开始读取文件内容</strong><br>使用read()方法，语法格式</p>
<pre><code>file.read([size])     #size用于指定要读取的字符个数，如果省略，则一次性读取全部
</code></pre><p>例子，注意打开模式只能为r或者r+</p>
<pre><code>with open(&apos;2.txt&apos;, &apos;r+&apos;) as file:
    print(file.read(2))
</code></pre><p><strong>2、读取部分内容</strong><br>使用seek()方法将指针移动到新的位置，再用read(size)方法读取。seek()基本语法</p>
<pre><code>file.seek(offset[,whence])
</code></pre><p>部分参数说明<br>offset:用于指定移动的字符个数，其具体位置与whence有关<br>whence：用于指定从什么位置开始算。0表示从文件头开始计算，1表示当前位置，2表示文件尾，默认为0。<br><strong>注意</strong><br>如果在打开文件时，没有使用b模式，那么只允许从文件头开始计算，从文件尾会报错。<br>使用seek()方法时，offset的值是一个汉字占2个字符，一个数字或者英文占一个字符，与read（）方法不同。</p>
<p>例子</p>
<pre><code>with open(&apos;2.txt&apos;, &apos;r&apos;) as file:
    file.seek(3)
    print(file.read(2))
</code></pre><h3 id="1-52、读取一行"><a href="#1-52、读取一行" class="headerlink" title="1.52、读取一行"></a>1.52、读取一行</h3><p>使用readline()方法，语法格式</p>
<pre><code>file.readline()
</code></pre><p>文件的打开模式要求与使用read（）方法一样<br>例子，一行一行输出2.txt里的内容</p>
<pre><code>with open(&apos;2.txt&apos;, &apos;r&apos;, encoding=&quot;utf-8&quot;) as file:
    number = 0  # 记录行号
    while True:
        number += 1
        line = file.readline()
        if line == &apos;&apos;:
            break
        print(number, line)  # 输出一行的内容
</code></pre><h3 id="1-53、读取全部行"><a href="#1-53、读取全部行" class="headerlink" title="1.53、读取全部行"></a>1.53、读取全部行</h3><p>使用readlines()方法，语法格式</p>
<pre><code>file.readlines()        # 返回类型为字符串列表
</code></pre><p>例子：<br>2.txt文件内容为<br>学无止境<br>python有趣<br>好好学习<br>天天向上</p>
<pre><code>with open(&apos;2.txt&apos;, &apos;r&apos;, encoding=&quot;utf-8&quot;) as file:
    print(file.readlines())
</code></pre><p>输出</p>
<pre><code>[&apos;学无止境\n&apos;, &apos;python有趣\n&apos;, &apos;好好学习\n&apos;, &apos;天天向上&apos;]
</code></pre><p>可以看出返回一个字符串列表，但是如果文件比较大，这种方法效率太低，这时可以将列表内容逐行输出，修改后的代码为</p>
<pre><code>with open(&apos;2.txt&apos;, &apos;r&apos;, encoding=&quot;utf-8&quot;) as file:
    a = file.readlines()
    for i in a:
        print(i)
</code></pre><h1 id="2、目录操作"><a href="#2、目录操作" class="headerlink" title="2、目录操作"></a>2、目录操作</h1><p>python中并没有直接提供操作目录的函数或者对象，而是通过内置的os和os.path模块实现。</p>
<p>其中os模块是python内置的与操作系统功能和文件系统相关的模块，该模块上执行结果通常与操作系统有关，在不同的操作系统上执行可能会有不同的效果<br>这边的操作系统为windows系统</p>
<h2 id="2-1、os和os-path模块"><a href="#2-1、os和os-path模块" class="headerlink" title="2.1、os和os.path模块"></a>2.1、os和os.path模块</h2><p>要使用os和os.path模块  ，首先要使用import语句导入，代码如下</p>
<pre><code>import os
</code></pre><p>导入os模块后，也可以使用其子模块os.path<br>os模块提供的常用的变量有以下几个<br><strong>1、name:用于获取操作系统类型</strong><br>如</p>
<pre><code>import os
print(os.name)
</code></pre><p>输出</p>
<pre><code>nt             # nt为windows系统，posix为Linux、UNIX或者Mac OS操作系统
</code></pre><p><strong>2、linesep:用于获取当前操作系统的换行符</strong></p>
<p><strong>3、sep:用于获取当前存在系统的路径分隔符</strong></p>
<p>os模块提供的与目录相关的函数<br>| getcwd()                         | 返回当前的工作目录                                           |<br>| ——————————– | ———————————————————— |<br>| listdir(path)                    | 返回指定路径下的文件和目录信息                               |<br>| mkdir(path [,mode])              | 创建目录                                                     |<br>| kakedirs(path1/path2/……..)   | 创建多级目录                                                 |<br>| rmdir(path)                      | 删除目录                                                     |<br>| removedirs(path1/path2/……..) | 删除多级目录                                                 |<br>| chdir(path)                      | 把path设置为当前工作目录                                     |<br>| walk(top [,topdown[,onerror]])   | 遍历目录树，该方法返回一个元组，包括所有路径名、所有目录列表和文件列表3个元素 |</p>
<p>os.path模块提供的与目录相关的函数<br>| 函数             | 说明                                               |<br>| —————- | ————————————————– |<br>| abspath(path)    | 用于获取文件或目录的绝对路径                       |<br>| exists（path）   | 用于判断路径是否存在，存在返回True,不存在返回False |<br>| join(path,name)  | 将目录与目录或者与文件名拼接起来                   |<br>| splitext()       | 分离文件名和扩展名                                 |<br>| basename（path） | 从一个目录中提取文件名                             |<br>| dirname（path）  | 从一个路径中提取文件路径，不包括文件名             |<br>| isdir(path)      | 用于判断是否为路径                                 |</p>
<h2 id="2-2、路径"><a href="#2-2、路径" class="headerlink" title="2.2、路径"></a>2.2、路径</h2><p>1、包括绝对路径和相对路径</p>
<p>2、可以使用os模块提供的getcwd()函数获取当前工作目录<br>代码如下</p>
<pre><code>import os
print(os.getcwd())   
</code></pre><p>在python中，指定文件路径时要对路径分隔符进行“\”转义,即将路径分隔符</p>
<p>“\”替换为”\“。也可以用“/”代替。</p>
<p>3、拼接目录<br>使用os.path.join()函数进行拼接，<br>语法格式为</p>
<pre><code>os.path.join(path1 [,path2[,.......]])
</code></pre><p>（1）、path1、path2为要拼接的路径，如果要拼接的路径中没有一个是绝对路径那么拼接出来的路径就是相对路径。<br>（2）、使用 os.path.join()拼接路径时，并不会检测该路径是否真实存在<br>如</p>
<pre><code>import os
print(os.path.join(&quot;E：\\Pyth&quot;, &quot;web\\ 1.txt&quot;))
</code></pre><p>输出</p>
<pre><code>E：\Pyth\web\ 1.txt
</code></pre><p>在使用os.path.join()函数时，如果要拼接的路径中有多个绝对路径，那么以从左到右最后一次出现的为准，之前的参数会被忽略，如<br>import os</p>
<pre><code>print(os.path.join(&quot;E:\\Pyth&quot;, &quot;D:\\txt&quot; , &quot;demo&quot;))
</code></pre><p>输出</p>
<pre><code>D:\txt\demo
</code></pre><p>注意：2个路径要拼接在一起时，不要直接使用字符串拼接，而是使用os.path.join()函数，这样可以处理不同操作系统的分隔符。</p>
<h2 id="2-3、判断目录是否存在"><a href="#2-3、判断目录是否存在" class="headerlink" title="2.3、判断目录是否存在"></a>2.3、判断目录是否存在</h2><p>使用os.path.exists()函数，语法格式如下</p>
<pre><code>os.path.exists(path)
</code></pre><p>路径存在返回True,不存在返回False,path可以为绝对路径或者相对路径，该函数还可以判读文件算法存在</p>
<h2 id="2-4、创建目录"><a href="#2-4、创建目录" class="headerlink" title="2.4、创建目录"></a>2.4、创建目录</h2><h3 id="2-41、创建一级目录"><a href="#2-41、创建一级目录" class="headerlink" title="2.41、创建一级目录"></a>2.41、创建一级目录</h3><p>使用os.mkdir(）函数创建目录，该函数只能创建一级目录，也就是知道路径的最后一级目录，如果该目录的上一级目录不存在，则会抛出异常，如果要创建的路径已经存在也会抛出异常<br>语法格式</p>
<pre><code>os.mkdir(path,mode= 0o777)
</code></pre><p>mode用于指定数值的模式，默认值为0777，该参数在非UNIX系统时无效或者被忽略<br>如，创建一个C:\demo目录（windows系统）</p>
<pre><code>import os
os.mkdir(&quot;C:\\demo&quot;)
</code></pre><p>那如何避免上面所说的创建的路径已经存的问题呢。可以使用以下代码，先判断，再创建</p>
<pre><code>import os
path = &quot;C:\\demo&quot;
if not os.path.exists(path):       # 判断目录是否存在
    os.mkdir(path)
    print(&quot;创建目录成功&quot;)
else:
    print(&quot;目录已经存在&quot;)
</code></pre><h3 id="2-42、创建多级目录"><a href="#2-42、创建多级目录" class="headerlink" title="2.42、创建多级目录"></a>2.42、创建多级目录</h3><p>使用os.makedirs()函数，语法格式</p>
<pre><code>os.makedirs(name, mode = 0o777)
</code></pre><p>name:用于指定要创建目录<br>例子<br>在windows系统上创建一个多级目录</p>
<pre><code>import os
path = &quot;C:\\demo\\web\\mr&quot;
os.makedirs(path)
</code></pre><h2 id="2-5、删除目录"><a href="#2-5、删除目录" class="headerlink" title="2.5、删除目录"></a>2.5、删除目录</h2><pre><code>通过os.rmdir（）函数可以删除目录，且要删除的目录为空时才有效，语法格式


os.rmdir(path)
</code></pre><p>如</p>
<pre><code>import os
path = &quot;C:\\Desktop\\web&quot;
os.rmdir(path)
</code></pre><p>删除后的目录</p>
<pre><code>C:\Desktop\web
</code></pre><p>如果目录不存在会抛出异常，将代码进行改进</p>
<pre><code>import os
path = &quot;C:\\Desktop\\web&quot;
if os.path.exists(path):
    os.rmdir(path)
    print(&quot;目录成功删除&quot;)
else:
    print(&quot;该目录不存在&quot;)
</code></pre><p>注意：<br>os.rmdir()函数只能删除空目录，如果要删除非空目录，可以使用python中内置模块shutil的rmtree()函数实现。<br>如，删除不为空的目录C:\Desktop\web</p>
<pre><code>import shutil
shutil.rmtree(&quot;C:\\Desktop\\web&quot;)
</code></pre><h2 id="2-6、遍历目录"><a href="#2-6、遍历目录" class="headerlink" title="2.6、遍历目录"></a>2.6、遍历目录</h2><p>使用os.walk()函数，语法如下</p>
<pre><code>os.walk(top [, topdown] [,onerror] [,follwlinks])
</code></pre><p>参数说明<br>top：用于指定要遍历的内容的根目录</p>
<p>topdown:可选参数用于指定遍历的顺序，值为True就是自上而下的遍历（从根目录开始），如果值为False就是自下而上的遍历。默认为True</p>
<p>onerror: 可选参数，用于指定错误处理方式，默认忽略，也可以指定一个错误处理函数，一般采用默认</p>
<p>followlinks: 可选参数，在默认情况下，walk（）函数不会向下转换成解析到目录的符号链接。将该参数值设置为True,表示用于在支持的系统上访问由符号链接指向的目录</p>
<p>返回值： 返回3个元素（dirpath、dirnames、filenames）的元组生成器对象。dirpath表示当前遍历的路径，是一个字符串；dirnames表示当前路径下包含的子目录，是一个列表，filenames表示当前路径下包含的文件，是一个列表</p>
<p>如,遍历D:\Python\web目录</p>
<pre><code>import os
# 遍历D:\Python\web目录
tuples = os.walk(&quot;D:\\Python\\web&quot;)
for tuplel in tuples:    # 通过for循环输出遍历结果
    print(tuplel, &apos;\n&apos;)
</code></pre><p>注意：walk()函数只在windows系统和UNIX系统中有效。</p>
<h1 id="3、文件的高级操作"><a href="#3、文件的高级操作" class="headerlink" title="3、文件的高级操作"></a>3、文件的高级操作</h1><p>os模块中与文件相关的函数<br>| 函数                         | 说明                                                         |<br>| —————————- | ———————————————————— |<br>| access(path,accessmode)      | 获取对文件是否有指定的访问权限（读取，写入，执行权限）。accessmod的值是R_OK(读取)、W_OK(写人)、X_OK(执行)或F_OK(存在)。如果有指定的权限，则返回1，否则返回0 |<br>| chmod(path,mode)             | 修改path指定文件的访问权限                                   |<br>| remove(path)                 | 删除path指定的文件路径                                       |<br>| rename(src,dst)              | 将文件或目录src重命名为dst                                   |<br>| stat(path)                   | 返回path指定文件的信息                                       |<br>| startfile(path [,operation]) | 使用关联的应用程序打开path指定的路径                         |</p>
<h2 id="3-1、删除文件"><a href="#3-1、删除文件" class="headerlink" title="3.1、删除文件"></a>3.1、删除文件</h2><p>使用os.remove（)函数，语法格式</p>
<pre><code>os.remove(path)
</code></pre><p>如，删除当前目录下的2.txt文件，代码如下</p>
<pre><code>import os
path = &quot;2.txt&quot;               # 使用相对路径（绝对路径也可以），要删除的文件
if os.path.exists(path):     # 判断文件是否存,防止文件不存在时抛出异常
    os.remove(path)
    print(&quot;文件删除成功&quot;)
else:
    print(&quot;该文件不存在&quot;)
</code></pre><h2 id="3-2、重命名文件和目录"><a href="#3-2、重命名文件和目录" class="headerlink" title="3.2、重命名文件和目录"></a>3.2、重命名文件和目录</h2><p>使用os.rename()函数，如果指定的路径是文件，则重命名文件，如果是目录，则重命名目录，语法格式</p>
<pre><code>os.rename(src,dst)
</code></pre><p>例子：将当前目录下的2.txt重命名为1.txt</p>
<pre><code>import os
src = &quot;D:\\Python\\web\\2.txt&quot;
dst = &quot;D:\\Python\\web\\1.txt&quot; # 使用绝对路径（相对路径也可以），要删除的文件
if os.path.exists(src):     # 判断文件是否存
    os.rename(src, dst)
    print(&quot;文件重命名成功&quot;)
else:
    print(&quot;该文件不存在&quot;)
</code></pre><p>值得注意的是使用rename()函数重命名目录时操作与重命名文件一样，但是只能修改最后一级的目录名称，否则会抛出异常。</p>
<h2 id="3-3、获取文件的基本信息"><a href="#3-3、获取文件的基本信息" class="headerlink" title="3.3、获取文件的基本信息"></a>3.3、获取文件的基本信息</h2><p>通过os.stat()函数可以获取文件的基本信息，语法格式如下</p>
<pre><code>os.stat(path)
</code></pre><p>start()函数返回式的对象的常用属性<br>| 属性     | 说明                     | 属性     | 说明                                                         |<br>| ——– | ———————— | ——– | ———————————————————— |<br>| st_mode  | 保护模式                 | st_dev   | 设备名                                                       |<br>| st_ino   | 索引号                   | st_uid   | 用户ID                                                       |<br>| st_nlink | 硬连接号（被连接的数目） | st_gid   | 组ID                                                         |<br>| st_size  | 文件大小，单位为字节     | st_atime | 最后一次询问时间                                             |<br>| st_mtime | 最后一次修改时间         | st_ctime | 最后一次状态变化的时间（不同系统不一样，如windows系统返回的是问卷创建的时间） |</p>
<h1 id="4、牛刀小试"><a href="#4、牛刀小试" class="headerlink" title="4、牛刀小试"></a>4、牛刀小试</h1><h2 id="1、查找特定目录D-Python-web下以m开头的文件"><a href="#1、查找特定目录D-Python-web下以m开头的文件" class="headerlink" title="1、查找特定目录D:\Python\web下以m开头的文件"></a>1、查找特定目录D:\Python\web下以m开头的文件</h2><pre><code>import os, re
input_dir = os.walk(&quot;D:\\Python\\web&quot;)
for dirPath, dirNames, fileNames in input_dir:     # 根据os.walk输出目录信息
        for fileName in fileNames:                # 对文件列表进行遍历
            pattern = r&apos;^m+&apos;                      # 模式字符串
            match = re.match(pattern, fileName)    # 查找匹配条件的文件名
            if match:              # 判断是否匹配成功
                print(os.path.join(dirPath, fileName))    # 拼接目录和文件名，并输出
</code></pre><p>或者</p>
<pre><code>import os, re
input_dir = input(&quot;please input the search dir:&quot;)
for dirPath, dirNames, fileNames in os.walk(input_dir):     # 根据os.walk输出目录信息
        for fileName in fileNames:                # 对文件列表进行遍历
            pattern = r&apos;^m+&apos;                      # 模式字符串
            match = re.match(pattern, fileName)    # 查找匹配条件的文件名
            if match:              # 判断是否匹配成功
                print(fileName)
                print(os.path.join(dirPath, fileName))    # 拼接目录和文件名，并输出
</code></pre><h2 id="2、复制C盘下的1-log文件到你的程序目录，然后修改日志中的所有的Aug为wr，并把修改后的文件保存到wr-txt"><a href="#2、复制C盘下的1-log文件到你的程序目录，然后修改日志中的所有的Aug为wr，并把修改后的文件保存到wr-txt" class="headerlink" title="2、复制C盘下的1.log文件到你的程序目录，然后修改日志中的所有的Aug为wr，并把修改后的文件保存到wr.txt"></a>2、复制C盘下的1.log文件到你的程序目录，然后修改日志中的所有的Aug为wr，并把修改后的文件保存到wr.txt</h2><pre><code>import shutil
shutil.copyfile(&apos;C:\\1.log&apos;, &apos;D:\\Python\\web\\1.txt&apos;)          # 复制文件到程序目录下
file = open(&apos;1.txt&apos;, &apos;r&apos;)
file_new = open(&apos;wr.txt&apos;, &apos;w&apos;)
for line in file:                                               # 按行读取文件内容
    if &quot;Aug&quot; in line:                                           # 查找我们所需要修改的内容
        line = line.replace(&quot;Aug&quot;, &quot;wr&quot;)                        #替换Aug为wr
    file_new.write(line)                                        #修改后的内容写入新文件里
file.close()
file_new.close()
</code></pre><p>或者</p>
<pre><code>import shutil
shutil.copyfile(&apos;C:\\1.log&apos;, &apos;D:\\Python\\web\\1.txt&apos;)
with open(&apos;1.txt&apos;, &apos;r&apos;) as file:
    with open(&apos;wr.txt&apos;, &apos;w&apos;) as new_file:
        for line in file:
            if &quot;Aug&quot; in line:
                line = line.replace(&quot;Aug&quot;, &quot;wr&quot;)
                new_file.write(line)
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wrgiun.github.io/2019/09/12/python知识整合（模块）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="giun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/12/python知识整合（模块）/" class="post-title-link" itemprop="url">python知识整合（模块）</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-12 20:45:30 / 修改时间：20:46:42" itemprop="dateCreated datePublished" datetime="2019-09-12T20:45:30+08:00">2019-09-12</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1、自定义模块"><a href="#1、自定义模块" class="headerlink" title="1、自定义模块"></a>1、自定义模块</h1><p>在Python中一个.py文件就是一个模块。</p>
<p>在python中自定义模块有2个作用。一个是规范代码，让代码更易于阅读。另一个是方便其他程序使用已经编写好的代码，提高开发效率、</p>
<p>要实现自定义模块主要分为创建模块和导入模块2部分。</p>
<h2 id="1-1、创建模块"><a href="#1-1、创建模块" class="headerlink" title="1.1、创建模块"></a>1.1、创建模块</h2><p>就是将模块中的相关代码编写在单独的文件中，文件名为模块名.py<br>要注意的是设置的模块名不能与python自带的标准库名称一样。如果一样的话。先导入了我们自定义的模块后，就不能再导入python自带的标准库</p>
<h2 id="1-2、使用import语句导入模块"><a href="#1-2、使用import语句导入模块" class="headerlink" title="1.2、使用import语句导入模块"></a>1.2、使用import语句导入模块</h2><p>使用import导入<br>语法格式</p>
<pre><code>import modulename [as alias]
</code></pre><p>部分参数说明：<br> [as alias] 给模块起的别名，可以通过该别名使用模块</p>
<p>在调用模块中的变量、函数或者类等时，需要在变量、函数或者类名前面添加“模块名.”</p>
<p>使用import语句也可以一次导入多个模块<br>如</p>
<pre><code>import re,requests,os
</code></pre><p>1.3、使用from…import语句导入模块<br>在使用import语句导入模块时，每执行一条import语句就会创建一个新的命名空间，且在调用模块中的变量、函数或者类时，需要在变量、函数或者类名前面添加“模块名.”。</p>
<p>使用from…import语句导入模块是把具体的定义导入到当前的命名空间，不需要添加前缀，直接通过具体的变量、函数或者类等访问即可。</p>
<p>语法格式:</p>
<pre><code>from modelname import member
</code></pre><p>参数说明：<br>modelname：模块名区分大小写<br>member：用于指定要导入的变量、函数或者类等，可以同时导入多个定义，如果要想导入全部定义使用“*”代替。</p>
<p>注意：在导入模块时，如果使用了通配符*导入全部定义之后，可以使用dir()来查看具体导入了哪些定义。</p>
<h2 id="1-3、模块搜索的目录"><a href="#1-3、模块搜索的目录" class="headerlink" title="1.3、模块搜索的目录"></a>1.3、模块搜索的目录</h2><p>当使用import语句导入模块时，在默认的情况下，按一下顺序进行查找<br>1、在当前目录进行查找<br>2、在python环境变量下的每个目录查找<br>3、到python的默认安装目录下查找</p>
<p>说明的各个目录的具体位置都是保存在标准模块sys的sys.path变量中。可以通过一下代码输出具体的目录</p>
<pre><code>import sys
print(sys.path)
</code></pre><p>如果要导入的模块不在标准模块sys的sys.path变量中，会报错。（注意模块名区分大小写）</p>
<p>这时有3种方式可以将指定的目录添加到sys.path中</p>
<p><strong>1、临时添加</strong><br>通过该方法添加的目录只在执行当前文件的窗口有效，窗口关闭后就失效。<br>语法格式</p>
<pre><code>import sys
sys.path.append(&quot;要添加的指定目录&quot;)
</code></pre><p><strong>2、增加.pth文件（推荐）</strong></p>
<p>在python安装目录的子目录Lib\site-packages子目录中，创建一个扩展名为.pth的文件，文件名任意，在该文件中添加要导入模块所在的目录。然后重新打开要执行导入模块的python文件，使得新添加的目录生效。</p>
<p>通过该方法添加的目录只在当前版本的python中有效</p>
<p><strong>3、在PYTHONPATH环境变量中添加</strong><br>在系统的环境变量对话框中，查找在PYTHONPATH环境变量，如果没有就创一个，然后添加所要导入的模块的目录。然后重新打开要执行导入模块的python文件，使得新添加的目录生效。</p>
<p>通过该方法添加的目录在不同版本的python中都有效</p>
<h1 id="2、以主程序的形式执行"><a href="#2、以主程序的形式执行" class="headerlink" title="2、以主程序的形式执行"></a>2、以主程序的形式执行</h1><p>创建一个aaa模块</p>
<pre><code>p = &quot;苹果&quot;
def fun_c():
    p = &quot;一个烂苹果&quot;
    print(p)
if __name__==&quot;__main__&quot;:
    print(&quot;哈哈哈哈&quot;)
</code></pre><p>在text中导入该模块</p>
<pre><code>import aaa
print(aaa.p)
</code></pre><p>输出</p>
<pre><code>苹果
</code></pre><p>说明：如果在aaa模块中没有if语句的话，会把下面的测试语句（    print(“哈哈哈哈”)）也一块执行。但是我们只想要输出变量p。故将测试语句放入if语句。</p>
<h1 id="3、python中的包"><a href="#3、python中的包" class="headerlink" title="3、python中的包"></a>3、python中的包</h1><p>python中的包是一个分层的目录结构，它将一组功能相近的模块组织在一个目录下，这样就可以起到代码规范的作用，又可以避免模块重名引起的冲突</p>
<p>简单来说python的包就是一个含义<strong>init</strong>.py的文件的文件夹</p>
<h2 id="3-1、创建"><a href="#3-1、创建" class="headerlink" title="3.1、创建"></a>3.1、创建</h2><p>1、创建包就是创建一个文件夹，并在文件里创建一个名称为<strong>init</strong>.py的文件。在<strong>init</strong>.py文件里可以不编写代码，也可以编写代码，在导入包时会自动执行。</p>
<p>注意：<strong>init</strong>.py文件是一个模块文件，模块名为包名。在a包中创建的<strong>init</strong>.py文件，对应的模块名为a</p>
<h2 id="3-2、使用包"><a href="#3-2、使用包" class="headerlink" title="3.2、使用包"></a>3.2、使用包</h2><p>创建包，然后在包中创建相应的模块，然后再使用import语句从包中加载模块。<br>从包中加载模块有以下3种方式。</p>
<p><strong>1、通过”import+完整包名+模块名”的方式加载指定模块</strong><br>语法格式</p>
<pre><code>import 完整包名.模块名
</code></pre><p>通过该方式，访问模块中的变量时，语法格式如下</p>
<pre><code>完整包名.模块名.变量名
</code></pre><p><strong>2、通过”from+完整包名+import+模块名”的方式加载指定模块</strong><br>语法格式：</p>
<pre><code>from 完整包名 import 模块名
</code></pre><p>通过该方式，访问模块中的变量时，语法格式如下</p>
<pre><code>模块名.变量名
</code></pre><p><strong>3、通过通过”from+完整包名+import+模块名+定义名”的方式加载指定模块</strong><br>语法格式</p>
<pre><code>from 完整包名.模块名  import 定义名1，定义名2，....
</code></pre><p>定义名可以是函数、类、变量名等</p>
<p>通过该方式，访问模块中的函数、类、变量等，语法格式如下</p>
<pre><code>定义名
</code></pre><p>如果使用*号则表示加载该模块下的所有定义</p>
<h1 id="4、引用其他模块"><a href="#4、引用其他模块" class="headerlink" title="4、引用其他模块"></a>4、引用其他模块</h1><p>在python中除了自定义模块，还有其他模块，主要包括标准模块和第三方模块。</p>
<p>下表为python中常用的内置的标准模块<br>| 模块名   | 概述                                                         |<br>| ——– | ———————————————————— |<br>| sys      | 与python解释器及其环境操作相关的标准库                       |<br>| time     | 提供与时间相关的各种函数的标准库                             |<br>| os       | 提供了访问操作系统服务功能的标准库                           |<br>| calendar | 提供了与日期相关的各种函数的标准库                           |<br>| urllib   | 用于读取来自网上（服务器上）的数据的标准库                   |<br>| json     | 用于使用JSON序列化和反序列化                                 |<br>| re       | 用于在字符串中执行正则表达式匹配和替换                       |<br>| math     | 提供标准算术运算函数的标准库                                 |<br>| decimal  | 用于进行精确控制运算精度、有效位数和四舍五入操作的十进制运算 |<br>| shutil   | 用于进行高级文件操作，如复制等                               |<br>| logging  | 提高了灵活的记录事件、错误、警告和调试信息等日志信息的功能   |<br>| thinker  | 使用python进行GUI编程的标准库                                |<br>当然python有许多标准库,可以在python的安装目录下，的DOC目录下的扩展名为.chm文件（就是python的帮助文档）打开文件，文件里的The Python Standard Library下面的Python Runtime Services里进行查看，当然也可以上网查找。</p>
<h1 id="5、牛刀小试"><a href="#5、牛刀小试" class="headerlink" title="5、牛刀小试"></a>5、牛刀小试</h1><h2 id="5-1、输出6位数的验证码"><a href="#5-1、输出6位数的验证码" class="headerlink" title="5.1、输出6位数的验证码"></a>5.1、输出6位数的验证码</h2><p>要求确保6位数中有一位大写字母，一位小写字母，一位数字</p>
<pre><code>import random, string
code_li = []
&quot;&quot;&quot;确保6位数中有一位大写字母，一位小写字母，一位数字&quot;&quot;&quot;
code_li.append(random.choice(string.ascii_lowercase))    # 随机添加小写字母
code_li.append(random.choice(string.digits))             # 随机添加
code_li.append(random.choice(string.ascii_uppercase))    # 随机添加大写字母
while len(code_li)&lt;6:
    code_li.append(random.choice(string.ascii_lowercase+string.digits+string.ascii_uppercase))
    print(code_li)
q_code = &quot;&quot;.join(code_li)
&quot;&quot;&quot;
join()函数
语法：  &apos;sep&apos;.join(seq)
参数说明
sep：分隔符。可以为空
seq：要连接的元素序列、字符串、元组、字典
上面的语法即：以sep作为分隔符，将seq所有的元素合并成一个新的字符串
返回值：返回一个以分隔符sep连接各个元素后生成的字符串
&quot;&quot;&quot;
print(q_code)
</code></pre><h2 id="5-2、转化为时间戳"><a href="#5-2、转化为时间戳" class="headerlink" title="5.2、转化为时间戳"></a>5.2、转化为时间戳</h2><p>把2019-01-02 20:12:54转化为时间戳</p>
<pre><code>import time
dt = &quot;2019-01-02 20:12:54&quot;
timeArray = time.strptime(dt,&quot;%Y-%m-%d %H:%M:%S&quot;)  # 根据指定的格式把一个时间字符串解析为时间元组。(转化为时间戳)
# timestamp = time.mktime(timeArray)   # 返回用秒数来表示时间的浮点数
# print(timestamp)
print(timeArray)
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wrgiun.github.io/2019/09/12/python知识整合（面向对象程序设计）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="giun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/12/python知识整合（面向对象程序设计）/" class="post-title-link" itemprop="url">python知识整合（面向对象程序设计）</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-12 20:44:30 / 修改时间：20:45:50" itemprop="dateCreated datePublished" datetime="2019-09-12T20:44:30+08:00">2019-09-12</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1、面向对象概述"><a href="#1、面向对象概述" class="headerlink" title="1、面向对象概述"></a>1、面向对象概述</h1><h2 id="1-1、对象（object）"><a href="#1-1、对象（object）" class="headerlink" title="1.1、对象（object）"></a>1.1、对象（object）</h2><p>对象是一个抽象的概念，表示任意存在的事物</p>
<p>对象可以分为2部分，就是静态部分和动态部分。静态部分被称为“属性”，如人的性别；动态部分指的是对象的行为（对象执行的动作），如人可以走路</p>
<p>在python中，一切都是对象，即不仅把具体事物称为对象，字符串、函数等也是对象。（pyhton天生就是面向对象的）</p>
<h2 id="1-2、类"><a href="#1-2、类" class="headerlink" title="1.2、类"></a>1.2、类</h2><p>类是封装对象的属性和行为的载体，反过来说具有相同属性和行为的一类实体被称为类。<br>如定义一个鸟类，在该类中可以定义每个对象共有的属性和方法。而每一只鸟就是一个对象。<br>对象是类的实例</p>
<h2 id="1-3、面向对象程序设计特点"><a href="#1-3、面向对象程序设计特点" class="headerlink" title="1.3、面向对象程序设计特点"></a>1.3、面向对象程序设计特点</h2><p>面向对象程序设计具有3大基本特征：封装，继承，多态。</p>
<p><strong>1、封装</strong></p>
<p>封装是面向对象编程的核心思想，将对象的属性和行为封装起来，载体是类。类通常会对客户隐藏其实现细节。如我们看一本书，只需要看书的内容就可以，而不需要知道书是这么制作的。</p>
<p>封装思想保证了类内部数据结构的完整性，提高了程序的可维护性。</p>
<p><strong>2、继承</strong><br>矩形是四边形的一种，矩形拥有四边形的全部特点，反之不然。<br>矩形类可以看为继承四边形类后产生的类，称为子类。而四边形类称为父类或者超类。<br>在python中子类的实例都是父类的实例，但是不能说父类的实例都是子类的实例。<br>继承是重复利用的重要手段，子类可以继承父类的属性的同时，又增加了子类特有的属性和行为。</p>
<p><strong>3、多态</strong><br>将父类对象应用于子类的特征就是多态。<br>就是子类继承父类特征的同时，也具备了自己的特征，并且能够实现不同的效果，这就是多态化结构。</p>
<h1 id="2、类的定义和使用"><a href="#2、类的定义和使用" class="headerlink" title="2、类的定义和使用"></a>2、类的定义和使用</h1><h2 id="2-1、定义类"><a href="#2-1、定义类" class="headerlink" title="2.1、定义类"></a>2.1、定义类</h2><p>使用class关键字来定义类<br>语法格式</p>
<pre><code>class ClassName:
    &apos;&apos;&apos;类的帮助信息&apos;&apos;&apos;        # 类文档字符串
    statement               # 类体 ,如果没有想好类的功能，可以使用pass代替
</code></pre><h2 id="2-2、创建类的实例对象"><a href="#2-2、创建类的实例对象" class="headerlink" title="2.2、创建类的实例对象"></a>2.2、创建类的实例对象</h2><p>创建类的实例的语法：</p>
<pre><code>ClassName(parameterlist)
</code></pre><p>注意在python中创建实例不使用new关键字，这是它与其他面向对象语言的区别。</p>
<h2 id="2-3、创建-int-方法"><a href="#2-3、创建-int-方法" class="headerlink" title="2.3、创建 int ()方法"></a>2.3、创建 <strong>int </strong>()方法</h2><p> <strong>int </strong>()方法是一个特殊的方法，每当创建一个类的新实例时，Python会自动执行它。</p>
<p> <strong>int </strong>()方法必须包含一个self参数,且必须是第一个参数。self参数是一个指向实例本身的引用，用于访问类中的属性和方法。在方法调用时会自动传递实际参数self</p>
<p>如</p>
<pre><code>class Apple:
    &quot;&quot;&quot;苹果类&quot;&quot;&quot;
    def __init__(self):
        print(&quot;这是苹果类&quot;)
</code></pre><p>​<br>    wildApple = Apple()</p>
<p>可以看出，在创建苹果类的实例时，虽然没有为 <strong>int </strong>()方法指定参数，但是该方法会自动执行</p>
<p>当然 <strong>int </strong>()方法出了self参数外，还可以自定义一些参数。<br>例子</p>
<pre><code>class Apple:
    &quot;&quot;&quot;苹果类&quot;&quot;&quot;
    def __init__(self, size, color):      # 构造方法
        print(&quot;这是苹果&quot;)
        print(size)
        print(color)
</code></pre><p>​<br>    size_1 = “个大”<br>    color_1 = “又红”<br>    wildApple = Apple(size_1, color_1)    # 创建苹果类的实例</p>
<h2 id="2-4、创建类的成员并访问"><a href="#2-4、创建类的成员并访问" class="headerlink" title="2.4、创建类的成员并访问"></a>2.4、创建类的成员并访问</h2><p>类的成员主要由实例的方法和数据成员组成。创建了类的成员后，可以通过类的实例进行访问</p>
<p><strong>1、创建实例方法并访问</strong></p>
<p>实例方法其实就是在类中定义函数</p>
<p>与<strong>int</strong>()方法类似<br>语法格式如下</p>
<pre><code>def  functionName(self,parameterlist):
    block
</code></pre><p>参数说明：<br>functionName：用于指定方法名，一般小写字母开头</p>
<p>self : 必要参数，其名称要是self以外的单词，用self只是个习惯</p>
<p>parameterlist: 用于指定除self以外的参数</p>
<p>block: 方法体，实现具体功能</p>
<p>实例方法创建完成之后，可以通过类的实例名称名称和“.”来访问。<br>语法格式</p>
<pre><code>instanceName.functionName(parametervalue)
</code></pre><p><strong>2、创建数据成员并访问</strong><br>数据成员是指类中定义的变量（属性），根据定义的位置可以分为类属性和实例属性。</p>
<p>类属性：定义在类中且在函数体外的属性。可以在使用实例化的对象中公用。</p>
<p>实例属性定义在类的方法（实例方法）中的属性，只作用于当前的实例。<br>如</p>
<pre><code>class Apple:
    &quot;&quot;&quot;苹果类&quot;&quot;&quot;
    size = &quot;个大&quot;             # 定义类属性
    color = &quot;又红&quot;            # 定义类属性

    def __init__(self):       # 构造方法
        self.weight = &quot;又重&quot;
        print(&quot;这是苹果&quot;)
        print(Apple.size)
        print(Apple.color)
        print(self.weight)     # 定义实例属性
</code></pre><p>​<br>    apple = Apple()    # 创建苹果类的实例</p>
<p>注意实例属性只能通过实例名访问。当然实例属性也可以通过实例名称修改，修改后不影响该类的其他的实例中相应的实例属性的值<br>如</p>
<pre><code>class Apple:
    &quot;&quot;&quot;苹果类&quot;&quot;&quot;

    def __init__(self):       # 构造方法
        self.weight = &quot;又重&quot;
        print(self.weight)     # 定义实例属性
</code></pre><p>​<br>    apple1 = Apple()<br>    apple2 = Apple()<br>    apple1.weight = “太轻了”<br>    print(apple1.weight)<br>    print(apple2.weight)</p>
<h2 id="2-5、访问限制"><a href="#2-5、访问限制" class="headerlink" title="2.5、访问限制"></a>2.5、访问限制</h2><p>访问限制有3种方式。可以在属性或者方法前加个单下划线，双下划线，或者首尾加双下划线</p>
<p>1、首尾加双下划线：表示定义的特殊方法，一般是系统定义的名字如<strong>int</strong>()</p>
<p>2、单下划线：表示保护（protected）类型的成员，只允许类本身或者子类访问，但不可以使用“from module import*”语句导入</p>
<p>如：</p>
<pre><code>class Apple:
    &quot;&quot;&quot;苹果类&quot;&quot;&quot;
    _weight_apple = &quot;又重&quot;   # 定义保护属性

    def __init__(self):       # 实例方法
        print(Apple._weight_apple)     # 在实例方法中访问保护属性
</code></pre><p>​<br>    apple1 = Apple()<br>    print(apple1._weight_apple)</p>
<p>保护属性可以通过实例名进行访问</p>
<p>3、双下划线：表示私有（private）类型成员，只允许定义该方法的类的本身进行访问，而且不能通过类的实例进行访问。但是可以通过”类的实例名._类名__xxx”进行访问</p>
<p>如</p>
<pre><code>class Apple:
    &quot;&quot;&quot;苹果类&quot;&quot;&quot;
    __weight_apple = &quot;又重&quot;   # 定义私有属性

    def __init__(self):       # 实例方法
        print(Apple.__weight_apple)     # 在实例方法中访问私有属性
</code></pre><p>​<br>    apple1 = Apple()<br>    print(apple1._Apple__weight_apple)</p>
<h1 id="3、属性（property）"><a href="#3、属性（property）" class="headerlink" title="3、属性（property）"></a>3、属性（property）</h1><h2 id="3-1、创建用于计算的属性"><a href="#3-1、创建用于计算的属性" class="headerlink" title="3.1、创建用于计算的属性"></a>3.1、创建用于计算的属性</h2><p>可以通过@property(装饰器)把一个方法转化为属性，从而实现用于计算的属性。可以直接通过方法名来访问。<br>语法格式</p>
<pre><code>@property
def methodname(self)
    block
</code></pre><p>如</p>
<pre><code>class Rect:
    def __init__(self, width, height):
        self.width = width           # 矩形的宽
        self.height = height         # 矩形的高

    @property                        # 将方法转化为属性
    def area(self):
        return self.width*self.height    # 返回矩形的面积
</code></pre><p>​<br>    rect = Rect(5, 4)       # 创建类的实例<br>    print(rect.area)        # 输出属性的值</p>
<h2 id="3-2、为属性添加安全的保护机制"><a href="#3-2、为属性添加安全的保护机制" class="headerlink" title="3.2、为属性添加安全的保护机制"></a>3.2、为属性添加安全的保护机制</h2><p>如果想要创建一个可读不能修改的属性，那么可以使用@property(装饰器)实现该效果</p>
<p>例子：</p>
<pre><code>class Rect:
    def __init__(self, width):
        self.width = width           # 矩形的宽

    @property                        # 将方法转化为属性
    def area(self):
        return self.width
</code></pre><p>​<br>    rect = Rect(5)       # 创建类的实例<br>    print(rect.area)        # 输出属性的值<br>    rect.area = 6     # 修改属性值<br>    print(rect.area)    # 获取属性值，会抛出AttributeError</p>
<h1 id="4、继承"><a href="#4、继承" class="headerlink" title="4、继承"></a>4、继承</h1><h2 id="4-1、继承的基本语法："><a href="#4-1、继承的基本语法：" class="headerlink" title="4.1、继承的基本语法："></a>4.1、继承的基本语法：</h2><p>语法格式：</p>
<pre><code>class ClassName(baseclasslist):
    &quot;&quot;&quot;类的帮助信息&quot;&quot;&quot;                   # 类文档字符串
    statement                          # 类体
</code></pre><p>部分参数说明：<br>baseclasslist:用于指定要继承的基类（父类），可以多个。类名之间用逗号隔开。如果不指定，将使用所以python对象的根类object.</p>
<h2 id="4-2、方法重写"><a href="#4-2、方法重写" class="headerlink" title="4.2、方法重写"></a>4.2、方法重写</h2><p>基类（父类）的成员都会被派生类（子类）继承，当基类中的某个方法不完全适用于派生类时，就需要在派生类中重写基类的这个方法。<br>例子：重写基类中的harvest方法</p>
<pre><code>class Fruit:
    def __init__(self, color = &quot;绿色&quot;):
        Fruit.color = color             # 定义类的属性

    def harvest(self):
        print(&quot;水果……&quot;)
</code></pre><p>​<br>    class Orange(Fruit):<br>        color = “橙色”</p>
<pre><code>def __init__(self):
    print(&quot;\n我是橘子&quot;)
    super().__init__()                   # 调用基类的__init__()方法

def harvest(self, color):
    print(&quot;橘子是：&quot; + color + &quot;的&quot;)      # 输出参数形式color
    print(&quot;橘子已经收获了&quot;)
    print(&quot;橘子原来是：&quot; + Fruit.color + &quot;的&quot;)   #输出类属性color
</code></pre><p>​<br>    orange = Orange()<br>    orange.harvest(“橙色”)</p>
<p>这边有一点要注意，在派生类中定义<strong>init</strong>()方法时，不会自动调用基类的<strong>init</strong>()方法。故需要对派生类的<strong>init</strong>()方法进行初始化，就是在派生类中只有super()函数进行调用基类的<strong>init</strong>()方法，如下代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">super().__init__()</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wrgiun.github.io/2019/09/12/python知识整合（函数）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="giun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/12/python知识整合（函数）/" class="post-title-link" itemprop="url">python知识整合（函数）</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-12 20:43:24 / 修改时间：20:44:03" itemprop="dateCreated datePublished" datetime="2019-09-12T20:43:24+08:00">2019-09-12</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1、函数的创建与调用"><a href="#1、函数的创建与调用" class="headerlink" title="1、函数的创建与调用"></a>1、函数的创建与调用</h1><p>函数出了python中的内置函数外，我们也也可以根据需求，自己创建函数<br><strong>创建函数语法格式</strong></p>
<pre><code>def functionname([parameterlist])
    [&apos;&apos;&apos;comments&apos;&apos;&apos;]
    [functionbody]
</code></pre><p> <strong>调用函数语法格式</strong></p>
<pre><code>functionname([parameterlist])
</code></pre><p>小技巧：<br>在调用函数时，如果指定了“comment(注释)”参数，那么在调用函数时，输入函数名及其左侧小括号时，就会显示该函数的帮助信息（注释的内容）</p>
<p>例子：</p>
<pre><code>def filterchar(string):
    &apos;&apos;&apos;
    功能：过滤危险字符，并将过滤后的结果输出
    about:要过滤的字符串
    没有返回值
    &apos;&apos;&apos;
    import re
    pattern = r&apos;(黑客)|(抓包)|(监听)|(trojan)&apos;
    sub = re.sub(pattern, &quot;@_@&quot;, string)
    print(sub)
filterchar(&quot;黑客&quot;)
</code></pre><h1 id="2、参数传递"><a href="#2、参数传递" class="headerlink" title="2、参数传递"></a>2、参数传递</h1><h2 id="2-1、形式参数与实际参数（形参与实参）"><a href="#2-1、形式参数与实际参数（形参与实参）" class="headerlink" title="2.1、形式参数与实际参数（形参与实参）"></a>2.1、形式参数与实际参数（形参与实参）</h2><p>形式参数（形参）：在定义函数时，函数名后括号内的参数为形参<br>实际参数（实参）：在调用一个函数时，函数名后括号内的参数为实参，也就是调用函数时，我们给函数传入的参数。</p>
<p>根据实践参数类型的不同，可以分为值传递和应用传递。当实际参数为不可变对象时，就是值传递：当实际参数为可变对象时就是引用传递。</p>
<p>例子：<br><strong>定义函数</strong><br>def demo(obj):<br>    print(“元值：”, obj)<br>    obj += obj<br><strong>调用函数</strong></p>
<pre><code>print(&quot;========值传递========&quot;)
mot = &quot;唯有在被追赶的时候，你才能真正的奔跑。&quot;
print(&quot;函数调用前：&quot;, mot)
demo(mot)   # 采用不可变量字符串
print(&quot;函数调用后：&quot;, mot)
print(&quot;========引用传递========&quot;)
list1 = [&apos;apple&apos;, &apos;banana&apos;, &apos;orange&apos;, &apos;pear&apos;]
print(&quot;函数调用前：&quot;, list1)
demo(list1)   # 采用可对象列表
print(&quot;函数调用后：&quot;, list1)
</code></pre><p>输出</p>
<pre><code>========值传递========
函数调用前： 唯有在被追赶的时候，你才能真正的奔跑。
元值： 唯有在被追赶的时候，你才能真正的奔跑。
函数调用后： 唯有在被追赶的时候，你才能真正的奔跑。
========引用传递========
函数调用前： [&apos;apple&apos;, &apos;banana&apos;, &apos;orange&apos;, &apos;pear&apos;]
元值： [&apos;apple&apos;, &apos;banana&apos;, &apos;orange&apos;, &apos;pear&apos;]
函数调用后： [&apos;apple&apos;, &apos;banana&apos;, &apos;orange&apos;, &apos;pear&apos;, &apos;apple&apos;, &apos;banana&apos;, &apos;orange&apos;, &apos;pear&apos;]
</code></pre><p>可以看出，值传递改变形参的值，但是不改变实参的值。<br>引用传递改变形参的值，同时也改变实参的值。</p>
<h2 id="2-2、位置参数"><a href="#2-2、位置参数" class="headerlink" title="2.2、位置参数"></a>2.2、位置参数</h2><p>位置参数也称必备参数，必须按照正确的顺序传入函数中</p>
<p><strong>1、数量必须与定义时的一样</strong></p>
<p>在调用函数时，指定的实际参数的数量必须与形式参数一样一样，否则会抛出TypeError异常，提示缺少的位置参数</p>
<p><strong>2、位置必须与定义时的一致</strong></p>
<p>不一致会产生下面2种异常<br>（1）、抛出TypeErro异常<br>该种异常主要是实参与形参类型不一致，且在函数中，2种类型无法转换<br>（2）、产生的结果与预期的不符<br>就是位置错了，但是他们的类型一致，比如身高和体重的参数位置反了。<br>这其实是一种bug</p>
<h2 id="2-3、关键字参数"><a href="#2-3、关键字参数" class="headerlink" title="2.3、关键字参数"></a>2.3、关键字参数</h2><p>关键字参数是指使用形参的名字来确定输入的参数值，使用该方法，实参的位置不需要一致。<br>如调用fun_bmi(persion,height,weight)函数，可以通过关键字参数</p>
<pre><code>fun_mbi(height = 1.58, persion = &apos;john&apos;, weight = &apos;50&apos;)
</code></pre><h2 id="2-4、为参数设置默认值"><a href="#2-4、为参数设置默认值" class="headerlink" title="2.4、为参数设置默认值"></a>2.4、为参数设置默认值</h2><p>语法格式：</p>
<pre><code>def functionname(…，[parameter1 = defaultvaluel]):
    [functionbody]
</code></pre><p>查看函数的默认值参数的语法</p>
<pre><code>函数名.__defaults__
</code></pre><p>使用可以变量作为参数的默认值时，多次调用，可能会产生意料之外的结果。<br>为了防止这种情况的产生，我们可以使用None作为可变对象的默认值，还要加上检验代码。</p>
<p>在定义函数时，为形式参数设置默认值时，默认参数必须指向不可变对象</p>
<h2 id="2-5、可变参数"><a href="#2-5、可变参数" class="headerlink" title="2.5、可变参数"></a>2.5、可变参数</h2><p>可变参数也称不定长参数。即传入函数的参数可以是0个，1个，2个等等。<br>主要有*parameter和**parameter 2种形式</p>
<p><strong>1</strong>、*parameter<br>这种形式表示接收任意多个实际参数并将其放入一个元组中。<br>如</p>
<pre><code>def printfruit(*fruitname):
    print(&apos;\n我喜欢的水果有：&apos;)
    for i in fruitname:
        print(i)   # 输出水果名称

printfruit(&apos;apple&apos;)
printfruit(&apos;apple&apos;, &apos;banana&apos;, &apos;pear&apos;)
</code></pre><p>输出</p>
<pre><code>我喜欢的水果有：
apple

我喜欢的水果有：
apple
banana
pear
</code></pre><p>如果想要用一个已经存在的列表作为函数的可变参数，可以在列表名称前加个’*‘。<br>如</p>
<pre><code>a = [&apos;apple&apos;, &apos;banana&apos;, &apos;pear&apos;]
printfruit(*a)
</code></pre><p><strong>2</strong>、**parameter<br>这种形式表示可以接收任意多个类似关键字一样的显示赋值的实际参数<br>如</p>
<pre><code>def printsign(**sign):
    print()
    for key, value in sign.items():    # 遍历字典
        print(key + &quot;的星座是：&quot; + value)
printsign(a=&apos;水瓶&apos;)
printsign(a=&apos;水瓶&apos;, b=&apos;狮子&apos;)
</code></pre><p>输出</p>
<pre><code>a的星座是：水瓶

a的星座是：水瓶
b的星座是：狮子
</code></pre><p>如果想要用一个已经存在的字典作为函数的可变参数，可以在字典名称前加个’**‘。</p>
<h1 id="3、返回值"><a href="#3、返回值" class="headerlink" title="3、返回值"></a>3、返回值</h1><p>在python中无论return语句在什么位置，只有得到执行，就会直接结束函数的执行<br>语法格式：</p>
<pre><code>result =return [value]
</code></pre><p>说明<br>value为一个可选参数，用于指定要返回的值（可以是一个值，也可以是多个值，值可以是任意类型）</p>
<p>当函数中没有return语句，，或者省略return语句的参数时，将返回None(空值)</p>
<h1 id="4、变量的作用域"><a href="#4、变量的作用域" class="headerlink" title="4、变量的作用域"></a>4、变量的作用域</h1><h2 id="4-1、局部变量"><a href="#4-1、局部变量" class="headerlink" title="4.1、局部变量"></a>4.1、局部变量</h2><p>局部变量就是在函数内部定义并使用的变量。（在函数外部使用会抛出NameError异常）</p>
<h2 id="4-2、全部变量"><a href="#4-2、全部变量" class="headerlink" title="4.2、全部变量"></a>4.2、全部变量</h2><p><strong>1、在函数外部定义</strong><br>值得注意的事，当全局变量与局部变量重名时，对函数体内的变量进行赋值后，不影响函数体外的变量。</p>
<p><strong>2、在函数内定义</strong><br>在函数体内定义全局变量，需要使用global关键字<br>语法格式</p>
<pre><code>global 变量
</code></pre><h1 id="5、匿名函数"><a href="#5、匿名函数" class="headerlink" title="5、匿名函数"></a>5、匿名函数</h1><p>匿名函数就是没有名字的函数，一般只使用一次。使用lambda关键字<br>语法格式</p>
<pre><code>result = lambda [arg1 [,arg2,...,argn]]：expression
</code></pre><p>参数说明：<br>result：用于调用lambda表达式<br>[arg1 [,arg2,…,argn]]：可选参数，用于指定的要传递的参数列表<br>expression: 必选参数，用于指定一个实现具体功能的表达式。</p>
<p>注意：使用lambda关键字只能有一个返回值和出现其他非表达式语句（如for或while）<br>如：</p>
<pre><code>import math
r = 10
result = lambda r: math.pi*r*r
print(&quot;半径为&quot;, r, &quot;的圆的面积为&quot;, result(r))
</code></pre><p>lambda的首页用途是指定短小的回调函数。</p>
<h1 id="6、牛刀小试"><a href="#6、牛刀小试" class="headerlink" title="6、牛刀小试"></a>6、牛刀小试</h1><h2 id="6-1、输出第几天"><a href="#6-1、输出第几天" class="headerlink" title="6.1、输出第几天"></a>6.1、输出第几天</h2><p>请编写一个程序，实现输入任意的年月日就可以计算出是这一年的第几天，如输入20190203，就可以输出这是2019年的第34天。</p>
<pre><code>def data(y, m, d):
    if m &lt;= 2:
        return &quot;这是&quot;+str(y)+&quot;年的第&quot;+str((m-1)*31+d)+&quot;天&quot;
    elif m in (3, 5, 7, 9, 10, 11, 12):
        return &quot;这是&quot; + str(y) + &quot;年的第&quot; + str((m - 1) * 31 + d - m//2 - 1 + y % 4 - 1) + &quot;天&quot;
    elif m in (4, 6, 8):
        return &quot;这是&quot; + str(y) + &quot;年的第&quot; + str((m - 1) * 31 + d - m//2 - 1 + y % 4) + &quot;天&quot;
</code></pre><p>​<br>     if <strong>name</strong> == ‘<strong>main</strong>‘:<br>            a = data(2017, 1, 1)<br>            print(a)</p>
<h2 id="6-2、找出重复IP"><a href="#6-2、找出重复IP" class="headerlink" title="6.2、找出重复IP"></a>6.2、找出重复IP</h2><p>下面list 中提供了几组IP地址，编写一个函数，将list中重复出现的IP地址找出来。<br>list=[‘192.168.1.1’,’10.192.66.72’,’10.199.88.132’, ‘192.168.1.1’,’1.192.168.163’]</p>
<pre><code>def main():
    a=[&apos;192.168.1.1&apos;,&apos;10.192.66.72&apos;,&apos;10.199.88.132&apos;, &apos;192.168.1.1&apos;,&apos;192.168.163&apos;]
    b=[]
    c=[]
    for i in range (0,len(a)):
        if a[i] not in b:
            b.append(a[i])
        else:
            c.append(a[i])

    print (c)
if __name__ == &apos;__main__&apos;:
    main()
</code></pre><h2 id="6-3、大写模式"><a href="#6-3、大写模式" class="headerlink" title="6.3、大写模式"></a>6.3、大写模式</h2><p>编写-一个函数，把输入的字母统一成大写模式， 如输入“go big or go home”,输出为“60BIG OR G0 HOME”。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">(a)</span>:</span></span><br><span class="line">    a = a.upper()</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    b = demo(<span class="string">'go big or go home'</span>)</span><br><span class="line">    print(b)</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wrgiun.github.io/2019/09/12/Python知识集合（异常处理和程序调试）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="giun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/12/Python知识集合（异常处理和程序调试）/" class="post-title-link" itemprop="url">Python知识集合（异常处理和程序调试）</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-12 20:42:11 / 修改时间：20:42:55" itemprop="dateCreated datePublished" datetime="2019-09-12T20:42:11+08:00">2019-09-12</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1、异常处理语句"><a href="#1、异常处理语句" class="headerlink" title="1、异常处理语句"></a>1、异常处理语句</h2><h2 id="1-1、try…except语句"><a href="#1-1、try…except语句" class="headerlink" title="1.1、try…except语句"></a>1.1、try…except语句</h2><p>语法格式：</p>
<pre><code>try:
    block1
except [ExceptionName [as alias]]:
    block2
</code></pre><p>   参数说明：<br>   block1：表示可能出错的代码块</p>
<p>   ExceptionName [as alias]:可选参数，用于指定要捕获的异常，其中 ExceptionName表示要捕获的异常名称，如果在其右侧加上 as alias 表示当前的异常指定一个别名。</p>
<p>   block2：表示进行异常处理的代码块，在这里可以输出固定的提示信息，也可以通过别名输出异常的具体内容</p>
<p>   注意：如果except后面不知道异常名称，则表示捕获全部异常。使用try…except语句捕获异常后，程序会继续执行。</p>
<h2 id="1-2、try-…except…else语句"><a href="#1-2、try-…except…else语句" class="headerlink" title="1.2、try …except…else语句"></a>1.2、try …except…else语句</h2><p>try …except…else语句与try …except语句的不同在于当没有异常时，使用else子语句。</p>
<p>例子</p>
<pre><code>def division():
    &apos;&apos;&apos; 实现功能：分苹果 &apos;&apos;&apos;
    print(&quot;\n-----------------分苹果了-----------------\n&quot;)
    apple = int(input(&quot;请输入苹果个数：&quot;))
    children = int(input(&quot;请输出一共有几个小朋友：&quot;))
    result = apple // children                 # 计算每个小朋友分几个苹果，输出整数
    remain = apple - result * children         # 计算剩下的苹果
    if remain &gt; 0:
        print(apple, &quot;个苹果，平均分给&quot;, children, &quot;个小朋友，每人分&quot;, result,&quot;个，剩下&quot;, remain, &quot;个。&quot;)
    else:
        print(apple, &quot;个苹果，平均分给&quot;, children, &quot;个小朋友，每人分&quot;, result, &quot;个。&quot;)
if __name__ == &apos;__main__&apos;:
    try:                                                # 捕获异常
        division()
    except ZeroDivisionError:                            # 处理zero异常
        print(&quot;\n出错了，不能把苹果分给0个小朋友。&quot;)
    except ValueError as e:                              # 处理value异常
        print(&quot;输入错误：&quot;, e)
    else:                                                # 没有抛出异常时执行
        print(&quot;苹果成功分给小朋友。&quot;)
</code></pre><h2 id="1-3、try-…except-…finally语句"><a href="#1-3、try-…except-…finally语句" class="headerlink" title="1.3、try …except …finally语句"></a>1.3、try …except …finally语句</h2><p>不管是否有异常产生，都会执行finally里的语句<br>语法格式：</p>
<pre><code>try:
    block1
except [ExceptionName [as alias]]:
    block2
finally:
    block3
</code></pre><p>例子</p>
<pre><code>def division():
    &apos;&apos;&apos; 实现功能：分苹果 &apos;&apos;&apos;
    print(&quot;\n-----------------分苹果了-----------------\n&quot;)
    apple = int(input(&quot;请输入苹果个数：&quot;))
    children = int(input(&quot;请输出一共有几个小朋友：&quot;))
    result = apple // children                 # 计算每个小朋友分几个苹果，输出整数
    remain = apple - result * children         # 计算剩下的苹果
    if remain &gt; 0:
        print(apple, &quot;个苹果，平均分给&quot;, children, &quot;个小朋友，每人分&quot;, result,&quot;个，剩下&quot;, remain, &quot;个。&quot;)
    else:
        print(apple, &quot;个苹果，平均分给&quot;, children, &quot;个小朋友，每人分&quot;, result, &quot;个。&quot;)
if __name__ == &apos;__main__&apos;:
    try:                                                # 捕获异常
        division()
    except ZeroDivisionError:                            # 处理zero异常
        print(&quot;\n出错了，不能把苹果分给0个小朋友。&quot;)
    except ValueError as e:                              # 处理value异常
        print(&quot;输入错误：&quot;, e)
    else:                                                # 没有抛出异常时执行
        print(&quot;苹果成功分给小朋友。&quot;)
     finally:
         print(&quot;进行了一次分苹果操作&quot;)
</code></pre><p>输出：</p>
<pre><code>-----------------分苹果了-----------------

请输入苹果个数：8
请输出一共有几个小朋友：0

出错了，不能把苹果分给0个小朋友。
进行了一次分苹果操作
</code></pre><h2 id="1-4、使用raise语句抛出异常"><a href="#1-4、使用raise语句抛出异常" class="headerlink" title="1.4、使用raise语句抛出异常"></a>1.4、使用raise语句抛出异常</h2><p>如果函数或方法中有异常，却不想在当前函数或方法中处理异常，可以使用raise处理异常。<br>语法格式：</p>
<pre><code>raise [ExceptionName [(raise)]]
</code></pre><h2 id="2、使用assert语句调试程序"><a href="#2、使用assert语句调试程序" class="headerlink" title="2、使用assert语句调试程序"></a>2、使用assert语句调试程序</h2><p>语法格式：</p>
<pre><code>assert expression [,reason]
</code></pre><p>说明：<br>expression: 条件表达式，如果该表达式为真什么，都不用做，如果为假抛出AssertionError异常。<br>reason：可选参数，用于对判断条件进行描述，为了以后更好的知道哪里出了问题<br>例子</p>
<pre><code>def division():
    &apos;&apos;&apos; 实现功能：分苹果 &apos;&apos;&apos;
    print(&quot;\n-----------------分苹果了-----------------\n&quot;)
    apple = int(input(&quot;请输入苹果个数：&quot;))
    children = int(input(&quot;请输出一共有几个小朋友：&quot;))
    assert apple &gt; children, &quot;苹果不够分&quot;
    result = apple // children                 # 计算每个小朋友分几个苹果，输出整数
    remain = apple - result * children         # 计算剩下的苹果
    if remain &gt; 0:
        print(apple, &quot;个苹果，平均分给&quot;, children, &quot;个小朋友，每人分&quot;, result,&quot;个，剩下&quot;, remain, &quot;个。&quot;)
    else:
        print(apple, &quot;个苹果，平均分给&quot;, children, &quot;个小朋友，每人分&quot;, result, &quot;个。&quot;)
if __name__ == &apos;__main__&apos;:
    division()
</code></pre><p>输出：</p>
<pre><code>请输入苹果个数：5
请输出一共有几个小朋友：8
Traceback (most recent call last):
  File &quot;D:/Python/web/test.py&quot;, line 14, in &lt;module&gt;
    division()
  File &quot;D:/Python/web/test.py&quot;, line 6, in division
    assert apple &gt; children, &quot;苹果不够分&quot;
AssertionError: 苹果不够分
</code></pre><p>通常情况下，assert语句可以和异常处理语句结合使用，把上面的代码的最后一行语句改为</p>
<pre><code>try:
    division()
except AssertionError as e:
    print(&quot;\n输出有误：&quot;, e)
</code></pre><p>输出</p>
<pre><code>-----------------分苹果了-----------------

请输入苹果个数：5
请输出一共有几个小朋友：8

输出有误： 苹果不够分
</code></pre><p>注意：assert语句只在调试阶段有效。我们可以通过在执行python命令时加入-O(大写)参数来关闭asset语句。<br>如在命令行窗口下可以使用以下命令</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -O 调试文件.py</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wrgiun.github.io/2019/09/12/Python知识整合（字符串及正则表达式）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="giun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/12/Python知识整合（字符串及正则表达式）/" class="post-title-link" itemprop="url">Python知识整合（字符串及正则表达式）</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-12 20:41:12 / 修改时间：20:41:46" itemprop="dateCreated datePublished" datetime="2019-09-12T20:41:12+08:00">2019-09-12</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1、字符串常规操作"><a href="#1、字符串常规操作" class="headerlink" title="1、字符串常规操作"></a>1、字符串常规操作</h1><h2 id="1-1、拼接字符串"><a href="#1-1、拼接字符串" class="headerlink" title="1.1、拼接字符串"></a>1.1、拼接字符串</h2><p>使用“+”号可以实现多个字符串的拼接，并产生一个字符串对象。<br>如</p>
<pre><code>a = &quot;123&quot;
print(a+&quot;1234&quot;)
</code></pre><h2 id="1-2计算字符串长度"><a href="#1-2计算字符串长度" class="headerlink" title="1.2计算字符串长度"></a>1.2计算字符串长度</h2><p>使用len（）函数<br>如</p>
<pre><code>str =&quot;123a,时候&quot;
print(len(str))
</code></pre><p>输出</p>
<pre><code>7
</code></pre><p>可以看出在len函数计算字符串的长度时，不区分数字，英文，汉字，所有字符都认为是一个字节<br>但是，如果采用UTF-8编码，汉字占3个字节，采用GBK或者GB2312编码时，汉字占2个字节<br>如</p>
<pre><code>str =&quot;123a,时候&quot;
print(len(str.encode()))   #utf-8编码
  print(len(str.encode(gbk)))   #gbk编码 
</code></pre><p>输出</p>
<pre><code>15
12
</code></pre><h2 id="1-3、截取字符串"><a href="#1-3、截取字符串" class="headerlink" title="1.3、截取字符串"></a>1.3、截取字符串</h2><p>通过切片方法实现<br>语法格式如下</p>
<pre><code>string(start : end : step)
</code></pre><p>   如</p>
<pre><code>str = &quot;你就是个啊哈&quot;
 str1 = str[1]       #截取第二个字符
 str1 = str[2:]      #从第3个字符开始截取
 str2 = str[:2]      #从左边开始截取2个字符
 str3 = str[2:4]   #截取第3个到第4个字符
</code></pre><h2 id="1-4、分隔字符串"><a href="#1-4、分隔字符串" class="headerlink" title="1.4、分隔字符串"></a>1.4、分隔字符串</h2><p>使用split函数分隔<br>语法格式</p>
<pre><code>str.split(sep,maxsplit)
</code></pre><p>说明<br>1、str:表示进行分隔的字符串<br>2、sep表示指定的分隔符，可以包含多个指定字符，如果不指定，那么默认为None，即所有的空字符（包括空格，\n等等）<br>3、maxsplit:可选参数，用于指定分隔的次数，如果不指定或者为-1，分隔次数没有限制，否则返回的元素最多为maxsplit+1。<br>4、如果不指定sep,也不能指定maxsplit<br>5、返回值为字符串列表</p>
<h2 id="1-5、检索字符串"><a href="#1-5、检索字符串" class="headerlink" title="1.5、检索字符串"></a>1.5、检索字符串</h2><p><strong>1、count方法</strong><br>count（）方法检索字符串在另一个字符串中出现的次数。如果字符串不存在返回0，否则返回次数，其语法格式如下。</p>
<pre><code>str.count(sub[,start[,end]])
</code></pre><p>说明：<br>str表示原字符串<br>sub表示要检索的字符串<br>start表示可选参数，检索的起始位置，若不指定，从头检索<br>end，与start相似。</p>
<p><strong>2、find方法</strong><br>检索是否包含指定的字符串，如果检索的字符串不存在则，返回-1，否则返回该字符串首次出现的索引<br>语法格式</p>
<pre><code>str.find(sub[,start[,end]])
</code></pre><p><strong>3、index（）方法</strong><br>与find（）方法类似，不过使用index()方法，当指定的字符串不存在时抛出异常<br>语法格式</p>
<pre><code>str.index(sub[,start[,end]])
</code></pre><p><strong>4、startwith()方法</strong><br>检测是否以指定字符串开头，是返回True,不是返回False<br>语法格式：</p>
<pre><code>str.startswith(prefix[,start[,end]])
</code></pre><p>参数说明，str表示原字符串，prefix表示要检索的字符串<br>其他参数说明与find()方法类似</p>
<p><strong>5、endwith()方法</strong><br>检测是否以指定字符串结尾，是返回True,不是返回False<br>语法格式</p>
<p>str.endswith(suffix[,start[,end]])</p>
<h2 id="1-6、字母的大小写转换"><a href="#1-6、字母的大小写转换" class="headerlink" title="1.6、字母的大小写转换"></a>1.6、字母的大小写转换</h2><p><strong>1、lower（）方法</strong><br>将字符串中的全部的大写字母转化为小写字母。<br>语法格式：</p>
<pre><code>str.lower()
</code></pre><p><strong>2、upper()方法</strong><br>将字符串中的全部的小写字母转化为大写字母。<br>语法格式：</p>
<pre><code>str.upper()
</code></pre><p><strong>3、swapcase()方法</strong><br>同时将字符串中的全部的小写字母转化为大写字母，全部的大写字母转化为小写字母。</p>
<pre><code>str.swapcase()
</code></pre><h2 id="1-7、去除字符串中的空格和特殊字符"><a href="#1-7、去除字符串中的空格和特殊字符" class="headerlink" title="1.7、去除字符串中的空格和特殊字符"></a>1.7、去除字符串中的空格和特殊字符</h2><p>特殊字符在这里指的是：\t \r \n(制表、回车、换行)<br><strong>1、strip（）方法</strong><br>去除字符串的左右两侧的空格和特殊字符<br>语法格式</p>
<pre><code>str.strip([chars])
</code></pre><p>如</p>
<pre><code>str1 = &quot; 12323 \n&quot;
print(&quot;原字符串str1：&quot; + str1)
print(&quot;字符串：&quot; + str1.strip() + &quot;.&quot;)   # 去除首尾的空格和特殊字符
str2 = &quot;#133#.&quot;
print(&quot;原字符串str2：&quot; + str2)
print(&quot;字符串：&quot; + str2.strip(&apos;#.&apos;))         #去除首位的#或者.
</code></pre><p>输出</p>
<pre><code>原字符串str1： 12323 

字符串：12323.
原字符串str2：#133#.
字符串：133
</code></pre><p><strong>2、lstrip()方法</strong><br>lstrip（）方法可以去除字符串左侧的空格和特殊字符，<br>语法格式</p>
<pre><code>str.lstrip([chars])
</code></pre><p><strong>3、rstrip()方法</strong><br>rstrip（）方法可以去除字符串由右侧的空格和特殊字符，<br>语法格式</p>
<pre><code>str.rstrip([chars])
</code></pre><h2 id="1-8、格式化字符串"><a href="#1-8、格式化字符串" class="headerlink" title="1.8、格式化字符串"></a>1.8、格式化字符串</h2><p>格式化字符串就是先定义一个模板，然后在模板中留几个空位，空位用占位符来标记</p>
<p><strong>1、使用%号操作符（逐渐没落）</strong></p>
<p>常用的格式化字符<br>| 格式化字符 | 说明                  | 格式化字符 | 说明                   |<br>| ———- | ——————— | ———- | ———————- |<br>| %s         | 字符串（采用str显示） | %r         | 字符串（采用repr显示） |<br>| %c         | 单个字符              | %o         | 八进制整数             |<br>| %d或者%i   | 十进制整数            | %e         | 指数（基地写为e）      |<br>| %x         | 16进制整数            | %E         | 指数（基地写为E）      |<br>| %f或者%F   | 浮点数                | %%         | 字符%                  |</p>
<p>如</p>
<pre><code>a = &quot;小明为莆田%d中学生，学号为%d,同学都叫他%s&quot;   # 定义模板
b1 = (6, 31111111, &apos;小明&apos;)                   # 定义与转化的内容
print(a % b1)                               # 格式化输出
</code></pre><p>输出</p>
<pre><code>小明为莆田6中学生，学号为31111111,同学都叫他小明
</code></pre><p><strong>2、使用字符串对象的format()方法（推荐使用）</strong><br>语法格式</p>
<pre><code>str.format(args)
</code></pre><p>args用于指定与转化的项</p>
<p><strong>format()方法中常用的格式化字符</strong><br>| s        | 对字符串类型进行格式化                      |<br>| ——– | ——————————————- |<br>| b        | 将十进制数自动转换成二进制数表示再格式化    |<br>| d        | 十进制整数                                  |<br>| o        | 将十进制数自动转换成八进制数表示再格式化    |<br>| c        | 将十进制数自动转换成对应的unicode字符       |<br>| x 或者 X | 将十进制数自动转换成十六进制数表示再格式化  |<br>| e或者E   | 转化为科学计数法表示再格式化                |<br>| f或者F   | 转化为浮点数（默认小数点后保留6位）再格式化 |<br>| g或者G   | 自动在e和f或者E和F中切换                    |<br>| %        | 显示百分比（默认小数点后保留6位）           |</p>
<p>如</p>
<pre><code>a = &quot;小明为莆田{:d}中学生，学号为{:0&gt;7d},同学都叫他{:s}&quot;   # 定义模板
b1 = a.format(6, 31111111, &apos;小明&apos;)             # 定义与转化的内容
print(b1)            # 格式化输出
</code></pre><p>输出</p>
<pre><code>小明为莆田6中学生，学号为31111111,同学都叫他小明
</code></pre><h1 id="2、正则表达式基础"><a href="#2、正则表达式基础" class="headerlink" title="2、正则表达式基础"></a>2、正则表达式基础</h1><h2 id="2-1、行定位符"><a href="#2-1、行定位符" class="headerlink" title="2.1、行定位符"></a>2.1、行定位符</h2><p>行定位符就是用来描述字符串的边界。“^”表示行的开始，“$”表示行的结尾<br>如</p>
<pre><code>^tm$
</code></pre><h2 id="2-2、常用的元字符"><a href="#2-2、常用的元字符" class="headerlink" title="2.2、常用的元字符"></a>2.2、常用的元字符</h2><table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>匹配除换行符以外的任意字符</td>
</tr>
<tr>
<td>\w</td>
<td>匹配字母数字、下划线或者汉字</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任意的空格符</td>
</tr>
<tr>
<td>\d</td>
<td>匹配数字</td>
</tr>
<tr>
<td>\b</td>
<td>匹配单词的开始或者结束</td>
</tr>
<tr>
<td>^</td>
<td></td>
<td>匹配字符串的开始</td>
</tr>
<tr>
<td>$</td>
<td>匹配字符串的结尾</td>
</tr>
</tbody>
</table>
<h2 id="2-3、限定符"><a href="#2-3、限定符" class="headerlink" title="2.3、限定符"></a>2.3、限定符</h2><p>如匹配8位QQ号码可以使用下面的方式表示</p>
<pre><code>^\d{8}$
</code></pre><p><strong>常用的限定符</strong><br>| 限定符 | 说明                            | 举例                                          |<br>| —— | ——————————- | ——————————————— |<br>| ？     | 匹配前面的字符零次或者一次      | app?le，该表达式可以匹配apple或者aple         |<br>| +      | 匹配前面的字符者一次或多次      | app+le，该表达式可以匹配apple到app….le      |<br>| <em>      | 匹配前面的字符者零次或多次      | app</em>le，该表达式可以匹配aple到app….le       |<br>| {n}    | 匹配前面的字符者n次             | app{2}le，该表达式可以匹配appple              |<br>| {n,}   | 匹配前面的字符者最少n次         | app{2,}le，该表达式可以匹配appple到appp…le  |<br>| {n,m}  | 匹配前面的字符者最少n次,最多m次 | app{2,3}le，该表达式可以匹配appple或者apppple |</p>
<h2 id="2-4、字符类"><a href="#2-4、字符类" class="headerlink" title="2.4、字符类"></a>2.4、字符类</h2><p>如果匹配没有预定义的元字符的字符集合（比如元音字母a,e,i,o,u）我们可以使用方括号，然后把要匹配的内容写在方括号里，如[aeiou]匹配任何一个元音字母。<br>[0-9]与\d的效果一样<br>[a-z0-9A-Z]与\w的效果一样(只考虑英文)<br>[\u4e00-\u9fa5]匹配给定字符串的任意一个汉字，匹配连续多个汉字[\u4e00-\u9fa5]+</p>
<h2 id="2-5、排除字符"><a href="#2-5、排除字符" class="headerlink" title="2.5、排除字符"></a>2.5、排除字符</h2><p>把^放在方括号里就是排除的意思<br>如</p>
<pre><code>[^a-zA-Z]
</code></pre><p>该表达式用于匹配一个不是字母的字符串</p>
<h2 id="2-6、选择字符"><a href="#2-6、选择字符" class="headerlink" title="2.6、选择字符"></a>2.6、选择字符</h2><p>例子，匹配身份证号码<br>身份证号码为15位或者18位，如果是15位的全为数字，如果是17位，则最后一位是效验位，为数字或者X(x)<br>可以使用下面表达式匹配</p>
<pre><code>^\d{15})|(^\d{18}) |(^\d{17} (\d|X|x)$
</code></pre><p>意思是匹配15位或者18位数字或者17位数字和最后一位是数字或者X或者x</p>
<h2 id="2-7、转义字符"><a href="#2-7、转义字符" class="headerlink" title="2.7、转义字符"></a>2.7、转义字符</h2><p>正则表达式中的转义字符也是将特殊字符（“.”、“？”，“\”）变为普通的字符<br>。如用正则表达式表示127.0.0.1这样格式的IP地址</p>
<pre><code>[1-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}
</code></pre><p>注意括号在正则表达式也算一个字符</p>
<h2 id="2-8、分组"><a href="#2-8、分组" class="headerlink" title="2.8、分组"></a>2.8、分组</h2><p>例子</p>
<pre><code>（thir|four）th
</code></pre><p>意思是匹配单词thirth或者fourth，如果不使用小括号，就变成了匹配单词thir和fourth</p>
<p>小括号的第二个作用就是分组。<br>如</p>
<pre><code>（\.[1-9]{1,3}){2},就是对（\.[1-9]{1,3})进行操作
</code></pre><h2 id="2-9、在python中使用正则表达式语法"><a href="#2-9、在python中使用正则表达式语法" class="headerlink" title="2.9、在python中使用正则表达式语法"></a>2.9、在python中使用正则表达式语法</h2><p>在Python中使用正则表达式就是将其作为模式字符串使用的。<br>将匹配以m开头的正则表达式转化为模式字符串</p>
<pre><code>&apos;\\bm\\w*\\b&apos;
</code></pre><p>因为模式字符串可能包含大量的特殊字符和斜杠，所以需要使用原生字符串<br>就是在模式字符串前加上r或者R.<br>如<br>     r ‘\bm\w*\b’</p>
<h1 id="3、使用re模块实现正则表达式操作"><a href="#3、使用re模块实现正则表达式操作" class="headerlink" title="3、使用re模块实现正则表达式操作"></a>3、使用re模块实现正则表达式操作</h1><h2 id="3-1、匹配字符串"><a href="#3-1、匹配字符串" class="headerlink" title="3.1、匹配字符串"></a>3.1、匹配字符串</h2><p><strong>1.使用match（）方法进行匹配</strong><br>如果在其实位置匹配成功，则返回Match对象，否则返回None,其语法格式如下：</p>
<pre><code>re.match(pattern,string,[flags])
</code></pre><p>说明<br>pattern:表示模式字符串，由要匹配的正则表达式转换而来<br>string:表示要匹配的字符串<br>flags：可选参数，表示标识位，用于控制匹配方式，如是否区分字母大小写。<br>常用的标志如下表所示<br>| 标志          | 说明                                                         |<br>| ————- | ———————————————————— |<br>| A或ASCII      | 对\w、\W、\b、\B、\d、\D、\s、\S只进行ASCII匹配（只适用Python3.x） |<br>| I或ICNORECASE | 执行不按字母大小写匹配                                       |<br>| M或MULTLINE   | 将^和$用于包括整个字符串的开始和结尾的每一行                 |<br>| S或DOTALL     | 使用“.”字符匹配所有字符，包括换行符                          |<br>| X或VERBOSE    | 忽略模式字符串中为转义的空格和注释                           |</p>
<p>如</p>
<pre><code>import re
pattern = r&apos;mr_\w+&apos;    # 模式字符串
string = &apos;MR_SHOP mr_shop&apos;   # 要匹配的字符串
match = re.match(pattern, string,re.I)  # 匹配字符串不区分大小写
print(&quot;匹配值的起始位置：&quot;, match.start())
print(&quot;匹配值的结束位置：&quot;, match.end())
print(&quot;匹配位置的元组：&quot;, match.span())
print(&quot;要匹配的字符串：&quot;, match.string)
print(&quot;匹配数据&quot;, match.group())
</code></pre><p>输出</p>
<pre><code>匹配值的起始位置： 0
匹配值的结束位置： 7
匹配位置的元组： (0, 7)
要匹配的字符串： MR_SHOP mr_shop
匹配数据 MR_SHOP
</code></pre><p><strong>2、使用search()方法进行匹配</strong><br>search()方法用于在整个字符串的搜索第一个匹配的值，如果在匹配成功返回match对象，否则返回None<br>语法格式</p>
<pre><code>re.search(pattern,string,[flags])
</code></pre><p>参数说明参考match方法</p>
<p><strong>3、使用findall()方法进行匹配</strong><br>findall方法主要用于整个字符串中搜索所有符合正则表达式的字符串，并以列表的形式返回。如果匹配成功返回包含匹配结构的列表，否则返回空列表。<br>语法格式</p>
<pre><code>re.findall(pattern,string,[flags])
</code></pre><p>参数说明参考match方法<br>如</p>
<pre><code>import re
pattern = r&apos;([1-9]{1,3}(\.[0-9]{1,3}){3})&apos;
str1 = &apos;127.0.0.1 192.168.122.2&apos;
match = re.findall(pattern, str1)
for i in match:
    print(i[0])
</code></pre><p>输出</p>
<pre><code>127.0.0.1
192.168.122.2
</code></pre><h2 id="3-2、替换字符"><a href="#3-2、替换字符" class="headerlink" title="3.2、替换字符"></a>3.2、替换字符</h2><p>使用sub()方法进行字符串替换<br>语法格式</p>
<pre><code>re.sub(pattern, repl, string, count, flags)
</code></pre><p>说明<br>pattern:表示模式字符串<br>repl:表示替换的字符串<br>string：表示要被查找替换的原始字符串<br>count: 可选参数表示模式匹配后替换的最大次数，默认为0表示替换所有的匹配<br>flags: 可选参数，表示标志位，用于控制匹配方式，如区分大小写等，参考match()方法</p>
<p>例子</p>
<pre><code>import re
pattern = r&apos;1[34578]\d{9}&apos;
string = &apos;中奖号码为：84795643 联系电话为：13611111111&apos;
result = re.sub(pattern, &apos;1xxxxxxxxxx&apos;, string)
print(result)
</code></pre><p>输出</p>
<pre><code>中奖号码为：84795643 联系电话为：1xxxxxxxxxx
</code></pre><h2 id="3-3、使用正则表达式分隔字符串"><a href="#3-3、使用正则表达式分隔字符串" class="headerlink" title="3.3、使用正则表达式分隔字符串"></a>3.3、使用正则表达式分隔字符串</h2><p>split()方法进行分隔字符串，并以列表形式返回<br>语法格式</p>
<pre><code>re.split(pattern, string, [maxsplit], [flags])
</code></pre><p>说明<br>pattern:表示模式字符串<br>string：表示要匹配的字符串<br>maxsplit: 可选参数，表示最大的拆分次数<br>flags: 可选参数，表示标志位，用于控制匹配方式，如区分大小写等，参考match()方法<br>例子</p>
<pre><code>import re
pattern = r&apos;[?|&amp;]&apos;
url = &apos;http://www.baidu.com?a=xxx&amp;b=yyyy&apos;
result = re.split(pattern, url)
print(result)
</code></pre><p>输出</p>
<pre><code>[&apos;http://www.baidu.com&apos;, &apos;a=xxx&apos;, &apos;b=yyyy&apos;]
</code></pre><h1 id="4、牛刀小试"><a href="#4、牛刀小试" class="headerlink" title="4、牛刀小试"></a>4、牛刀小试</h1><h2 id="4-1、按要求输出字符串"><a href="#4-1、按要求输出字符串" class="headerlink" title="4.1、按要求输出字符串"></a>4.1、按要求输出字符串</h2><p>已知字符串word=”aS98hdkHFSWEas754”,.编写一- 个程序，分别实现如下功能:<br>●请将word字符串中的大写字母改为小写字母，小写字母改为大写字母，<br>●请将word字符串中的数字取出，并输出成一 一个新的字符串</p>
<p><strong>普通版：</strong></p>
<pre><code>word = &quot;aS98hdkHFSWEas754&quot;
 a = &quot;&quot;
 b = &quot;&quot;
 for i in word:
     if  97 &lt;= ord(i) &lt;= 122:        #  小写字母变大写
         a = a + i.upper()              
     elif   65 &lt;= ord(i) &lt;= 90:      # 大写字母变小写
        a = a + i.lower()
     else:                                        
         a = a + i                   # 数字不变
         b = b + i                   # 数字取出，组成新的字符串
 word = a
 print(word)
 print(b)
</code></pre><p><strong>升级版：</strong></p>
<pre><code>word = &quot;aS98hdkHFSWEas754&quot;
word = word.swapcase()   # word字符串中的大写字母改为小写字母，小写字母改为大写字母
b = &quot;&quot;
for i in word:
    if &apos;0&apos;&lt;=i &lt;=&apos;9&apos;:
        b = b + i      # 数字取出，组成一个新的字符串
print(word)
print(b)
</code></pre><h2 id="4-2、输出生日信息"><a href="#4-2、输出生日信息" class="headerlink" title="4.2、输出生日信息"></a>4.2、输出生日信息</h2><p>张三的身份证号码是“210011196809210451”.请提取张三的生日信息并输出。</p>
<p>前置知识，身份证的第七位到第14位是出生日期，11位到14位是生日</p>
<pre><code>number = &quot;210011196809210451&quot;
birthday = &apos;张三的生日为：{:s}月{:s}日&apos;                   # 定义模块化字符串
print(birthday.format(number[10:12], number[12:14]))   # 使用format方法输出张三生日
</code></pre><h2 id="4-3、不重复字母"><a href="#4-3、不重复字母" class="headerlink" title="4.3、不重复字母"></a>4.3、不重复字母</h2><p>已知字符串word=”ABDPISDNGDA”.请去除word字符串多次出现的字母，仅留最先出现的一个。例如aabc经过去除后，输出abc。</p>
<pre><code>b =&quot;&quot;
word=&quot;ABDPISDNGDA&quot;

for i in word:

    if i not in b:
        b += i
print(b)
</code></pre><h2 id="4-4、英文句子倒叙输出"><a href="#4-4、英文句子倒叙输出" class="headerlink" title="4.4、英文句子倒叙输出"></a>4.4、英文句子倒叙输出</h2><p>将一句英文句于单词顺序留序输出，但是不改变单词结构。例如: 1 am a beautiful ginl,输出为girl beautiful a am I</p>
<pre><code>a = input(&quot;请输入英文句子：&quot;)
b = a.split()                      # 将字符串按空格分开，生产一个列表
c = &quot;&quot;
for index, item in enumerate(b):   # 利用索引倒叙输出列表的值，并拼接为字符串
    c = c + b[-1 - index] + &quot; &quot;
print(c)
</code></pre><p>输出</p>
<pre><code>请输入英文句子：You are a beautiful girl
girl beautiful a are You 
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wrgiun.github.io/2019/09/12/python知识整合（序列）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="giun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/12/python知识整合（序列）/" class="post-title-link" itemprop="url">python知识整合（序列）</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-12 20:40:20 / 修改时间：20:40:50" itemprop="dateCreated datePublished" datetime="2019-09-12T20:40:20+08:00">2019-09-12</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1、序列"><a href="#1、序列" class="headerlink" title="1、序列"></a>1、序列</h1><p>序列就是用于存放多个值的连续的空间，且具有顺序关系。<br>python中序列结构主要包括列表、元素、集合和字典。</p>
<h2 id="1-1索引（indexing）"><a href="#1-1索引（indexing）" class="headerlink" title="1.1索引（indexing）"></a>1.1索引（indexing）</h2><p>索引是从0开始计算<br>在python中索引也可以是负数，从右向左计数，最右边的数是的索引为-1（也就是最后一个数的下标可以是-1）.<br>如</p>
<pre><code>a = [&quot;你&quot;,&quot;好&quot;,&quot;啊&quot;,&quot;吗&quot;]
print( a[0] )
print(a[-4])
print(&quot;--------分割线--------&quot;)
print(a[1])
print(a[-3])
print(&quot;--------分割线--------&quot;)
print(a[2])
print(a[-2])
print(&quot;--------分割线--------&quot;)
print(a[3])
print(a[-1])
</code></pre><p>输出</p>
<pre><code>你
你
--------分割线--------
好
好
--------分割线--------
啊
啊
--------分割线--------
吗
吗
</code></pre><h2 id="1-2、切片（Slicing）"><a href="#1-2、切片（Slicing）" class="headerlink" title="1.2、切片（Slicing）"></a>1.2、切片（Slicing）</h2><p>切片操作是访问序列中的元素的另一种方法<br><strong>语法格式：</strong></p>
<pre><code>sname[start : end : step]
</code></pre><p><strong>说明：</strong><br>1、sname:序列的名字<br>2、start:切片的起始位置（包括该位置），如果不指定，默认为0<br>3、end：切片的截止位置（不包括该位置），如果不知道，默认为序列的长度<br>4、step: 切片的步长，如果省略（省略时可以连最后一个冒号也一起省略），默认为1。</p>
<p>如：</p>
<pre><code>animal = [&quot;小马&quot;, &quot;小牛&quot;, &quot;小羊&quot;, &quot;小狗&quot;, &quot;小猴&quot;, &quot;小猫&quot;, &quot;小蛇&quot;, &quot;小虎&quot;, &quot;小兔&quot;]
print(animal[1:5])
print(animal[2:5:2])
</code></pre><p>输出</p>
<pre><code>[&apos;小牛&apos;, &apos;小羊&apos;, &apos;小狗&apos;, &apos;小猴&apos;]
[&apos;小羊&apos;, &apos;小猴&apos;]
</code></pre><p>技巧：如果需要复制一整个序列，可以将start,end都有省略，但是中间的冒号要保留。如</p>
<pre><code>animal[ : ]
</code></pre><h2 id="1-3、序列相加与相乘"><a href="#1-3、序列相加与相乘" class="headerlink" title="1.3、序列相加与相乘"></a>1.3、序列相加与相乘</h2><p><strong>1、序列相加</strong><br>可以将2个同类型（同为列表、元组、字典等，序列里的元素类型可以不同）的序列进行相加操作（使用+号进行），其实就是拼接2个序列</p>
<p><strong>2、序列相乘</strong><br>一个序列乘以数字n，那么就将序列重复n次成为新的序列。<br>如</p>
<pre><code>animal = [&quot;小马&quot;, &quot;小牛&quot;, &quot;小羊&quot;]
print(animal * 3)
</code></pre><p>输出</p>
<pre><code>[&apos;小马&apos;, &apos;小牛&apos;, &apos;小羊&apos;, &apos;小马&apos;, &apos;小牛&apos;, &apos;小羊&apos;, &apos;小马&apos;, &apos;小牛&apos;, &apos;小羊&apos;]
</code></pre><p>如果只是为了初始化指定列表长度的功能，那么可以采取以下方式<br>如</p>
<pre><code>a = [None] * 5
print(a)
</code></pre><p>输出</p>
<pre><code>[None, None, None, None, None]
</code></pre><h2 id="1-4、检查某个元素是否是序列的成员（元素）"><a href="#1-4、检查某个元素是否是序列的成员（元素）" class="headerlink" title="1.4、检查某个元素是否是序列的成员（元素）"></a>1.4、检查某个元素是否是序列的成员（元素）</h2><p>可以使用in关键字来检查<br><strong>语法格式:</strong></p>
<pre><code>value in sequence
</code></pre><p>例子</p>
<pre><code>animal = [&quot;小马&quot;, &quot;小牛&quot;, &quot;小羊&quot;]
print(&quot;小马&quot; in animal)
print(&quot;xiaoma&quot; in animal)
print(&quot;xiaoma&quot; not in animal)
</code></pre><p>输出</p>
<pre><code>True
False
True
</code></pre><h2 id="1-5、计算序列的长度、最大值和最小值"><a href="#1-5、计算序列的长度、最大值和最小值" class="headerlink" title="1.5、计算序列的长度、最大值和最小值"></a>1.5、计算序列的长度、最大值和最小值</h2><p>计算序列的长度使用内置函数len()、最大值使用内置函数max()和最小值使用内置函数min()<br>如：</p>
<pre><code>a = [&quot;1&quot;, &quot;5&quot;, &quot;2&quot;]
print(&quot;a序列的长度&quot;, len(a))
print(&quot;a序列的最大元素&quot;, max(a))
print(&quot;a序列的最小元素&quot;, min(a))
</code></pre><p>输出</p>
<pre><code>a序列的长度 3
a序列的最大元素 5
a序列的最小元素 1
</code></pre><p>python中的其他内置函数及其作用</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>list()</td>
<td>将序列转化为列表</td>
</tr>
<tr>
<td>str</td>
<td>将序列转化为字符串</td>
</tr>
<tr>
<td>sum()</td>
<td>计算元素和</td>
</tr>
<tr>
<td>sorted</td>
<td>对元素进行排序</td>
</tr>
<tr>
<td>reversed()</td>
<td>反向序列元素</td>
</tr>
<tr>
<td>enumerate()</td>
<td>将序列组合为一个索引序列，多用在for循环中</td>
</tr>
</tbody>
</table>
<p>如</p>
<pre><code>a = [&quot;1&quot;, &quot;5&quot;, &quot;2&quot;]
print(&quot;[1,2,3]序列的元素和&quot;, sum([1,2,3]))
print(&quot;正序&quot;, sorted(a, reverse=True))
print(&quot;逆序&quot;, sorted(a, reverse=False))
</code></pre><h1 id="2、列表（list）"><a href="#2、列表（list）" class="headerlink" title="2、列表（list）"></a>2、列表（list）</h1><p>python中的列表是非常灵活的，列表里的元素内容可以不同，因为他们之间没有任何关系，但是通常情况下我们在一个列表里只放一种数据类型，为得是增加数据的可读性</p>
<h2 id="2-1、创建与删除列表"><a href="#2-1、创建与删除列表" class="headerlink" title="2.1、创建与删除列表"></a>2.1、创建与删除列表</h2><p><strong>1、使用赋值运算符直接创建列表</strong><br>语法格式如下：</p>
<pre><code>listname = [element 1, element 2, ......, element n]      
</code></pre><p><strong>2、创建空列表</strong><br>语法如下：</p>
<pre><code>emptylist = []
</code></pre><p><strong>3、创建数值列表</strong><br>可以使用list()函数直接将range()函数循环出口的结果直接转换为列表<br>语法如下：（其中data的类型可以是range对象、字符串、元组或者其他可以迭代类型的数据）</p>
<pre><code>list(data)
</code></pre><p>例子：</p>
<pre><code>print(list(range(10)))
</code></pre><p>输出</p>
<pre><code>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre><p><strong>4、删除列表</strong><br>语法格式：</p>
<pre><code>del listname
</code></pre><p>值得注意的是在python中有自带的垃圾回收机制会自动销毁不用的列表，故该语句我们比较少用。</p>
<h2 id="2-2、访问列表元素"><a href="#2-2、访问列表元素" class="headerlink" title="2.2、访问列表元素"></a>2.2、访问列表元素</h2><p>输出列表或者列表的某个元素的语法格式：</p>
<pre><code>print(listname)或者print(listname[n])
</code></pre><h2 id="2-3、遍历列表"><a href="#2-3、遍历列表" class="headerlink" title="2.3、遍历列表"></a>2.3、遍历列表</h2><p>遍历列表的方法很多，这边介绍2种最常用的</p>
<p> <strong>1、使用for循环</strong><br>语法格式：</p>
<pre><code>for item in listname:
    # 输出item
</code></pre><p>例子：</p>
<pre><code>fruit = [&apos;apple&apos;, &apos;banana&apos;, &apos;orange&apos;, &apos;pear&apos;, &apos;watermelon&apos;]
for i in fruit:
    print(i)
</code></pre><p>输出</p>
<pre><code>apple
banana
orange
pear
watermelon
</code></pre><p><strong>2、使用for循环和enumerate()函数实现</strong><br>使用for循环和enumerate()函数实现输出索引和元素<br>语法格式：</p>
<pre><code>for index, item in enumerate(listname):
</code></pre><p>例子</p>
<pre><code>fruit = [&apos;apple&apos;, &apos;banana&apos;, &apos;orange&apos;, &apos;pear&apos;, &apos;watermelon&apos;]
for index,i in enumerate(fruit):
    print(index, i)
</code></pre><p>输出</p>
<pre><code>0 apple
1 banana
2 orange
3 pear
4 watermelon
</code></pre><h2 id="2-4、添加、删除、修改列表元素"><a href="#2-4、添加、删除、修改列表元素" class="headerlink" title="2.4、添加、删除、修改列表元素"></a>2.4、添加、删除、修改列表元素</h2><p><strong>1、添加元素</strong><br>语法格式如下：</p>
<pre><code>listname.append(obj)    #速度快，常用
或者
使用+号，                #速度太慢
或者
insert()函数            #效率低，不推荐
</code></pre><p>例子：</p>
<pre><code>fruit = [&apos;apple&apos;, &apos;banana&apos;, &apos;orange&apos;, &apos;pear&apos;, &apos;watermelon&apos;]
print(&quot;水果的种类有&quot; + str(len(fruit)) + &apos;种&apos;)
fruit.append(&quot;grape&quot;)
print(&quot;水果的种类有&quot;+ str(len(fruit)) + &apos;种&apos;)
</code></pre><p>输出</p>
<pre><code>水果的种类有5种
水果的种类有6种
</code></pre><p>如果要将一个列表里的元素全部添加到另一个列表<br>可以使用下面语句：</p>
<pre><code>listname.extend(seq)         #seq为要添加进去的列表
</code></pre><p><strong>2、修改元素</strong><br>直接举例子说明</p>
<pre><code>fruit = [&apos;apple&apos;, &apos;banana&apos;, &apos;orange&apos;, &apos;pear&apos;, &apos;watermelon&apos;]
print(fruit)
fruit[2] = &apos;strawberry&apos;
print(fruit)
</code></pre><p>输出</p>
<pre><code>[&apos;apple&apos;, &apos;banana&apos;, &apos;orange&apos;, &apos;pear&apos;, &apos;watermelon&apos;]
[&apos;apple&apos;, &apos;banana&apos;, &apos;strawberry&apos;, &apos;pear&apos;, &apos;watermelon&apos;]
</code></pre><p><strong>3、删除元素</strong></p>
<p>（1）、根据索引删除</p>
<p>如：</p>
<pre><code>fruit = [&apos;apple&apos;, &apos;banana&apos;, &apos;orange&apos;, &apos;pear&apos;, &apos;watermelon&apos;]
del fruit[1]
print(fruit)
</code></pre><p>输出</p>
<pre><code>[&apos;apple&apos;, &apos;orange&apos;, &apos;pear&apos;, &apos;watermelon&apos;]
</code></pre><p>（2）、根据元素值删除</p>
<p>如：</p>
<pre><code>fruit = [&apos;apple&apos;, &apos;banana&apos;, &apos;orange&apos;, &apos;pear&apos;, &apos;watermelon&apos;]
value = &quot;apple&quot;
if fruit.count(value) &gt; 0:    # 判断元素是否存在防止报错
    fruit.remove(value)
print(fruit)
</code></pre><p>输出</p>
<pre><code>[&apos;banana&apos;, &apos;orange&apos;, &apos;pear&apos;, &apos;watermelon&apos;]
</code></pre><h2 id="2-5、对列表进行统计计算"><a href="#2-5、对列表进行统计计算" class="headerlink" title="2.5、对列表进行统计计算"></a>2.5、对列表进行统计计算</h2><p><strong>1、获取指定元素出现的次数</strong><br>使用count()函数<br>语法格式：</p>
<pre><code>listname.count(obj)
</code></pre><p><strong>2、获取指定元素首次出现的下标</strong><br>使用index（）函数<br>语法格式：</p>
<pre><code>listname.index(obj)
</code></pre><p><strong>3、统计数值列表的元素和</strong><br>使用sum()函数</p>
<pre><code>sum(iterable[,strart])    #iterable为要统计的列表名
</code></pre><h2 id="2-6、对列表进行排序"><a href="#2-6、对列表进行排序" class="headerlink" title="2.6、对列表进行排序"></a>2.6、对列表进行排序</h2><p><strong>1、使用sort函数进行排序</strong><br>语法格式：</p>
<pre><code>listname.sort(key=None,reverse=False)
</code></pre><p>参数说明，key是指定一个比较键，如当key=str.lower时，不区分大小写。<br>reverse=False时为降序，为True时为升序，默认为升序。</p>
<p>注意sort()函数对字符串进行排序时，先对大写字母进行排序，然后对小写字母进行排序。且对中文排序时，容易出错<br>如</p>
<pre><code>fruit = [&apos;Apple&apos;, &apos;banana&apos;, &apos;Orange&apos;, &apos;pear&apos;, &apos;watermelon&apos;]
print(&apos;-------区分大小写-------&apos;)
fruit.sort()
print(fruit)
print(&apos;-------不区分大小写-------&apos;)
fruit.sort(key=str.lower)
print(fruit)
</code></pre><p>输出<br>——-区分大小写——-</p>
<pre><code>[&apos;Apple&apos;, &apos;Orange&apos;, &apos;banana&apos;, &apos;pear&apos;, &apos;watermelon&apos;]
-------不区分大小写-------
[&apos;Apple&apos;, &apos;banana&apos;, &apos;Orange&apos;, &apos;pear&apos;, &apos;watermelon&apos;]
</code></pre><p><strong>2、使用sorted()函数进行排序</strong><br>作用与sort()基本一样，但是sorted（）不会改变原列表的顺序，sort（）会。<br>语法格式：</p>
<pre><code>sorted(iterable, key=None,reverse=False)   #iterable为要排序的列表
</code></pre><p>如</p>
<pre><code>fruit = [&apos;Apple&apos;, &apos;banana&apos;, &apos;Orange&apos;, &apos;pear&apos;, &apos;watermelon&apos;]
fruit_a = sorted(fruit)
print(&quot;原列表顺序不变&quot;, fruit)
print(fruit_a)
</code></pre><p>输出</p>
<pre><code>原列表顺序不变 [&apos;Apple&apos;, &apos;banana&apos;, &apos;Orange&apos;, &apos;pear&apos;, &apos;watermelon&apos;]
[&apos;Apple&apos;, &apos;Orange&apos;, &apos;banana&apos;, &apos;pear&apos;, &apos;watermelon&apos;]
</code></pre><h2 id="2-7、列表推导式"><a href="#2-7、列表推导式" class="headerlink" title="2.7、列表推导式"></a>2.7、列表推导式</h2><p>使用列表推导式可以快速生成一个列表，或让摸个列表生成满足指定需求的列表。<br>有以下几种常用方法<br><strong>1、生成指定范围的数值列表</strong><br>语法格式：<br>list = [Expression for var in range]  </p>
<p>参数说明：list生成的列表名，Expression表达式用于计算新列表的元素<br>var循环变量，range采用range()生成的range对象<br>如生产10个随机数，范围在10到100之间</p>
<pre><code>import random
randomnumber = [random.randint(10,100) for i in range(10)]
print(randomnumber)
</code></pre><p>输出</p>
<pre><code>[65, 50, 57, 84, 56, 30, 27, 47, 98, 79]
</code></pre><p><strong>2、根据列表生成指定需求的列表</strong><br>语法格式：</p>
<pre><code>newlist = [Expression for var in list]
</code></pre><p>如</p>
<pre><code>import random
price = [100, 200, 300]           # 商品价格
sale = [int(i*0.5) for i in price]      # 打五折后的价格
print(sale)
</code></pre><p>输出</p>
<pre><code>[50, 100, 150]
</code></pre><p><strong>3、从列表中选择符合条件的元素组成新的列表</strong><br>语法格式：</p>
<pre><code>newlist = [Expression for var in list if condition]
如
import random
price = [100, 200, 300]           # 商品价格
sale = [i for i in price if i &gt; 200]      # 价格大于200的商品价格
print(sale)
</code></pre><p>输出</p>
<pre><code>[300]
</code></pre><h1 id="3、元组"><a href="#3、元组" class="headerlink" title="3、元组"></a>3、元组</h1><p>元组简单说就是<strong>不可变</strong>的<strong>列表</strong>（不可变序），用于保存不可修改的内容。</p>
<h2 id="3-1、元组的创建与删除"><a href="#3-1、元组的创建与删除" class="headerlink" title="3.1、元组的创建与删除"></a>3.1、元组的创建与删除</h2><p><strong>1、用赋值运算符直接创建元组</strong><br>语法格式（括号可以省略）</p>
<pre><code>tuplename = (element 1,element 2,...element n)
</code></pre><p>如果创建的元组只有一个符号时，需要在元素的后面加个逗号<br>如：</p>
<pre><code>a = (&quot;a&quot;,)   # 元组
a = (&quot;a&quot;)    # 字符串
</code></pre><p><strong>2、创建空元组</strong><br>语法格式</p>
<pre><code>emptytuple = ()
</code></pre><p><strong>3、创建数值元组</strong><br>语法格式</p>
<pre><code>tuple(data)
</code></pre><p>如</p>
<pre><code>print(tuple(range(0, 10, 3)))
</code></pre><p>输出</p>
<pre><code>(0, 3, 6, 9)
</code></pre><p><strong>4、删除元组</strong><br>语法格式</p>
<pre><code>del tuplename
</code></pre><h2 id="3-2、访问元组元素"><a href="#3-2、访问元组元素" class="headerlink" title="3.2、访问元组元素"></a>3.2、访问元组元素</h2><p><strong>print直接打印元组</strong><br>语法格式</p>
<pre><code>print(tuplename)         #打印整个元组
print(tuplename[n])      #打印单个元组元素
print(tuplement[x:y])    #打印多个元素
</code></pre><p>当然也可以使用for循环来遍历，语法格式与列表一样</p>
<h2 id="3-3、修改元组元素"><a href="#3-3、修改元组元素" class="headerlink" title="3.3、修改元组元素"></a>3.3、修改元组元素</h2><p>修改元组里的单个元素的内容，是<strong>不支持</strong>的<br>如</p>
<pre><code>a = (1,2,3)
a[1]= &quot;a&quot;
print(a)
</code></pre><p>报错</p>
<pre><code>TypeError: &apos;tuple&apos; object does not support item assignment
</code></pre><p>但是我们可以把一整个元组重新赋值<br>如</p>
<pre><code>a = (&apos;1&apos;, 2, 3)
print(a)
a = (&apos;1&apos;, 6, 9)
print(a)
a = a+a
print(a)
</code></pre><p>输出</p>
<pre><code>(&apos;1&apos;, 2, 3)
(&apos;1&apos;, 6, 9)
(&apos;1&apos;, 6, 9, &apos;1&apos;, 6, 9)
</code></pre><p>注意进行元组的连接时，连接的内容必须都是元组。连接的元组只有一个元素时，不用忘记元素后面的逗号。</p>
<h2 id="3-4、元组的推导式"><a href="#3-4、元组的推导式" class="headerlink" title="3.4、元组的推导式"></a>3.4、元组的推导式</h2><p>语法格式与列表类似</p>
<p>例子</p>
<pre><code>import random
randomname = (random.randint(10,100) for i in range(5))
print(&quot;生产的元组为&quot;, randomname)
</code></pre><p>输出</p>
<pre><code>生产的元组为 &lt;generator object &lt;genexpr&gt; at 0x000001C573448E60&gt;
</code></pre><p>可以发现元组推导式生成的结果是一个生成器对象，而不是元组或者列表。这点与列表不同。其中转化成元组用tuple()函数，转化为列表用list函数</p>
<p>通过for循环遍历，或者使用<strong>next</strong>()方法可以使用元组推导器生成的生成器对象</p>
<p>如：（<strong>next</strong>()例子）</p>
<pre><code>import random
randomname = (i for i in range(3))
print(randomname.__next__())
print(randomname.__next__())
print(randomname.__next__())
print(tuple(randomname))
</code></pre><p>输出</p>
<pre><code>0
1
2
()
</code></pre><p>如（for循环遍历例子）</p>
<pre><code>import random
randomname = (i for i in range(3))
for i in randomname:
    print(i, end=&quot; &quot;)
print(tuple(randomname))
</code></pre><p>输出</p>
<pre><code>0 1 2 ()
</code></pre><h2 id="3-5、元组与列表的区别"><a href="#3-5、元组与列表的区别" class="headerlink" title="3.5、元组与列表的区别"></a>3.5、元组与列表的区别</h2><p>1、元组不可变序列；列表可变序列</p>
<p>2、元组不能修改、添加，删除单个元素；列表可以</p>
<p>3、元组只支持切片访问，不支持切片修改；列表都支持</p>
<p>4、元组访问和处理速度比列表快。使用当只需要对其中的元素进行访问时，，建议使用元组</p>
<p>5、元组可以作为字典的键；列表不能。</p>
<h1 id="4、字典"><a href="#4、字典" class="headerlink" title="4、字典"></a>4、字典</h1><p>字典是无序的可变序列。保存内容是以“键—值对”的形式存放，键是唯一的，值可以是多个的。</p>
<p><strong>字典的主要特征：</strong><br>1、通过键来读取而不是索引</p>
<p>2、字典是任意对象的无序集合</p>
<p>3、字典是可变的，并且可以任意嵌套。</p>
<p>4、字典的键必须是唯一和不可变的。</p>
<h2 id="4-1、字典的创建与删除"><a href="#4-1、字典的创建与删除" class="headerlink" title="4.1、字典的创建与删除"></a>4.1、字典的创建与删除</h2><p><strong>创建字典语法格式</strong></p>
<pre><code>dictionary = {&apos;key1&apos;:&apos;value1&apos;,&apos;key1&apos;:&apos;value1&apos;,...,&apos;keyn&apos;:&apos;valuen&apos;,}
</code></pre><p><strong>创建空字典的语法</strong></p>
<pre><code>dictionary = {}或者dictionary = dict()
</code></pre><p><strong>1、通过映射函数创建字典</strong></p>
<pre><code>dicttionary = dict(zip(list1,list2))   #list1作为键的列表  list2作为值的列表
</code></pre><p>注意如果list1与list2长度不一样，则与最短的列表长度一样</p>
<p><strong>2、通过“键——值对”创建字典</strong></p>
<pre><code>dictionary = dict(key1=value1,key2=value2,...,keyn=value n)
</code></pre><p>如</p>
<pre><code>a = dict(福州=&apos;3&apos;,)
print(a)
</code></pre><p>输出</p>
<pre><code>{&apos;福州&apos;: &apos;3&apos;}
</code></pre><p>python中还可以使用dict对象的fromkeys()方法创建值为空的字典<br>语法格式：</p>
<pre><code>dictionary = dict.fromkeys(list1)   #list1为键的列表
</code></pre><p>当然还有可以通过存在的元组和列表来创建字典（列表不能作为键，字典可以）<br>如</p>
<pre><code>list = [1, 2, 3]
b = (&apos;1&apos;, &apos;2&apos;, &apos;3&apos;)
c = {b: list}
print(c)
</code></pre><p>输出</p>
<pre><code>{(&apos;1&apos;, &apos;2&apos;, &apos;3&apos;): [1, 2, 3]}
</code></pre><p><strong>3、删除字典</strong><br>语法格式</p>
<pre><code>del dictionary
</code></pre><p><strong>4、把字典变为空字典</strong><br>语法格式</p>
<pre><code>dictionary.clear()
</code></pre><p>当然还有pop(),popitem（）方法。</p>
<h2 id="4-2、通过键—值对访问字典"><a href="#4-2、通过键—值对访问字典" class="headerlink" title="4.2、通过键—值对访问字典"></a>4.2、通过键—值对访问字典</h2><p>如果想直接输出字典的内容直接<code>printf（dictionary）</code>，但是我们一般不这么做。一般是根据指定的键得到我们想要的结果。<br>如</p>
<pre><code>print(dictionary([key])
</code></pre><p>但是这样容易出错，我们一般使用以下语句</p>
<pre><code>print(dictionary[key] if  &apos;key &apos; in dictionary else &apos;我的字典里没有该内容&apos;)
</code></pre><p>python中推荐使用字典对象的<code>get()</code>方法获取指定的键的值<br>语法格式如下：</p>
<pre><code>dictionary.get(key,[default])
</code></pre><p>说明defaults是当指定的键不存的时候就返回一个默认值，default可以省略，如果省略返回None</p>
<h2 id="4-3、遍历字典"><a href="#4-3、遍历字典" class="headerlink" title="4.3、遍历字典"></a>4.3、遍历字典</h2><p><strong>1、通过items()方法遍历</strong><br>语法格式：</p>
<pre><code>dictionary.items()  #返回可以遍历的j键-值元组列表
</code></pre><p><strong>2、for循环遍历该元组列表</strong><br>如</p>
<pre><code>dictionary = {&apos;qq&apos;:&apos;12333&apos;}
for i in dictionary.items():
    print(i)
    或
for key,value in dictionary():
    print(value)
</code></pre><h2 id="4-4、添加、修改、删除字典元素"><a href="#4-4、添加、修改、删除字典元素" class="headerlink" title="4.4、添加、修改、删除字典元素"></a>4.4、添加、修改、删除字典元素</h2><p><strong>1、添加元素</strong><br>语法格式</p>
<pre><code>dictionary[key] = value
</code></pre><p>注意如果键名之前已经存在，那么将换替换该键的值</p>
<p>2、删除某个元素<br>如：</p>
<pre><code>dictionary = dict[key]
或者
if &quot;key&quot; in dictionary:    #防止键不存在时报错
    dictionary = dict[key]
</code></pre><h2 id="4-5、字典推导式"><a href="#4-5、字典推导式" class="headerlink" title="4.5、字典推导式"></a>4.5、字典推导式</h2><p>其表现形式与列表推导式相似，这边不做说明</p>
<h1 id="5、列表、元组、字典的区别"><a href="#5、列表、元组、字典的区别" class="headerlink" title="5、列表、元组、字典的区别"></a>5、列表、元组、字典的区别</h1><table>
<thead>
<tr>
<th>数据结构</th>
<th>是否可变</th>
<th>是否有序</th>
<th>定义符号</th>
</tr>
</thead>
<tbody>
<tr>
<td>列表</td>
<td>可变</td>
<td>有序</td>
<td>[]</td>
</tr>
<tr>
<td>元组</td>
<td>不可变</td>
<td>有序</td>
<td>()</td>
</tr>
<tr>
<td>字典</td>
<td>可变</td>
<td>无序</td>
<td>{key,value}</td>
</tr>
</tbody>
</table>
<p>题目：创建一个包含1~50之间所有素数的列表，打印显示该列表;随后只保留该列表前5个数字，删除其余内容并打印输出相应结果;再将每个元素值加。上20，显示列表内容。</p>
<pre><code>prime_number = [2]
for i in range(3, 51):
    for j in range(2, i):
        if i % j != 0:
            n = i
            if j == n-1:
                prime_number.append(i)
                break
        else:
            break
print(prime_number)
prime_number = prime_number[:5]
for k in range(5):
    prime_number[k] = prime_number[k] + 20
print(prime_number)
</code></pre><h1 id="6、逻辑判断内置函数"><a href="#6、逻辑判断内置函数" class="headerlink" title="6、逻辑判断内置函数"></a>6、逻辑判断内置函数</h1><table>
<thead>
<tr>
<th>all(iterable)</th>
<th>集合中的元素都为真的时候为真，注意空字串返回为True</th>
</tr>
</thead>
<tbody>
<tr>
<td>any(iterable)</td>
<td>集合中的元素有一个为真的时候为真，特别是空串返回False</td>
</tr>
<tr>
<td>cmp（x,y）</td>
<td>x&lt;y，返回负数；x = y,返回0；x&gt;y返回正数</td>
</tr>
</tbody>
</table>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wrgiun.github.io/2019/09/12/python知识整合（基础）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="giun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/09/12/python知识整合（基础）/" class="post-title-link" itemprop="url">python知识整合（基础）</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-09-12 20:38:07 / 修改时间：20:39:39" itemprop="dateCreated datePublished" datetime="2019-09-12T20:38:07+08:00">2019-09-12</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文章内容的python版本默认为python3.x</p>
<h1 id="1、注释"><a href="#1、注释" class="headerlink" title="1、注释"></a>1、注释</h1><p>注释包括单行注释，多行注释，中文声明注释</p>
<h2 id="1-1、单行注释"><a href="#1-1、单行注释" class="headerlink" title="1.1、单行注释"></a>1.1、单行注释</h2><p>注释内容从#号到换行为止结束<br><strong>语法格式：</strong></p>
<pre><code># 注释内容
</code></pre><p><strong>注释格式：</strong><br><strong>第一种</strong></p>
<pre><code>#请输入你的年龄
age=int(input(&quot;请输入你的年龄&quot;))
</code></pre><p><strong>第二种</strong></p>
<pre><code>age=int(input(&quot;请输入你的年龄&quot;))        #请输入你的年龄
</code></pre><h2 id="1-2、多行注释"><a href="#1-2、多行注释" class="headerlink" title="1.2、多行注释"></a>1.2、多行注释</h2><p>在python中没有一个单独的多行注释标记，而是将注释内容包含在一对(‘’’…..’’’’)或者（”””…”””）<br><strong>语法格式：</strong></p>
<pre><code>&apos;&apos;&apos;
注释内容1
注释内容2
......
&apos;&apos;&apos;

或者

&quot;&quot;&quot;
注释内容1
注释内容2
......
&quot;&quot;&quot;
</code></pre><p>当然可以利用单行注释实现多行注释，如</p>
<pre><code>#注释内容1
#注释内容2
#....
</code></pre><h2 id="1-3、中文编码声明注释"><a href="#1-3、中文编码声明注释" class="headerlink" title="1.3、中文编码声明注释"></a>1.3、中文编码声明注释</h2><p>在python编写时，如果要指定字符编码，那么就需要在文件开头加上中文编码声明注释，来指定我们所需要的字符编码类型的中文编码，可以避免输出乱码<br><strong>语法格式：</strong></p>
<pre><code>#-*- coding:编码-*-
</code></pre><p>或者</p>
<pre><code>#  coding=编码
</code></pre><p>如</p>
<pre><code># coding=utf-8
</code></pre><p>==值得注意的是==，上面代码中的-*-是为了美观才加上的，没有任务特殊作用，故也可写为 <code># coding:编码</code></p>
<h1 id="2、代码缩进"><a href="#2、代码缩进" class="headerlink" title="2、代码缩进"></a>2、代码缩进</h1><p>python中使用代码缩进来区分代码的层次感，这点与c等一些语言不一样。</p>
<p>缩进可以使用空格键或者tap键，通常一个缩进量默认为为4个空格（可以修改），一个tap键为4个空格，不过，建议使用空格进行缩进。</p>
<p>注意：python中对代码缩进的要求非常严格，同一个级别的代码块的缩进量必须是相同的，否则将出现语法错误（SyntaxError）</p>
<h1 id="3、代码规范"><a href="#3、代码规范" class="headerlink" title="3、代码规范"></a>3、代码规范</h1><h2 id="3-1、编写规则"><a href="#3-1、编写规则" class="headerlink" title="3.1、编写规则"></a>3.1、编写规则</h2><p>pthon采用的是PEP8的编码规范，PEP是python Enhancement Proposal的缩写，8为版本</p>
<p>使用import进行导入模块时，注意，一次只导入一个模块。<br><strong>推荐写法：</strong></p>
<pre><code>import os
import request
</code></pre><p><strong>不推荐写法：</strong></p>
<pre><code>import os , request
</code></pre><p>不要在行尾添加“；”，也不用将2条命令放在同一行，然后用“；”隔开。python中换行代表中一个语句的结束。</p>
<p>建议每行不超过80个字，如果超过用（）连接，不推荐”\”<br>如,<strong>推荐</strong></p>
<pre><code>print(&quot;是多少级看过的力合股份客户广泛空间看过空间看过很快就卡。&quot;
            &quot;夫卡的风格看看吃饭大概开发地方&quot;)
</code></pre><p><strong>不推荐</strong></p>
<pre><code>print(&quot;是多少级看过的力合股份客户广泛空间看过空间看过很快就卡。\
            &quot;夫卡的风格看看吃饭大概开发地方&quot;)
</code></pre><p><strong>特殊情况除外</strong><br>1.导入模块语句过长<br>2.注释里的URL</p>
<p>可以使用空行增加代码的可读性，如·在定义方法之间空一行等等。</p>
<h2 id="3-2-命名规范"><a href="#3-2-命名规范" class="headerlink" title="3.2.命名规范"></a>3.2.命名规范</h2><p>1、模块名尽量短小，且全部小写，可以使用下划线，如</p>
<pre><code>game_age
</code></pre><p>2、包名尽量短小，且全部小写，不推荐使用下划线，如</p>
<pre><code>com.book
</code></pre><p>3、类名采用单词首写字母大即是Pascal风格。如</p>
<pre><code>BorrowBook
</code></pre><p>4、内部模块采用下划线加Pascal风格命名，如</p>
<pre><code>_BorrowBook
</code></pre><p>5、函数、类的属性和方法的命令规则和模块类似</p>
<p>6、常量命名时全部大写，使用可以使用下划线</p>
<p><strong>注意：</strong><br>使用单下划线开头的模块变量或函数是受保护的，在使用import*from语句从模块中不能导入。<br>使用双下划线开头的实例变量或方法是类私有的。</p>
<h1 id="4、基本的输入与输出"><a href="#4、基本的输入与输出" class="headerlink" title="4、基本的输入与输出"></a>4、基本的输入与输出</h1><h2 id="4-1、print（）函数"><a href="#4-1、print（）函数" class="headerlink" title="4.1、print（）函数"></a>4.1、print（）函数</h2><p><strong>print（）基础语法：</strong></p>
<pre><code>print(&quot;输出内容&quot;)
</code></pre><p>注意print（）语句输出后会自动换行，如果要一次输出多个内容，且不换行，可以用英文的半角逗号进行分开。如</p>
<pre><code>print(&quot;a&quot;,&quot;b&quot;)

输出结果为a b
</code></pre><p><strong>输出时间</strong><br>如</p>
<pre><code>import datetime                          # 调用时间模块datetime
d=datetime.datetime.now()
print(d)                                 # 输出当前日期和时间
print(d.strftime(&apos;%Y-%m-%d %H:%M:%S&apos;))   # 按格式输出当前时间
print(d.strftime(&apos;%I:%M %p&apos;))      
</code></pre><p>print（）不仅仅可以输出内容到屏幕还可以输出到指定文件<br>如</p>
<pre><code>fp = open(r&apos;F:\my.txt&apos;,&apos;a+&apos;)    # 打开文件，如果没有该文件将自动创建文件
print(&quot;hello world&quot;,file=fp)    # 输出到文件中
fp.close()                      # 关闭文件
</code></pre><h2 id="4-2、input（）函数"><a href="#4-2、input（）函数" class="headerlink" title="4.2、input（）函数"></a>4.2、input（）函数</h2><p><strong>作用</strong>：input（）在python中可以用来接收用户键盘输入的内容</p>
<p>如：</p>
<pre><code>b = input(&quot;输入字符:&quot;)
print(b+&quot;的ASCII码为&quot;,ord(b))
</code></pre><p>输出结果为：</p>
<pre><code>输入字符:b            # b为我们输入的字符
b的ASCII码为 98
</code></pre><p><strong>例子：根据输入的年份计算年龄</strong></p>
<pre><code>import datetime                                 # 调入时间模块datetime
imyear = input(&quot;请输入你的出生年份&quot;)               # 输入四位数的出生年份
nowyear = datetime.datetime.now().year          # 获取当前的年份
age = int(nowyear) - int(imyear)                # 计算年龄
print(&quot;你的年龄为&quot;+str(age))
</code></pre><p><strong>注意</strong>判断一个变量的类型可以使用type()函数</p>
<p><strong>例子：查单个字符的ACSII码器</strong></p>
<pre><code>b = 12
while b&gt;0:
    a = input(&quot;请输入字符：&quot;)
    print(a + &quot;的ASCII码为&quot;, +ord(a))
</code></pre><h1 id="5、保留字与标识符"><a href="#5、保留字与标识符" class="headerlink" title="5、保留字与标识符"></a>5、保留字与标识符</h1><h2 id="5-1、保留字"><a href="#5-1、保留字" class="headerlink" title="5.1、保留字"></a>5.1、保留字</h2><p>保留字就是被赋予特定意义的一些单词，这些单词不能被当作变量、函数、类、模块和其他对象的名称来使用（否则会报invalid syntax错误），python中保留字是区分大小写的，</p>
<p>python中的保留字，这边全部列出<br>| and      | as     | assert | break | class  |<br>| ——– | —— | —— | —– | —— |<br>| continue | def    | del    | elif  | except |<br>| finally  | for    | from   | False | global |<br>| if       | import | in     | is    | lambda |<br>| nonlocal | or     | pass   | raise | return |<br>| try      | True   | while  | with  | yield  |</p>
<p>当然如果我们忘记了也不用紧，可以通过2行代码查看保留字</p>
<pre><code>import keyword
print(keyword.kwlist)
</code></pre><h2 id="5-2、标识符"><a href="#5-2、标识符" class="headerlink" title="5.2、标识符"></a>5.2、标识符</h2><p>简单说标识符就是一个名字，用来识别变量、函数、类、模块和其他对象的名称。</p>
<p><strong>命名规则</strong><br>1、由字母、下划线和数字组成，并且第一个字母不能是数字。目前python中只允许使用ISO-Latin字符集中的字符A-Z和a~z.<br>2、不能使用Python中的保留字<br>例如，合法标识符</p>
<pre><code>USSSS
name
name123
name_age
</code></pre><p>不合法标识符</p>
<pre><code>4name             # 不能以数字开头
if                # 不能以保留字当作标识符
$name              #  不能使用特殊字符 空格、$、@、%等
</code></pre><p>3、区分字母大小写</p>
<p>4、以下划线开头的标识符具有特殊意义，要避免使用类似的标识符</p>
<p>以单下划线开头的标识符表示不能直接访问的类的属性，也不能太过from xxx import *导入</p>
<p>以双下划线开头的标识符表示类的私有成员</p>
<p>以双下划线开头和结尾的标识符是python中专用的标识，如<strong>int</strong>（）表示构造函数</p>
<p>5、尽量避免使用汉字作为标识符，尽管这是被允许的。</p>
<h1 id="6、变量"><a href="#6、变量" class="headerlink" title="6、变量"></a>6、变量</h1><h2 id="6-1、变量的命名规则与语法格式"><a href="#6-1、变量的命名规则与语法格式" class="headerlink" title="6.1、变量的命名规则与语法格式"></a>6.1、变量的命名规则与语法格式</h2><p><strong>变量的命名规则</strong></p>
<p>1、变量名必须是一个有效的标识符</p>
<p>2、变量名不能使用python中的保留字</p>
<p>3、慎用小写字母 l 和大写字母O</p>
<p>4、应该选择有意义的单词作为变量名</p>
<p><strong>语法格式</strong></p>
<pre><code>变量名 = value     #变量赋值
如
name = 12         # 创建变量name并赋值为12，类型为int
name = &quot;John&quot;     # 创建变量name并赋值为John，类型为str
</code></pre><p>注意，python中允许多个变量指向同一个值，但是他们对于的内存地址是否相同呢同，我们可以是内置函数id()来查看</p>
<p>例如</p>
<pre><code>a = 2014
b = 2014
print(&quot;a的地址为&quot;,+id(a))
print(&quot;b的地址为&quot;,+id(b))
</code></pre><p>输出</p>
<pre><code>a的地址为 2316677533424
b的地址为 2316677533424
</code></pre><h1 id="7、基本数据类型"><a href="#7、基本数据类型" class="headerlink" title="7、基本数据类型"></a>7、基本数据类型</h1><h2 id="7-1、数字类型"><a href="#7-1、数字类型" class="headerlink" title="7.1、数字类型"></a>7.1、数字类型</h2><p><strong>1、整数</strong><br>整数包括，十进制、八进制、十六进制</p>
<p>十进制不能以0开头</p>
<p>八进制在python3.x中必须以0o或0O开头，python2.x可以以0开头</p>
<p>十六进制必须以0x或0X开头</p>
<p><strong>2、浮点数</strong><br>浮点数表现形式，如2.7e2(科学计数法)，1.1414</p>
<p><strong>值得注意的是</strong>在使用浮点数进行计算时，可能会出现小数位数不确定的情况，如</p>
<pre><code>a = 0.2
b = 0.1
c= a + b
print(c)
</code></pre><p>我们觉得输出0.3，但是实际输出0.30000000000000004，<br>所有语言都有这个问题，可以忽略对于的小数位</p>
<p><strong>3、复数</strong><br>在python中复数与数学中的复数在形式上完全一样</p>
<h2 id="7-2、字符串类型"><a href="#7-2、字符串类型" class="headerlink" title="7.2、字符串类型"></a>7.2、字符串类型</h2><p>在python中字符串属于不可变序列<br>通常用单引号，双引号，三引号括起来。其中三引号内的字符序列可以分布在连续的多行中，而单引号，双引号内的字符序列必须在一行中。</p>
<p>注意如果需要表示复杂的字符串时可以进行引号的嵌套<br>如;</p>
<pre><code>print(&apos;&apos;&apos;&apos;___&apos; &quot;_&quot;***&apos;&apos;&apos;)
</code></pre><p>输出</p>
<pre><code>&apos;___&apos; &quot;_&quot;***
</code></pre><p>python中的字符串还支持转义字符<br>常见的转义字符如下表<br>| \    | 续行符                               |<br>| —- | ———————————— |<br>| \n   | 换行符                               |<br>| \r   | 回车符                               |<br>| \0   | 空                                   |<br>| \t   | 水平制表，用于横向跳到下一制表位     |<br>| \ “  | 双引号                               |<br>| \ ‘  | 单引号                               |<br>| \   | 一个反斜杠                           |<br>| \f   | 换页                                 |<br>| \0dd | 八进制数，dd表示字符，如\012代表换行 |<br>| \xhh | 十六进制，hh表示字符，如\x0a代表换行 |</p>
<p>注意在字符串定界符引号的前面加上R或r，将无视转义字符的存在。<br>如</p>
<pre><code>print(r&quot;hello\nworld&quot;)
print(&quot;hello\nworld&quot;)
</code></pre><p>输出</p>
<pre><code>hello\nworld
hello
world
</code></pre><h2 id="7-3、布尔类型"><a href="#7-3、布尔类型" class="headerlink" title="7.3、布尔类型"></a>7.3、布尔类型</h2><p>标识符True和False为布尔类型<br>True表示1，False表示0</p>
<p>注意布尔类型可以进行运算但是不建议进行运算</p>
<p>在python中所有对象都可以进行真假测试，只有以下几种情况为假其他都为真。<br>1、False或None</p>
<p>2、数值中的零，包括0、0.0、序数0</p>
<p>3、空序列，包括字符串，空元组、空列表、空字典</p>
<p>4、自定义对象的实例，对象的<strong>bool</strong>方法返回False或者<strong>len</strong>方法返回0.</p>
<h2 id="7-4、数据类型转换"><a href="#7-4、数据类型转换" class="headerlink" title="7.4、数据类型转换"></a>7.4、数据类型转换</h2><p>python是动态类型语言（也就是弱类型语言），不需要先声明变量类型，但在对变量进行操作时可能用到类型转换。</p>
<p> <strong>常用的类型转换函数</strong><br>| 函数                 | 作用                                               |<br>| ——————– | ————————————————– |<br>| int(x)               | 将x转为整型                                        |<br>| float（x）           | 将x转为浮点型                                      |<br>| complex(real[,imag]) | 创建一个复数                                       |<br>| str(x)               | 将x转为字符串                                      |<br>| repr(x)              | 将x转为表达式字符型                                |<br>| eval(str)            | 计算在字符串中的有效的python表达式，并返回一个对象 |<br>| chr(x)               | 将整数x转为字符                                    |<br>| ord(x)               | 将一个字符返回其所对应的整数值                     |<br>| hex(x)               | 将一个整数转化为一个16进制字符串                   |<br>| oct(x)               | 将一个整数转化为一个8进制字符串                    |</p>
<h1 id="8、运算符"><a href="#8、运算符" class="headerlink" title="8、运算符"></a>8、运算符</h1><h2 id="8-1、算术运算符"><a href="#8-1、算术运算符" class="headerlink" title="8.1、算术运算符"></a>8.1、算术运算符</h2><p>加（+）、减（-）、乘（*）、除（/）、取余数（%）、取整除（//）、幂（**）</p>
<p><strong>注意</strong><br>1、在%中如果除数（第二个操作数）是负数，那么得到的结果也是负数</p>
<p>2、使用/或//时，除数不能为0，不然会出现错误</p>
<p>3、在python2.x中/符号计算的结果为整数，而在python3.x中为浮点数，如<br>3/2，在python2.x中为1，在在python3.x中为1.5</p>
<h2 id="8-2、赋值运算符"><a href="#8-2、赋值运算符" class="headerlink" title="8.2、赋值运算符"></a>8.2、赋值运算符</h2><p>常见的赋值运算符有=、+=、-=、*=、/=、%=、**=、//=等<br>在使用时，就是把=号右边的值赋值给左边的变量，也可以进行某些运算后再赋值给左边的变量。<br>如x-=y,就是等于x=x-y,<br>例子如下</p>
<pre><code>x = 1
y = 2
x -= y
print(x)
</code></pre><p><strong>输出x=-1</strong></p>
<h2 id="8-3、比较（关系运算符）"><a href="#8-3、比较（关系运算符）" class="headerlink" title="8.3、比较（关系运算符）"></a>8.3、比较（关系运算符）</h2><p>对表达式或者变量的结果进行大小、真假等比较，如果比较结果为真返回True,否则为False</p>
<p>比较运算符有：</p>
<pre><code>&gt;、 &lt; 、==、!=、&gt;=、&lt;=
</code></pre><p>如果要判断一个变量是否在一个范围内可以使用 “ 值1&lt;变量a&lt;值2 ”</p>
<h2 id="8-4、逻辑运算符"><a href="#8-4、逻辑运算符" class="headerlink" title="8.4、逻辑运算符"></a>8.4、逻辑运算符</h2><p>主要包括 and（逻辑与） or（逻辑或） not（逻辑非）<br>and和or 的结合方向是从左到右<br>not的不一样是从右到左</p>
<h2 id="8-5、位运算符"><a href="#8-5、位运算符" class="headerlink" title="8.5、位运算符"></a>8.5、位运算符</h2><p>位运算符是对二进制进行计算的，所以需要把要执行的数据转化为二进制数，然后再进行位操作。<br>python中位运算符有位与（&amp;）、位或（|）、位异或（^）、位取反（~）、位左移（&lt;&lt;）、位右移（&gt;&gt;），</p>
<table>
<thead>
<tr>
<th>位运算符名称</th>
<th>算法</th>
</tr>
</thead>
<tbody>
<tr>
<td>位与（&amp;）</td>
<td>2个二进制数的对位都为1时才为1，否则为0 ，若2个操作数精度不同，则结果的精度与精度高的操作数相同</td>
</tr>
<tr>
<td>位或</td>
<td>2个二进制数的对位都为0时才为0，否则为1，若2个操作数精度不同，则结果的精度与精度高的操作数相同</td>
</tr>
<tr>
<td>位异或（^）</td>
<td>2个二进制数的对位相同时才为0，否则为1 ，若2个操作数精度不同，则结果的精度与精度高的操作数相同</td>
</tr>
<tr>
<td>位取反（~）</td>
<td>操作数中的1改为0,0改为1</td>
</tr>
<tr>
<td>位左移（&lt;&lt;）</td>
<td>将一个二进制操作数左移指定的位数，左边（高位段）溢出的位丢低，右边（低位段）的空位用0补充，位左移运算相当于乘以2的n次幂</td>
</tr>
<tr>
<td>右移（&gt;&gt;）</td>
<td>将一个二进制操作数右移指定的位数，右边（低位段）溢出的位用丢低，而在左边（高位段）的空位补充时，如果最高位为0，则在左侧补0，否则补1。位右移运算相当于除以2的n次幂</td>
</tr>
</tbody>
</table>
<p><strong>注意：</strong><br>由于移位运算符运算速度很快，所有在程序中遇到表达式乘以或除以2的n次幂时可以用移位运算符来代替</p>
<h2 id="8-6、运算符的优先级"><a href="#8-6、运算符的优先级" class="headerlink" title="8.6、运算符的优先级"></a>8.6、运算符的优先级</h2><p>python中运算符的运算规则是，优先级高的先执行，低的后执行，同一级的按从左往右进行操作。当然如果有括号，括号内的运算最先执行。在编写程序时尽量使用括号（）来限定运算次序，以免运算次序出错<br><strong>运算符的优先级（从高到低）</strong><br>| 类型                               |<br>| ———————————- |<br>| *<em>                                 |<br>| ~、+、-                            |<br>| </em>、/、%、//                        |<br>| +、-                               |<br>| &lt;&lt;、&gt;&gt;                             |<br>| ^                                  |<br>| 位或                               |<br>| &lt;、&lt;=、&gt;&gt;、=!、=、==（比较运算符） |</p>
<h1 id="9、流程控制语句"><a href="#9、流程控制语句" class="headerlink" title="9、流程控制语句"></a>9、流程控制语句</h1><h2 id="9-1、选择语句"><a href="#9-1、选择语句" class="headerlink" title="9.1、选择语句"></a>9.1、选择语句</h2><p><strong>1、最简单的if语句</strong><br>语法结构如下：</p>
<pre><code>if 表达式：
    语句块
</code></pre><p>注意在python中，当表达式的值为非零或者非空的字符串时。if语句也认为是条件成立（为真值）<br><strong>2、if…else语句</strong><br>语法结构如下：</p>
<pre><code>if 表达式：
    语句块1
else:
    语句块2
</code></pre><p><strong>技巧：</strong><br>if…else语句可以使用条件语句进行简化，如</p>
<pre><code>a = 1
if a &gt; 0:
    b =a
else:
    b = -a
print(b)
</code></pre><p>可以简化为（就是使用条件表达式）</p>
<pre><code>a = 1
b = a if a &gt; 0 else -a
print(b)
</code></pre><p><strong>3、if…elif…else语句</strong><br>语法结构</p>
<pre><code>if  表达式1：
    语句块1
elif 表达式2：
    语句块2
elif 表达式3：
    语句块3
...
else:
    语句块n
</code></pre><p>注意:if与elif都需要进行判断真假，而else不需要判断；else和elif都需要与if一起使用，不能单独使用</p>
<p>4、if语句的嵌套<br>if选择语句可以有多种嵌套方式，根据需要灵活运用。<br>如</p>
<pre><code>if 表达式1：
    if 表达式2：
        语句块1
    else:
        语句块2
</code></pre><h2 id="9-2、循环语句"><a href="#9-2、循环语句" class="headerlink" title="9.2、循环语句"></a>9.2、循环语句</h2><p>循环体就是一组被重复执行的语句。<br><strong>1、whie循环</strong><br>while循环结构</p>
<pre><code>while 条件表达式：
    循环体
</code></pre><p><strong>值得注意</strong>的是Python<strong>不支持do〜while语法</strong>、while（无限循环）和break组合起来替换 do ~ while<br>如</p>
<pre><code>n = 0
while True:         #无限循环...     
      print n
      n += 1
      if n == 10:
             break     #结束循环    
</code></pre><p><strong>2、for循环</strong><br>for循环结构</p>
<pre><code>for 迭代变量 in 对象：
    循环体
</code></pre><p>如：</p>
<pre><code>print(&quot;技术1+2+3+...+100结果为：&quot;)
result = 0
for i in range(101):
    result += i
print(result)
</code></pre><p>对<strong>range()这个函数进行</strong>简单的说明</p>
<p>range(start,end,step)</p>
<p>start为计数的起始值，可以省略，省略就从0开始</p>
<p>end为计数的结束值，但是不包括该值，如range(5),会输出0,1,2,3,4，不可省略</p>
<p>step为计数的步长，就是2个参数之间的间隔，可以省略，省略就默认为1</p>
<p><strong>小技巧</strong><br>在python3.x中，如果让print语句输出的内容在一行上可以使用下面这个语句</p>
<pre><code>print(result,end=&apos; 分隔符 &apos;)
</code></pre><p>for语句不仅可以循环数值，还可以逐个遍历字符串。</p>
<p>当然可以进行循环嵌套</p>
<h2 id="9-3、跳转语句和pass空语句"><a href="#9-3、跳转语句和pass空语句" class="headerlink" title="9.3、跳转语句和pass空语句"></a>9.3、跳转语句和pass空语句</h2><p><strong>1.break语句</strong><br>break语句通常会结合if语句使用，在某种条件下跳出循环。如果是嵌套循环，那么break语句将跳出最内层的循环</p>
<p>如while语句中使用break语句</p>
<pre><code>while 条件表达式1：
    执行代码
    if 条件表达式2：
        break
</code></pre><p>for语句中使用break语句</p>
<pre><code>for 迭代变量 in 变量
    if 条件表达式：
        break
</code></pre><p><strong>2.continue语句</strong><br>break语句通常会结合if语句使用，在某种条件下跳出当次循环，进行下一次循环。如果是嵌套循环，那么break语句将跳出最内层的当次循环</p>
<p>如while语句中使用break语句</p>
<pre><code>while 条件表达式1：
    执行代码
    if 条件表达式2：
        continue
</code></pre><p>for语句中使用break语句</p>
<pre><code>for 迭代变量 in 变量
    if 条件表达式：
        continue
</code></pre><p>3、pass空语句<br>不做任何事，一般起到占位作用，为得是方便以后进行处理</p>
<pre><code>for 迭代变量 in 变量
       if 条件表达式：
           语句块
       else:
           pass
</code></pre><h1 id="10、数字运算类内置函数"><a href="#10、数字运算类内置函数" class="headerlink" title="10、数字运算类内置函数"></a>10、数字运算类内置函数</h1><table>
<thead>
<tr>
<th>函数名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>abs(x)</td>
<td>求绝对值，参数可以是整数，也可以是复数，复数就输出复数的模</td>
</tr>
<tr>
<td>oct(x)</td>
<td>将一个数字转为8进制字符串</td>
</tr>
<tr>
<td>hex(x)</td>
<td>将一个数字转为16进制字符串</td>
</tr>
<tr>
<td>chr(x)</td>
<td>返回整数x对应的ASCII的字符</td>
</tr>
<tr>
<td>ord(x)</td>
<td>返回x对应的ASCII的值</td>
</tr>
<tr>
<td>complex([real[,image]])</td>
<td>创建一个复数</td>
</tr>
<tr>
<td>divmod(a,b)</td>
<td>分别取商和余数，整数和浮点数都可以</td>
</tr>
<tr>
<td>float(x)</td>
<td>将x转化为浮点数，如果没有参数返回0.0</td>
</tr>
<tr>
<td>int([x[,base]])</td>
<td>将x转化为int型，base为进制</td>
</tr>
<tr>
<td>long([x[,base]])</td>
<td>将x转化为long型，base为进制</td>
</tr>
<tr>
<td>pow(x,y[,z])</td>
<td>返回x的y次幂</td>
</tr>
<tr>
<td>range(strat,stop[,step])</td>
<td>产生一个序列，默认从零开始</td>
</tr>
<tr>
<td>round（x[,n]）</td>
<td>四舍五如=入</td>
</tr>
<tr>
<td>sum(iterable[,start])</td>
<td>对集合求和</td>
</tr>
<tr>
<td>bin(x)</td>
<td>将整数x转化为二进制字符串</td>
</tr>
<tr>
<td>bool([x])</td>
<td>将x转化为布尔类型</td>
</tr>
</tbody>
</table>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wrgiun.github.io/2019/08/02/bugku-16-26-writeup-misc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wr">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="giun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/08/02/bugku-16-26-writeup-misc/" class="post-title-link" itemprop="url">bugku 16-31 writeup(misc)</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-08-02 20:35:36" itemprop="dateCreated datePublished" datetime="2019-08-02T20:35:36+08:00">2019-08-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-09-12 20:32:01" itemprop="dateModified" datetime="2019-09-12T20:32:01+08:00">2019-09-12</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/bugkuCTF/" itemprop="url" rel="index"><span itemprop="name">bugkuCTF</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="十六、想蹭网络先破解wifi密码"><a href="#十六、想蹭网络先破解wifi密码" class="headerlink" title="十六、想蹭网络先破解wifi密码"></a>十六、想蹭网络先破解wifi密码</h2><p>题目给了我们一个数据包，且提示我们flag为wifi密码，</p>
<h3 id="第一步："><a href="#第一步：" class="headerlink" title="第一步："></a>第一步：</h3><p>打开文件，WIFI连接认证的重点在WPA的四次握手包，即eapol协议的包，过滤一下：<br>刚好四个包<br><img src="/2019/08/02/bugku-16-26-writeup-misc/1.png" alt="在这里插入图片描述"></p>
<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>既然是密码，还给了我们数据包，那么我们开始爆破，首先需要一个字典</p>
<p>因为手机号为11位，给了我们7位，故我们使用一下python代码生成字典<br>代码如下：</p>
<pre><code>import string
s = string.digits
f = open(&apos;1.txt&apos;, &apos;w&apos;)
for i in s:
    for j in s:
        for k in s:
            for o in s:
                f.write(&quot;1391040&quot;+i+j+k+o+&apos;\n&apos;)
</code></pre><h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>使用aircrack-ng进行爆破。</p>
<p>首先进行安装aircrack-ng，我在kali下进行操作。无法锁定的原因是我之前使用终端时，可能强制退出，还有命令在执行，那么我们就强制解除,命令如下</p>
<pre><code>sudo rm /var/cache/apt/archives/lock
sudo rm /var/lib/dpkg/lock
</code></pre><p><img src="/2019/08/02/bugku-16-26-writeup-misc/2.png" alt="在这里插入图片描述"><br>然后进行安装<strong>aircrack-ng</strong><br>命令如下</p>
<pre><code>apt-get install aircrack-ng
</code></pre><p>安装好用，进行爆破，得出密码</p>
<pre><code>aircrack-ng -a2 wifi.cap -w password.txt
</code></pre><p><img src="/2019/08/02/bugku-16-26-writeup-misc/3.png" alt="在这里插入图片描述"><br> <strong>aircrack-ng使用</strong></p>
<pre><code>aircrack-ng -w 字典文件 目标 

破解KEY,漫长的过程.漫不漫长取决于两个方面:一是网管的聪明程度(能否设置出复杂的密码),二是电脑的速度. 
usage:aircrack-ng[options]&lt;.cap/.ivsfile(s)&gt;

Commonoptions:
-a&lt;amode&gt;:暴破(1/WEP,2/WPA-PSK)

-e&lt;essid&gt;:选择essid为目标

-b&lt;bssid&gt;:选择ap的mac为目标,就是破解识别的关键字

-q:使用安静模式,无数出模式

-C&lt;macs&gt;:将所有的AP合并为一个虚拟的

–help:显示这个帮助
</code></pre><h2 id="十七、linux2"><a href="#十七、linux2" class="headerlink" title="十七、linux2"></a>十七、linux2</h2><p>根据题目提示，flag为key{}，那么使用winhex打开文件，并搜索key发现flag.</p>
<h2 id="十八、账号被盗了"><a href="#十八、账号被盗了" class="headerlink" title="十八、账号被盗了"></a>十八、账号被盗了</h2><p>点击getf lag，发现没有管理员权限，那么我们就想到cookie,使用抓包工具将cookie的值，改成ture，即可得到一个网站然而发现该网站我怎么也进去，打扰了。</p>
<h2 id="十九、细心的大象"><a href="#十九、细心的大象" class="headerlink" title="十九、细心的大象"></a>十九、细心的大象</h2><p>1、下载图片，使用winhex打开没发现什么有用的信息</p>
<p>2、用binwalk查看图片是否包含其他文件，成功分离出一个压缩文件<br><img src="/2019/08/02/bugku-16-26-writeup-misc/4.png" alt="在这里插入图片描述"><br>3、发现该压缩文件里有个图片是加密的，于是我们寻找密码</p>
<p>4、在用winhex看一下大象的图片，还是没发现重要信息，我们打开文件的属性，去看看文件的详细信息里面有什么信息，发现一串类似于base64加密的东西。<br><img src="/2019/08/02/bugku-16-26-writeup-misc/5.png" alt="在这里插入图片描述"><br>5、把该串信息当作密码输入，发现失败了，base64解密后，再输入，可以得到以下图片<br><img src="/2019/08/02/bugku-16-26-writeup-misc/6.png" alt="在这里插入图片描述"><br>使用winhex打开修改图片的高为500，就可以在图片里看到flag了<br><img src="/2019/08/02/bugku-16-26-writeup-misc/7.png" alt="在这里插入图片描述"></p>
<h2 id="二十、爆照"><a href="#二十、爆照" class="headerlink" title="二十、爆照"></a>二十、爆照</h2><p>1、首先对文件进行分析，发现1个压缩包，压缩包里有一个动态图和8个文件。更具文件的大小可以发现88、888、8888比较特殊。flag应该在这3张图片里。</p>
<p>使用winhex打开可以依次打开这3个文件可以发现这3个文件都是jpg文件。修改后缀名为jpg</p>
<p>可以发现88文件有个二维码，扫描得bilibili</p>
<p><img src="/2019/08/02/bugku-16-26-writeup-misc/8.png" alt="在这里插入图片描述"><br>888文件是个图片，查看文件详细信息可以发现一段base64加密的数据，解密得silisili<br><img src="/2019/08/02/bugku-16-26-writeup-misc/9.png" alt="在这里插入图片描述"><br>8888文件修改后缀名得到一张图片，详细信息没有有用信息，使用binwalk分析下，发现了一个压缩包。压缩包里有一个二维码图片，扫描得panama<br><img src="/2019/08/02/bugku-16-26-writeup-misc/10.png" alt="在这里插入图片描述"><br>故该题flag为{bilibili_silisili_panama}</p>
<h2 id="二十一、猫片（安恒）"><a href="#二十一、猫片（安恒）" class="headerlink" title="二十一、猫片（安恒）"></a>二十一、猫片（安恒）</h2><p>根据题目提示，这样应该是LBS隐写<br><img src="/2019/08/02/bugku-16-26-writeup-misc/11.png" alt="在这里插入图片描述"><br>1、下载附件修改后缀名为png</p>
<p>2、使用stegsolve打开，使用其DATA extract功能进行分析，根据提示为LSB,BGR隐写，经过下图操作，保存为png文件。<br><img src="/2019/08/02/bugku-16-26-writeup-misc/12.png" alt="在这里插入图片描述"><br>3、发现图片打不开，使用winhex打开查看，进行下图操作，然后保存，发现是半张二维码<br><img src="/2019/08/02/bugku-16-26-writeup-misc/13.png" alt="在这里插入图片描述"></p>
<p>4、进行图片高度的修改，可以得到一张完整的二维码，扫描下载flag.rar压缩包<br><img src="/2019/08/02/bugku-16-26-writeup-misc/14.png" alt="在这里插入图片描述"><br>打开文件，有上面的错误，flag文件里的内容，有点气，费尽脑子，发现无可奈何，于是开始查各种资料。<br><img src="/2019/08/02/bugku-16-26-writeup-misc/15.png" alt="在这里插入图片描述"><br>发现是ntfs文件数据流隐写，就说题目的提示为什么ntfs没用到。<br>使用ntfsstreamsEditor工具查找数据流，然后导出（注意这边一个坑：flag.rar这个压缩文件一定要用winrar来解压才能找得到数据流）</p>
<p><img src="/2019/08/02/bugku-16-26-writeup-misc/16.png" alt="在这里插入图片描述"><br>发现导出的数据流文件是python反编译文件。直接扔到在线我就进行python反编译  ，<a href="https://tool.lu/pyc/" target="_blank" rel="noopener">https://tool.lu/pyc/</a><br>得到以下结果</p>
<pre><code>import base64

def encode():
    flag = &apos;*************&apos;
    ciphertext = []
    for i in range(len(flag)):
        s = chr(i ^ ord(flag[i]))
        if i % 2 == 0:
            s = ord(s) + 10
        else:
            s = ord(s) - 10
        ciphertext.append(str(s))

    return ciphertext[::-1]

ciphertext = [
    &apos;96&apos;,
    &apos;65&apos;,
    &apos;93&apos;,
    &apos;123&apos;,
    &apos;91&apos;,
    &apos;97&apos;,
    &apos;22&apos;,
    &apos;93&apos;,
    &apos;70&apos;,
    &apos;102&apos;,
    &apos;94&apos;,
    &apos;132&apos;,
    &apos;46&apos;,
    &apos;112&apos;,
    &apos;64&apos;,
    &apos;97&apos;,
    &apos;88&apos;,
    &apos;80&apos;,
    &apos;82&apos;,
    &apos;137&apos;,
    &apos;90&apos;,
    &apos;109&apos;,
    &apos;99&apos;,
    &apos;112&apos;]
</code></pre><p>进行解密脚本的编写</p>
<pre><code>def decode():
    ciphertext = [
        &apos;96&apos;,
        &apos;65&apos;,
        &apos;93&apos;,
        &apos;123&apos;,
        &apos;91&apos;,
        &apos;97&apos;,
        &apos;22&apos;,
        &apos;93&apos;,
        &apos;70&apos;,
        &apos;102&apos;,
        &apos;94&apos;,
        &apos;132&apos;,
        &apos;46&apos;,
        &apos;112&apos;,
        &apos;64&apos;,
        &apos;97&apos;,
        &apos;88&apos;,
        &apos;80&apos;,
        &apos;82&apos;,
        &apos;137&apos;,
        &apos;90&apos;,
        &apos;109&apos;,
        &apos;99&apos;,
        &apos;112&apos;]
    ciphertext.reverse()             # 加密中使用ciphertext[::-1]进行取反，故使用reverse取反，
    flag = &apos;&apos;
    for i in range(len(ciphertext)):     # 加密中使用的是flag的长度，而ciphertext与flag长度一样
        if i % 2 == 0:
            s = int(ciphertext[i]) - 10    # 加密中s的值其实就是int(ciphertext[i])
        else:
            s = int(ciphertext[i]) + 10
        s = chr(i ^ s)                    # 加密中为i和flag异或，那么i与s异或即可的到flag
        flag += s
    return flag

if __name__ == &apos;__main__&apos;:
    flag = decode()
    print(flag)
</code></pre><h2 id="二十二、多彩"><a href="#二十二、多彩" class="headerlink" title="二十二、多彩"></a>二十二、多彩</h2><p>下载图片，放到Stegsolve里面跑下。<br>发现了<br><img src="/2019/08/02/bugku-16-26-writeup-misc/17.png" alt="在这里插入图片描述"><br>图片的名称又是lipstick.png (lipstick是口红意思），这边又有YSL，所以怀疑与YSL口红有关(圣罗兰口红).使用data extract分析下，发现PK开头，直接save bin 存为zip格式<br>![在这里插入图片描述]bugku-16-26-writeup-misc\18.png)<br>发现文件打不开，于是使用winhex打开，进行图中操作，成功打开文件，发现flag.txt文件加密</p>
<p><img src="/2019/08/02/bugku-16-26-writeup-misc/20.png" alt="在这里插入图片描述"><br>然后解压文件会产生错误，这里有个小坑注意，不能使用winrar解压，要使用360压缩等解压。<br><img src="/2019/08/02/bugku-16-26-writeup-misc/19.png" alt="在这里插入图片描述"><br>未完待续，卡住了这题</p>
<h2 id="二十三、旋转跳跃"><a href="#二十三、旋转跳跃" class="headerlink" title="二十三、旋转跳跃"></a>二十三、旋转跳跃</h2><p>一看题目，提示我们密码，还是音频文件，目测是音频隐写。<br>上工具MP3Stego。可以参考我的<a href="https://mp.csdn.net/postedit/89817197" target="_blank" rel="noopener">这篇博客</a><br><img src="/2019/08/02/bugku-16-26-writeup-misc/E:/hexo\blog\wrgiun\source\_posts\bugku-16-26-writeup-misc\22.png" alt="在这里插入图片描述"><br>可以得到一个txt文件，，得到flag<br><img src="/2019/08/02/bugku-16-26-writeup-misc/21.png" alt="在这里插入图片描述"></p>
<h2 id="二十四、普通的二维码"><a href="#二十四、普通的二维码" class="headerlink" title="二十四、普通的二维码"></a>二十四、普通的二维码</h2><p>扫描会得到一句话：我不会告诉你flag就在这里。使用winhex打开发现最后一段数字，应该是8进制数。<br><img src="/2019/08/02/bugku-16-26-writeup-misc/23.png" alt="在这里插入图片描述"><br>编写python脚本转ASCII码，即可得到flag</p>
<pre><code>a = &apos;146154141147173110141166145137171060125137120171137163143162151160164137117164143137124157137124145156137101163143151151041175&apos;
flag = &apos;&apos;
for i in range(len(a) // 3):
    flag += chr(int(a[i * 3:i * 3 + 3], 8))     # 八进制3为一个ASCII码
print(flag)
</code></pre><h2 id="二十五、乌云邀请码"><a href="#二十五、乌云邀请码" class="headerlink" title="二十五、乌云邀请码"></a>二十五、乌云邀请码</h2><p>经过一些尝试，原理是LSB隐写，使用Stegsolve工具的Data Extract功能即可得到flag<br><img src="/2019/08/02/bugku-16-26-writeup-misc/24.png" alt="在这里插入图片描述"></p>
<h2 id="二十六、神秘文件"><a href="#二十六、神秘文件" class="headerlink" title="二十六、神秘文件"></a>二十六、神秘文件</h2><p>下载附件，发现里面有一张图片，和一个压缩包，且压缩包里也有一个一模一样不过是加密的图片。<br>1、于是我们想到明文攻击。使用ARCHPR工具进行攻击。</p>
<p>2、注意把logo压缩成压缩包，并且把flag.zip的压缩包里的doc文件删除。</p>
<p>3、这边有一个坑，我们的压缩算法要与flag.zip的压缩算法一样才可以。我卡了好久在这。</p>
<p>4、可以复制flag.zip然后存入logo.png文件，然后修改名字为logo.zip。</p>
<p>5、可以得到口令，输入口令我们发现是一个笑脸<br><img src="/2019/08/02/bugku-16-26-writeup-misc/26.png" alt="在这里插入图片描述"><br>进行binwalk文件分离<br><img src="/2019/08/02/bugku-16-26-writeup-misc/27.png" alt="在这里插入图片描述"><br>然后在docProps文件下有个flag.txt，进行base64解码即可得flag。<br>破解zip加密的常见的几种方法，可以参考这个大佬的<a href="https://www.cnblogs.com/ECJTUACM-873284962/p/9387711.html" target="_blank" rel="noopener">博客</a></p>
<h2 id="二十八、图穷比见"><a href="#二十八、图穷比见" class="headerlink" title="二十八、图穷比见"></a>二十八、图穷比见</h2><p>下载附件<br>，使用winhex打开，在文件最后面发现一大堆16进制，然后复制到notepad里使用插件里的converter进行转化为ascii码。发现是一对坐标，然后把左右括号去掉，把逗号换成空格<br><img src="/2019/08/02/bugku-16-26-writeup-misc/28.png" alt="在这里插入图片描述"><br>然后使用gnuplot工具画图<br>使用命令 <code>plot &quot;E:\\gnuplot\\2.txt&quot;</code><br><img src="/2019/08/02/bugku-16-26-writeup-misc/29.png" alt="在这里插入图片描述"><br><img src="/2019/08/02/bugku-16-26-writeup-misc/30.png" alt="在这里插入图片描述"><br>扫描得flag</p>
<h2 id="二十九、convert"><a href="#二十九、convert" class="headerlink" title="二十九、convert"></a>二十九、convert</h2><p>一、打开文件发现一堆二进制，保存为2.txt文件，那肯定得转化为16进制，这边我尝试直接利用脚本转化为10进制然后转化为ASCII,发现是个rar文件，却因为有些字体识别不了乱码，打不开文件。</p>
<pre><code>with open(&apos;2.txt&apos;, &apos;w&apos;,encoding=&apos;utf-8&apos;) as f1:
    with open(&apos;1.txt&apos;,encoding=&apos;utf-8&apos;) as f2:
        while True:
            temp = f2.read(4)
            if temp:
                temp = int(temp, 2)   # 二进制转10进制
                temp = hex(temp)      # 10进制转16进制
                f1.write(temp[2:])    # 去掉0x
            else:
                break
</code></pre><p>二、利用Notepad++自带的十六进制转ascii，发现rar文件头，将文件另存为一个rar文件。<br>打开文件发现里面有一个图片，我们先看下属性，发现有一串base64码。<br>然后在线解密，发现flag.</p>
<h2 id="三十、听首音乐"><a href="#三十、听首音乐" class="headerlink" title="三十、听首音乐"></a>三十、听首音乐</h2><p>听了一会后，没听出啥，使用audacity进行分析，发现有点像摩斯密码<br><img src="/2019/08/02/bugku-16-26-writeup-misc/31.png" alt="在这里插入图片描述"><br>然后放大，摩斯密码有两种“符号”用来表示字符：点（.）和划（-），或叫“滴”（Dit）和“答”（Dah）。（滴，1t；嗒，3t），<br>分析，写出摩斯密码为（<strong>每一组后面加上空格</strong>）</p>
<pre><code>..... -... -.-. ----. ..--- ..... -.... ....- ----. -.-. -.. ----- .---- ---.. ---.. ..-. ..... ..--- . -.... .---- --... -.. --... ----- ----. ..--- ----. .---- ----. .---- -.-.
</code></pre><p>在线解密<a href="http://www.zhongguosou.com/zonghe/moErSiCodeConverter.aspx" target="_blank" rel="noopener">http://www.zhongguosou.com/zonghe/moErSiCodeConverter.aspx</a><br><img src="/2019/08/02/bugku-16-26-writeup-misc/32.png" alt="在这里插入图片描述"></p>
<h2 id="三十一、好多数值"><a href="#三十一、好多数值" class="headerlink" title="三十一、好多数值"></a>三十一、好多数值</h2><p>打开题目发现一堆数值，有点像rgb的值，255,255,255就是白色。<br>那么题目的思路就是一个根据这堆值生成图片</p>
<p>把行61366因式分解分解成两个数相乘（503*122）</p>
<pre><code>from PIL import Image
x = 503  # x坐标  通过对txt里的行数进行整数分解
y = 122  # y坐标  x*y = 行数

im = Image.new(&quot;RGB&quot;, (x, y))  # 创建图片
with open(&apos;1.txt&apos;) as file:  # 打开rbg值文件
    # 通过一个个rgb点生成图片
    for i in range(0,x):
        for j in range(0,y):
            line = file.readline()  # 获取一行的rgb值
            rgb = line.split(&quot;,&quot;)  # 分离rgb
            im.putpixel((i,j),(int(rgb[0]),int(rgb[1]),int(rgb[2])))  # rgb转化为像素
    im.show()
</code></pre><p><img src="/2019/08/02/bugku-16-26-writeup-misc/33.png" alt="在这里插入图片描述"></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="wr">
            
              <p class="site-author-name" itemprop="name">wr</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">46</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wr</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.0.0</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.0"></script>

  <script src="/js/src/motion.js?v=7.0.0"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.0"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.0"></script>




  

  


  <script src="/js/src/bootstrap.js?v=7.0.0"></script>



  



  





  

  

  

  

  

  

  

  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function(i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap');
      $(e).after($wrap);
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
        var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
          return $(e).text();
        }).toArray().join('\n');
        var ta = document.createElement('textarea');
        var range = document.createRange(); //For Chrome
        var sel = window.getSelection(); //For Chrome
        var yPosition = window.pageYOffset || document.documentElement.scrollTop;
        ta.style.top = yPosition + 'px'; //Prevent page scroll
        ta.style.position = 'absolute';
        ta.style.opacity = '0';
        ta.value = code;
        ta.textContent = code; //For FireFox
        ta.contentEditable = true;
        ta.readOnly = false;
        document.body.appendChild(ta);
        range.selectNode(ta);
        sel.removeAllRanges();
        sel.addRange(range);
        ta.setSelectionRange(0, code.length);
        var result = document.execCommand('copy');
        
          if (result) $(this).text('复制成功');
          else $(this).text('复制失败');
        
        ta.blur(); //For iOS
        $(this).blur();
      })).on('mouseleave', function(e) {
        var $b = $(this).find('.copy-btn');
        setTimeout(function() {
          $b.text('复制');
        }, 300);
      }).append(e);
    })
  </script>


  

</body>
</html>
